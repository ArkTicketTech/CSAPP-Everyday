# 深入理解计算机系统(CSAPP)

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHtt00XBvS4gFjhfw7b%2F-MHttfdsLWUPlWSz8ANj%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88.pdf..20200922190952319_00.png?alt=media&token=f65abe2d-0a5c-4e2c-91b8-5f008051209c)

> 作者：兰德尔 E. 布莱恩特

## 第 1 章：计算机系统漫游

**计算机系统**是由硬件和系统软件组成的，它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有相似的硬件和软件组件，它们又执行着相似的功能。一些程序员希望深入了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的，以此来提高自身的技能。本书便是为这些读者而写的。

在 Kernighan 和 Ritchie 的关于 C 编程语言的经典教材【61】中，他们通过图 1-1 中所示的 hello 程序来向读者介绍 C。尽管 hello 程序非常简单，但是为了让它实现运行，系统的每个主要组成部分都需要协调工作。从某种意义上来说，本书的目的就是要帮助你了解当你在系统上执行 hello 程序时，系统发生了什么以及为什么会这样。

```c
#include <stdio.h>
int main()
{
    printf("hello, world\n");
    return 0;
}
```

我们通过跟踪 hello 程序的生命周期来开始对系统的学习——从它被程序员创建开始，到在系统上运行，输出简单的消息，然后终止。我们将沿着这个程序的生命周期，简要地介绍一些逐步出现的关键概念、专业术语和组成部分。后面的章节将围绕这些内容展开。

### **1.1 信息就是位 + 上下文**

hello 程序的生命周期是从一个**源程序**（或者说源文件）开始的，即程序员通过编辑器创建并保存的文本文件，文件名是 hello.c。源程序实际上就是一个由值 0 和 1 组成的位（又称为比特）序列，8 个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。

大部分的现代计算机系统都使用 ASCII 标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数值来表示每个字符。比如，图 1-2 中给出了 hello.c 程序的 ASCII 码表示。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2Fsync%2Fb21fa77cbcdfba62be01af7b13234cf5eed3c055.png?generation=1624553050781139&alt=media" alt="img" style="zoom: 50%;" />

程序如何存储在文件中？`hello.c`程序是以字节序列的方式储存在文件中的。每个字节都有一个整数值，对应于某些字符。例如，第一个字节的整数值是 35，它对应的就是字符 “#”。第二个字节的整数值为 105，它对应的字符是 ‘i’，依此类推。注意，每个文本行都是以一个看不见的换行符 ‘\n’ 来结束的，它所对应的整数值为 10。像 hello.c 这样只由 ASCII 字符构成的文件称为**文本文件**，所有其他文件都称为**二进制文件**。

hello.c 的表示方法说明了一个基本思想∶系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串**比特**表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。 作为程序员，我们需要了解数字的机器表示方式，因为它们与实际的整数和实数是不同的。它们是对真值的有限近似值，有时候会有意想不到的行为表现。这方面的基本原理将在第 2 章中详细描述。

> **旁注 编程语言的起源**
>
> C 语言是**贝尔实验室**的 **Dennis Ritchie** 于 **1969 年 ~ 1973 年间创建的。**美国国家标准学会（American National Standards Institute，ANSI）在 1989 年颁布了 ANSI C 的标准，后来 C 语言的标准化成了国际标准化组织（International StandardsOrganization，ISO）的责任。这些标准定义了C语言和一系列函数库，即所谓的 **C 标准库**。Kernighan 和 Ritchie 在他们的经典著作中描述了 ANSI C，这本著作被人们满怀感情地称为 “K&R”【61】。用 Ritchic 的话来说【92】，C 语言是“古怪的、有缺陷的，但同时也是一个巨大的成功”。为什么会成功呢?
>
> - **C 语言与 Unix 操作系统关系密切。**C 从一开始就是作为一种用于 Unix 系统的程序语言开发出来的。大部分 Unix 内核（操作系统的核心部分），以及所有支撑工具和函数库都是用 C 语言编写的。20 世纪 70 年代后期到 80 年代初期，Unix 风行于高等院校，许多人开始接触 C 语言并喜欢上它。因为 Unix 几乎全部是用 C 编写的，它可以很方便地移植到新的机器上，这种特点为 C 和 Unix 赢得了更为广泛的支持。
> - **C 语言小而简单。**C语言的设计是由一个人而非一个协会掌控的，因此这是一个简洁明了、没有什么冗赘的设计。K&R 这本书用大量的例子和练习描述了完整的 C 语言及其标准库，而全书不过  261 页。C 语言的简单使它相对而言易于学习，也易于移植到不同的计算机上。 
> - **C语言是为实践目的设计的。**C 语言是设计用来实现 Unix 操作系统的。后来，其他人发现能够用这门语言无障碍地编写他们想要的程序。
>
> C 语言是系统级编程的首选，同时它也非常适用于应用级程序的编写。然而，它也并非适用于所有的程序员和所有的情况。C 语言的指针是造成程序员困惑和程序错误的一个常见原因。同时，C 语言还缺乏对非常有用的抽象的显式支持，例如类、对象和异常。像 C++ 和 Java 这样针对应用级程序的新程序语言解决了这些问题。

### 1.2 程序被其他程序翻译成不同的格式

hello程序的生命周期是从一个高级C语言程序开始的。然而，为了在系统上运行hello.c程序，每条 C 语句都必须被其他程序转化为一系列的低级**机器语言**指令。然后这些指令按照一种称为**可执行目标程序**的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为**可执行目标文件。**

在 Unix 系统上，从源文件到目标文件的转化是由**编译器驱动程序**完成的∶

```shell
linux> gcc -o hello hello.c
```

程序执行的四个阶段：GCC 编译器驱动程序读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译过程可分为四个阶段完成，如图 1-3 所示。执行这四个阶段的程序（**预处理器**、**编译器**、**汇编器**和**链接器**）一起构成了**编译系统**（compilation system）。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzZfEIY91yIzOD0Rce%2F-MHzZpZI-gs8CNcwHIyv%2F01-03%20compilation%20systems.png?alt=media&token=91ca688e-1cfc-4ec6-8b99-d52e672bbac7" alt="img" style="zoom:50%;" />

+ **预处理阶段。**预处理器（cpp）根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c 中第 1 行的`#include <stdio.h>`命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。 

+ **编译阶段。**编译器（ccl）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个**汇编语言程序**。该程序包含函数 main 的定义，如下所示∶

```c
main:
    subq $8, %rsp
    movl $.LC0, %edi
    call puts
    movl $0, %eax
    addq $8, %rsp
    ret
```

定义中 2～7 行的每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C编译器和 Fortran 编译器产生的输出文件用的都是一样的汇编语言。

+ **汇编阶段。**接下来，汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做**可重定位目标程序**（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码。如果我们在文本编辑器中打开 hello.o文件，将看到一堆乱码。
+ **链接阶段。**请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器（ld）就负责处理这种合并。结果就得到 hello 文件，它是一个**可执行目标文件**（或者简称为**可执行文件**），可以被加载到内存中，由系统执行。

> 旁注 - GNU项目
>
> GCC 是 GNU（GNU 是GNU's Not Unix 的缩写）项目开发出来的众多有用工具之一。GNU 项目是 1984 年由 Richard Stallman 发起的一个免税的慈善项目。该项目的目标非常宏大，就是开发出一个完整的类 Unix 的系统，其源代码能够不受限制地被修改和传播。GNU 项目已经开发出了一个包含 Unix 操作系统的所有主要部件的环境，但内核除外，内核是由 Linux 项目独立发展而来的。GNU 环境包括 EMACS 编辑器、GCC 编译器、GDB 调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。GCC 编译器已经发展到支持许多不同的语言，能够为许多不同的机器生成代码。支持的语言包括 C、C++、Fortran、Java、Pascal、面向对象 C 语言（Objective-C）和 Ada。
>
> GNU 项目取得了非凡的成绩，但是却常常被忽略。现代开放源码运动（通常和 Linux 联系在一起）的思想起源是 GNU 项目中自由软件（free software）的概念。（此处的free 为自由言论（free speech）中的“自由”之意，而非免费啤酒（free beer）中的“免费”之意。）而且，Linux 如此受欢迎在很大程度上还要归功于 GNU 工具，它们给 Linux 内核提供了环境。

### 1.3 了解编译系统如何工作是大有益处的

对于像 hello.c 这样简单的程序，我们可以依靠编译系统生成正确有效的机器代码。但是，有一些重要的原因促使程序员必须知道编译系统是如何工作的。 

- **优化程序性能。**现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序员，我们无须为了写出高效代码而去了解编译器的内部工作。但是，为了在 C 程序中做出好的编码选择，我们确实需要了解一些机器代码以及编译器将不同的 C 语句转化为机器代码的方式。比如，一个 switch 语句是否总是比一系列的 if-else 语句高效得多？一个函数调用的开销有多大？while 循环比 for 循环更有效吗？指针引用比数组索引更有效吗？为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多呢？为什么我们只是简单地重新排列一下算术表达式中的括号就能让函数运行得更快?？

  在第3章中，我们将介绍 x86-64，最近几代 Linux、Macintosh 和 Windows 计算机的机器语言。我们会讲述编译器是怎样把不同的 C 语言结构翻译成这种机器语言的。在第 5 章中，你将学习如何通过简单转换C语言代码，帮助编译器更好地完成工作，从而调整 C 程序的性能。在第 6 章中，你将学习存储器系统的层次结构特性，C 语言编译器如何将数组存放在内存中，以及 C 程序又是如何能够利用这些知识从而更高效地运行。 

- **理解链接时出现的错误。**根据我们的经验，一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。比如，链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？如果你在不同的 C 文件中定义了名字相同的两个全局变量会发生什么？静态库和动态库的区别是什么？我们在命令行上排列库的顺序有什么影响？最严重的是，为什么有些链接错误直到运行时才会出现？在第 7 章中，你将得到这些问题的答案。 

- **避免安全漏洞。**多年来，缓冲区溢出错误是造成大多数网络和 Internet 服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。作为学习汇编语言的一部分，我们将在第 3 章中描述堆栈原理和缓冲区溢出错误。我们还将学习程序员、编译器和操作系统可以用来降低攻击威胁的方法。

### **1.4 处理器读并解释储存在内存中的指令**

此刻，hello.c 源程序已经被编译系统翻译成了可执行目标文件 hello，并被存放在磁盘上。要想在 Unix 系统上运行该可执行文件，我们将它的文件名输入到称为 shell 的应用程序中∶ 

```shell
linux> ./hello
hello, world
linux> 
```

shell 是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的名字，它将加载并运行这个文件。所以在此例中，shell 将加载并运行 hello 程序，然后等待程序终止。hello 程序在屏幕上输出它的消息，然后终止。shell 随后输出一个提示符，等待下一个输入的命令行。

#### 1.4.1 系统的硬件组成

为了理解运行 hello 程序时发生了什么，我们需要了解一个典型系统的硬件组织，如图 1-4 所示。这张图是近期 Intel 系统产品族的模型，但是所有其他系统也有相同的外观和特性。现在不要担心这张图很复杂——我们将在本书分阶段对其进行详尽的介绍。

##### 1. 总线

贯穿整个系统的是一组电子管道，称作**总线**，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。**字中的字节数（即字长）是一个基本的系统参数**，各个系统中都不尽相同。现在的大多数机器字长要么是 4 个字节（32 位），要么是 8 个字节（64 位）。本书中，我们不对字长做任何固定的假设。相反，我们将在需要明确定义的上下文中具体说明一个“字”是多大。 

##### 2. I/O 设备

I/O（输入/输出）设备是系统与外部世界的联系通道。我们的示例系统包括四个 I/O 设备∶作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器（简单地说就是磁盘）。最开始，**可执行程序 hello 就存放在磁盘上**。

每个 I/O 设备都通过一个**控制器**或**适配器**与 I/O 总线相连。**控制器和适配器之间的区别主要在于它们的封装方式**。**控制器是 I/O 设备本身或者系统的主印制电路板（通常称作主板）上的芯片组**。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在 I/O 总线和 I/O 设备之间传递信息。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzautgnqCcwmhp1v0t%2F-MHzbJTPxV8WF5Cpigw-%2F01-04%20system%20hardwares.png?alt=media&token=78949ed7-8d53-4392-b21d-e6123cd2dc50" alt="img" style="zoom:50%;" />

> 图 1-4 一个典型系统的硬件组成
>
> CPU：中央处理单元；ALU：算术/逻辑单元；PC：程序计数器；USB：通用串行总线

第 6 章会更多地说明磁盘之类的 I/O 设备是如何工作的。在第 10 章中，你将学习如何在应用程序中利用 Unix I/O 接口访问设备。我们将特别关注网络类设备，不过这些技术对于其他设备来说也是通用的。 

##### 3. 主存

**主存**是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组**动态随机存取存储器**（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。与 C 程序变量相对应的数据项的大小是根据类型变化的。比如，在运行 Linux 的 x86-64 机器上，short 类型的数据需要 2 个字节，int 和 float 类型需要 4 个字节，而 long 和 double 类型需要 8 个字节。 第 6 章将具体介绍存储器技术，比如 DRAM 芯片是如何工作的，它们又是如何组合起来构成主存的。 

##### 4. 处理器

**中央处理单元**（CPU），简称**处理器**，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或**寄存器**），称为**程序计数器**（PC）。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。

> PC 也普遍地被用来作为“个人计算机”的缩写。然面，两者之间的区别应该可以很清楚地从上下文中看出来。

从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新 PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。

这样的简单操作并不多，它们围绕着**主存**、**寄存器文件**（register file）和**算术/逻辑单元**（ALU）进行。寄存器文件是一个小的存储设备，**由一些单个字长的寄存器组成，每个寄存器都有唯一的名字**。ALU 计算新的数据和地址值。下面是一些简单操作的例子，CPU 在指令的要求下可能会执行这些操作。

- **加载：**从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。

- **存储：**从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。 

- **操作：**把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。 

- **跳转：**从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖 PC 中原来的值。

处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的**指令集架构**和处理器的**微体系结构**区分开来：**指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。**在第 3 章研究机器代码时，我们考虑的是机器的指令集架构所提供的抽象性。第 4 章将更详细地介绍处理器实际上是如何实现的。第 5 章用一个模型说明现代处理器是如何工作的，从而能预测和优化机器语言程序的性能。

#### 1.4.2 运行 hello 程序

前面简单描述了系统的硬件组成和操作，现在开始介绍当我们运行示例程序时到底发生了些什么。在这里必须省略很多细节，稍后会做补充，但是现在我们将很满意于这种整体上的描述。 初始时，shell 程序执行它的指令，等待我们输人一个命令。当我们在键盘上输人字符串 “./hello” 后，shell 程序将字符逐一读入寄存器，再把它存放到内存中，如图 1-5 所示。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzbjGHhw9P3BFyZTKk%2F-MHzeim3VxH0O0hbd4Uh%2F01-05%20read%20hello%20from%20keyboard.png?alt=media&token=5956c888-1728-418c-8d21-83432d24ce77" alt="img" style="zoom:50%;" />

图 1-5 从键盘上读取 hello 命令

当我们在键盘上敲回车键时，shell 程序就知道我们已经结束了命令的输入。然后 shell 执行一系列指令来加载可执行的 hello 文件，这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串 “hello, world\n”。

利用**直接存储器存取**（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存。这个步骤如图 1-6 所示。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzfLHp5XFUFTsUJAKx%2F-MHzfN_gwQJSG2YnC5Gk%2F01-06%20%E4%BB%8E%E7%A3%81%E7%9B%98%E5%8A%A0%E8%BD%BD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%BB%E5%AD%98.png?alt=media&token=9a49507e-f20d-4af8-b277-bebf57cc597f" alt="img" style="zoom:50%;" />

图 1-6 从磁盘加载可执行文件到主存

一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将 “hello, world\n” 字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。这个步骤如图 1-7 所示。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzfVZwd5iIwJfDkOPj%2F-MHzffvOB90toXVTON5G%2F01-07%20%E5%B0%86%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%8E%E5%AD%98%E5%82%A8%E5%99%A8%E5%86%99%E5%88%B0%E6%98%BE%E7%A4%BA%E5%99%A8.png?alt=media&token=d0480c36-9640-4159-bc71-8f5db262a6ba" alt="img" style="zoom:50%;" />

图 1-7 将输出字符串从存储器写到显示器

### 1.5 高速缓存至关重要

这个简单的示例揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。hello 程序的机器指令最初是存放在磁盘上，当程序加载时，它们被复制到主存；**当处理器运行程序时，指令又从主存复制到处理器**。相似地，数据串 “hello, world\n” 开始时在磁盘上，然后被复制到主存，最后从主存上复制到显示设备。

开销：从程序员的角度来看，**这些复制就是开销，减慢了程序“真正”的工作。因此，系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。**

根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。比如说，一个典型系统上的磁盘驱动器可能比主存大 1000 倍，但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大 1000 万倍。

类似地，**一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节**。然而，**处理器从寄存器文件中读数据比从主存中读取几乎要快 100 倍**。更麻烦的是，随着这些年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。 针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为**高速缓存存储器**（cache memory，简称为 **cache 或高速缓存**），作为暂时的集结区域，存放处理器近期可能会需要的信息。图 1-8 展示了一个典型系统中的高速缓存存储器。位于处理器芯片上的 L1 高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的 L2 高速缓存通过一条特殊的总线连接到处理器。进程访问 L2 高速缓存的时间要比访问 L1 高速缓存的时间长 5 倍，但是这仍然比访问主存的时间快 5~10 倍。L1 和 L2 高速缓存是用一种叫做**静态随机访问存储器**（SRAM）的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存∶L1、L2 和 L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzgjEHwVipe3eiOGOu%2F-MHzhPegzo92o0T7BqNJ%2F01-08%20%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8.png?alt=media&token=c8cb0d2f-bb3c-4a99-8c16-b9db3835a0c4" alt="img" style="zoom:50%;" />

图 1-8 高速缓存存储器

意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。你将在第 6 章里学习这些重要的设备以及如何利用它们。

### 1.6 存储设备形成层次结构

在处理器和一个较大较慢的设备（例如主存）之间插**入**一个更小更快的存储设备（例如高速缓存）的想法已经成为一个普遍的观念。实际上，每个计算机系统中的存储设备都被组织成了一个**存储器层次结构**，如图 1-9 所示。在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第 0 级或记为 L0。这里我们展示的是三层高速缓存 L1 到 L3，占据存储器层次结构的第 1 层到第 3 层。主存在第 4 层，以此类推。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzhX2vrq6mFP3tN9EU%2F-MHzi1Edm9hUsnQdAkkL%2F01-09%20%E4%B8%80%E4%B8%AA%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E7%9A%84%E7%A4%BA%E4%BE%8B.png?alt=media&token=afb8208e-17dc-475f-9f61-acf0bd0ca891" alt="img" style="zoom:50%;" />

图 1-9 一个存储器层次结构的示例

存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是 L1 的高速缓存，L1 是 L2 的高速缓存，L2 是 L3 的高速缓存，L3 是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。 正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。第 6 章将更详细地讨论这个问题。

### **1.7 操作系统管理硬件**

让我们回到 hello 程序的例子。当 shell 加载和运行 hello 程序时，以及 hello 程序输出自己的消息时，shell  和 hello 程序都没有直接访问键盘、显示器、磁盘或者主存。取而代之的是，它们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，如图 1-10 所示。所有应用程序对硬件的操作尝试都必须通过操作系统。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzi6gd3YrHlZtNiGnn%2F-MHziSfWGuHFYHC0c9kb%2F01-10%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E5%B1%82%E8%A7%86%E5%9B%BE.png?alt=media&token=4166d09b-61ba-4d06-a185-2484867737fe" alt="img" style="zoom:50%;" />

图 1-10 计算机系统的分层视图

操作系统有两个基本功能∶（1）防止硬件被失控的应用程序滥用；（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（**进程**、**虚拟内存**和**文件**）来实现这两个功能。如图 1-11 所示，文件是对 I/O 设备的抽象表示，虚拟内存是对主存和磁盘 I/O 设备的抽象表示，进程则是对处理器、主存和 I/O 设备的抽象表示。我们将依次讨论每种抽象表示。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzi6gd3YrHlZtNiGnn%2F-MHzibk5fcFFoAm7QN5W%2F01-11%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%A1%A8%E7%A4%BA.png?alt=media&token=27d4ecf7-428d-43ca-a754-c841c327f065" alt="img" style="zoom:50%;" />

图 1-11 操作系统提供的抽象表示

> 旁注 - Unix、Posix 和标准 Unix 规范
>
> 20 世纪 60 年代是大型、复杂操作系统盛行的年代，比如 IBM 的 OS/360 和 Honey-well 的 Multics 系统。OS/360 是历史上最成功的软件项目之一，而 Multics 虽然持续存在了多年，却从来没有被广泛应用过。贝尔实验室曾经是 Multics 项目的最初参与者，但是因为考虑到该项目的复杂性和缺乏进展而于 1969 年退出。鉴于 Mutics 项目不愉快的经历，一群贝尔实验室的研究人员——Ken Thompson、Dennis Ritchie、Doug Mcllroy 和 Joe Ossanna，从 1969 年开始在 DEC PDP-7 计算机上完全用机器语言编写了一个简单得多的操作系统。这个新系统中的很多思想，比如层次文件系统、作为用户级进程的 shell 概念，都是来自于 Multics，只不过在一个更小、更简单的程序包里实现。1970 年，Brian Kernighan 给新系统命名为 “Unix”，这也是一个双关语，暗指 “Multics” 的复杂性。1973 年用 C 重新编写其内核，1974 年，Unix 开始正式对外发布【93】。
>
> 贝尔实验室以慷慨的条件向学校提供源代码，所以 Unix 在大专院校里获得了很多支持并得以持续发展。最有影响的工作发生在 20 世纪 70 年代晚期到 80 年代早期，在美国加州大学伯克利分校，研究人员在一系列发布版本中增加了虚拟内存和 Internet 协议，称为 Unix 4.xBSD（Berkeley Software Distribution）。与此同时，贝尔实验室也在发布自己的版本，称为 System V Unix。其他厂商的版本，比如 Sun Microsystems 的 Solaris 系统，则是从这些原始的 BSD 和 System V 版本中衍生而来。
>
> 20 世纪 80 年代中期，Unix 厂商试图通过加入新的、往往不兼容的特性来使它们的程序与众不同，麻烦也就随之而来了。为了阻止这种趋势，IEEE（电气和电子工程师协会）开始努力标准化 Unix 的开发，后来由 Richard Stallman 命名为 “Posix”。结果就得到了一系列的标准，称作 Posix 标准。这套标准涵盖了很多方面，比如 Unix 系统调用的 C 语言接口、shell 程序和工具、线程及网络编程。最近，一个被称为“标准 Unix 规范”的独立标准化工作已经与 Posix 一起创建了统一的 Unix 系统标准。这些标准化工作的结果是 Unix 版本之间的差异已经基本消失。

#### 1.7.1 进程

像 hello 这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和 I/O 设备。处理器看上去就像在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。

**进程是操作系统对一个正在运行的程序的一种抽象**。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而**并发运行**，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的 CPU 个数的。传统系统在一个时刻只能执行一个程序，而先进的**多核**处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，**这是通过处理器在进程间切换来实现的**。操作系统实现这种交错执行的机制称为**上下文切换**。为了简化讨论，我们只考虑包含一个 CPU 的**单处理器系统**的情况。我们会在 1.9.2 节中讨论**多处理器系统**。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是**上下文**，包括许多信息，比如 PC 和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。图 1-12 展示了示例 hello 程序运行场景的基本理念。

示例场景中有两个并发的进程∶shell 进程和 hello 进程。最开始，只有 shell 进程在运行，即等待命令行上的输入。当我们让它运行 hello 程序时，shell 通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存 shell 进程的上下文，创建一个新的 hello 进程及其上下文，然后将控制权传给新的 hello 进程。hello 进程终止后，操作系统恢复 shell 进程的上下文，并将控制权传回给它，shell 进程会继续等待下一个命令行输入。

如图 1-12 所示，从一个进程到另一个进程的转换是由操作系统**内核**（kernel）管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的**系统调用**（system call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzietxOnE2XCBTZHJ7%2F-MHziqrI26zhGJA9_NLL%2F01-12%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.png?alt=media&token=5df4420b-e3c7-46ca-8192-ba207aa49f15)

图 1-12 进程的上下文切换

实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。我们将在第 8 章中揭示这项工作的原理，以及应用程序是如何创建和控制它们的进程的。

#### 1.7.2 线程

尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为**线程**的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法，我们将在 1.9.2 节中讨论这个问题。在第 12 章中，你将学习并发的基本概念，包括如何写线程化的程序。

#### 1.7.3 虚拟内存

**虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。**图 1-13 所示的是 Linux 进程的虚拟地址空间（其他 Unix 系统的设计也与此类似）。在 Linux 中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。请注意，图中的地址是从下往上增大的。

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzietxOnE2XCBTZHJ7%2F-MHzj3WC193cZbjm8s4A%2F01-13%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png?alt=media&token=e75f285a-1895-46f5-83fd-e8857326e5f9)

图 1-13 进程的虚拟地址空间

每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。在本书的后续章节你将学到更多有关这些区的知识，但是先简单了解每一个区是非常有益的。我们从最低的地址开始，逐步向上介绍。 

- **程序代码和数据。**对所有的进程来说，代码是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件 hello。在第 7 章我们研究链接和加载时，你会学习更多有关地址空间的内容。
- **堆。**代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 malloc 和 free 这样的 C 标准库函数时，*堆可以在运行时动态地扩展和收缩*。在第 9 章学习管理虚拟内存时，我们将更详细地研究堆。 
- **共享库。**大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。在第 7 章介绍动态链接时，将学习共享库是如何工作的。 
- **栈。**位于用户虚拟地址空间顶部的是**用户栈**，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。**特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩**。在第 3 章中将学习编译器是如何使用栈的。
- **内核虚拟内存。**地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。

虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。第 9 章将解释它如何工作，以及为什么对现代系统的运行如此重要。

#### 1.7.4 文件

**文件**就是**字节序列**，仅此而已。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。**系统中的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的**。

文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的 I/O 设备。例如，处理磁盘文件内容的应用程序员可以非常幸福，因为他们无须了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。你将在第 10 章中学习 Unix I/O。 

> **旁注 - Linux项目**
>
> 1991年8月，芬兰研究生 Linus Torvalds 谨慎地发布了一个新的类 Unix 的操作系统内核，内容如下。
>
> > 来自∶ torvalds@klaava.Helsinki.FI（Linus Benedict Torvalds）
> >
> > 新闻组∶comp.os.minix
> >
> > 主题∶在 minix中你最想看到什么？
> >
> > 摘要∶关于我的新操作系统的小调查
> >
> > 时间∶1991 年 8 月 25 日 20:57:08 GMT 
> >
> > 每个使用 minix 的朋友，你们好。
> >
> > 我正在做一个（免费的）用在 386（486）AT 上的操作系统（只是业余爱好，它不会像 GNU 那样庞大和专业）。这个想法自 4 月份就开始酝酿，现在快要完成了。我希望得到各位对 minix 的任何反馈意见，因为我的操作系统在某些方面与它相类似（其中包括相同的文件系统的物理设计（因为某些实际的原 因））。
> >
> > 我现在已经移植了 bash（1.08）和 gc（1.40），并且看上去能运行。这意味着我需要几个月的时间来让它变得更实用一些，并且，我想要知道大多数人想要什么特性。欢迎任何建议，但是我无法保证我能实现它们。:-)
> >
> > **Linus (torvalds@kruna.helsinki.fi)** 
>
> 就像 Torvalds 所说的，他创建 Linux 的起点是 Minix，由 Andrew S. Tanenbaum 出于教育目的开发的一个操作系统【113】。 接下来，如他们所说，这就成了历史。Linux 逐渐发展成为一个技术和文化现象。通过和 GNU 项目的力量结合，Linux 项目发展成了一个完整的、符合 Posix 标准的 Unix 操作系统的版本，包括内核和所有支撑的基础设施。从手持设备到大型计算机，Linux 在范围如此广泛的计算机上得到了应用。IBM 的一个工作组甚至把 Linux 移植到了一块腕表中！

### **1.8 系统之间利用网络通信**

系统漫游至此，我们一直是把系统视为一个孤立的硬件和软件的集合体。实际上，现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个 I/O 设备，如图 1-14 所示。**当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。**

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzkHZkDb2pAz2UFj6L%2F-MHzkTNuWPTixbySY2Yc%2F01-14%20%E7%BD%91%E7%BB%9C%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8DIO%E8%AE%BE%E5%A4%87.png?alt=media&token=d06f41b1-bb97-42e1-ad6d-35f30948cbc7)

图 1-14 网络也是一种 I/O 设备

随着 Internet 这样的全球网络的出现，从一台主机复制信息到另外一台主机已经成为计算机系统最重要的用途之一。比如，像电子邮件、即时通信、万维网、FTP 和 telnet 这样的应用都是基于网络复制信息的功能。 回到 hello 示例，我们可以使用熟悉的 telnet 应用在一个远程主机上运行 hello 程序。假设用本地主机上的 telnet 客户端连接远程主机上的 telnet 服务器。在我们登录到远程主机并运行 shell 后，远端的 shell 就在等待接收输入命令。此后在远端运行 hello 程序包括如图 1-15  所示的五个基本步骤。

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzkHZkDb2pAz2UFj6L%2F-MHzkrKbCqYNGK5oVdPg%2F01-15%20%E5%88%A9%E7%94%A8telnet%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E8%BF%9C%E7%A8%8B%E8%BF%90%E8%A1%8Chello.png?alt=media&token=686ab00c-5876-4a23-bb52-6760cdc22591)

图 1-15 利用 telnet 通过网络远程运行 hello

当我们在 telnet 客户端键入 “hello” 字符串并敲下回车键后，客户端软件就会将这个字符串发送到 telnet 的服务器。telnet 服务器从网络上接收到这个字符串后，会把它传递给远端 shell 程序。接下来，远端 shell 运行 hello 程序，并将输出行返回给 telnet 服务器。最后，telnet 服务器通过网络把输出串转发给 telnet 客户端，客户端就将输出串输出到我们的本地终端上。 这种客户端和服务器之间交互的类型在所有的网络应用中是非常典型的。在第 11 章中，你将学会如何构造网络应用程序，并利用这些知识创建一个简单的 Web 服务器。

### **1.9 重要主题**

系统不仅仅只是硬件。系统是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。

#### 1.9.1 Amdahl 定律

Gene Amdahl，计算领域的早期先锋之一，**对提升系统某一部分性能所带来的效果做出了简单却有见地的观察**。这个观察被称为 **Amdahl 定律**（Amdahl's law，阿姆达尔定律）。该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。若系统执行某应用程序需要时间为$T_{old}$假设系统某部分所需执行时间与该时间的比例为$\alpha$，而该部分性能提升比例为$k$ 。即该部分初始所需时间为$aT_{old}$，现在所需时间为$aT_{old}/k$。因此，总的执行时间应为

$T_{new} = (1-\alpha)T_{old}+(\alpha T_{old})/k=T_{old}[(1-\alpha)+\alpha/k]$

由此，可以计算加速比$S=T_{old}/T_{new}$ 为

$S=\frac{1}{(1-\alpha)+\alpha/k} \tag{1.1}$

举个例子，考虑这样一种情况，系统的某个部分初始耗时比例为 60%（α =0.6），其加速比例因子为 3（k=3）。则我们可以获得的加速比为 1/[0.4+0.6/3]=1.67 倍。虽然我们对系统的一个主要部分做出了重大改进，但是获得的系统加速比却明显小于这部分的加速比。这就是 Amdahl 定律的主要观点——要想显著加速整个系统，必须提升全系统中相当大的部分的速度。

> **旁注 - 表示相对性能**
>
> 性能提升最好的表示方法就是用比例的形式 $T_{old}/T_{new}$，其中，$T_{old}$为原始系统所需时间， $T_{new}$为修改后的系统所需时间。如果有所改进，则比值应大于 1。我们用后缀 “×” 来表示比例，因此，“2.2×” 读作 “2.2 倍”。
>
> 表示相对变化更传统的方法是用百分比，这种方法适用于变化小的情况，但其定义是模糊的。应该等于 $100 \cdot (T_{old}-T_{new})/T_{new}$ ，还是 $100 \cdot (T_{old}-T_{new})/T_{old}$，还是其他的值？此外，它对较大的变化也没有太大意义。与简单地说性能提升 2.2× 相比，“性能提升了 120%” 更难理解。 

**练习题1.1**

假设你是个卡车司机，要将土豆从爱达荷州的 Boise 运送到明尼苏达州的 Minneapolis，全程 2500 公里。在限速范围内，你估计平均速度为 100 公里/小时，整个行程需要 25 个小时。

A. 你听到新闻说蒙大拿州刚刚取消了限速，这使得行程中有 1500 公里卡车的速度可以为 150 公里/小时。那么这对整个行程的加速比是多少？

B. 你可以在 www.fasttrucks.com 网站上为自已的卡车买个新的涡轮增压器。网站现货供应各种型号，不过速度越快，价格越高。如果想要让整个行程的加速比为 1.67×，那么你必须以多快的速度通过蒙大拿州？

> 答案：
>
> 该问题说明 Amdahl 定律不仅仅适用于计算机系统。
>
> A. 根据公式 1.1，有 α=0.6，k=1.5。更直接地说，在蒙大拿行驶的 1500 公里需要10个小时，而其他行程也需要 10 个小时。则加速比为 25/(10＋10)=1.25×。
>
> B. 根据公式 1.1，有 α=0.6，要求 S=1.67，则可算出 k。更直接地说，要使行程加速度达到 1.67×，我们必须把全程时间减少到 15 个小时。蒙大拿以外仍要求为 10 小时，因此，通过蒙大拿的时间就为 5 个小时。这就要求行驶速度为 300 公里/小时，对卡车来说这个速度太快了！

**练习题 1.2**

公司的市场部向你的客户承诺，下一个版本的软件性能将改进 2×。这项任务被分配给你。你已经确认只有 80% 的系统能够被改进，那么，这部分需要被改进多少（即 k 取何值）才能达到整体性能目标？ 

> 答案
>
> 理解 Amdahl 定律最好的方法就是解决一些实例。本题要求你从特殊的角度来看公式 1.1。
>
> 本题是公式的简单应用。已知 S=2，α=0.8，则计算 k：
>
> $2=\frac{1}{(1-0.8)+0.8/k}\\$
>
> $0.4+1.6/k=1.0$
>
> $k=2.67$

Amdahl 定律一个有趣的特殊情况是考虑 k 趋向于 ∞ 时的效果。这就意味着，我们可以取系统的某一部分将其加速到一个点，在这个点上，这部分花费的时间可以忽略不计。于是我们得到

$S_{\infty}=\frac{1}{(1-\alpha)} \tag{1.2}$

举个例子，如果 60% 的系统能够加速到不花时间的程度，我们获得的净加速比将仍只有 1/0.4=2.5×。

Amdahl 定律描述了改善任何过程的一般原则。除了可以用在加速计算机系统方面之外，它还可以用在公司试图降低刀片制造成本，或学生想要提高自己的绩点平均值等方面。也许它在计算机世界里是最有意义的，在这里我们常常把性能提升 2 倍或更高的比例因子。这么高的比例因子只有通过优化系统的大部分组件才能获得。

#### 1.9.2 并发和并行

数字计算机的整个历史中，有两个需求是驱动进步的持续动力：一个是我们想要计算机做得更多，另一个是我们想要计算机运行得更快。当处理器能够同时做更多的事情时，这两个因素都会改进。我们用的术语**并发**（concurrency）*是一个通用的概念，指一个同时具有多个活动的系统*；而术语**并行**（parallelism）指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。在此，我们按照系统层次结构中由高到低的顺序重点强调三个层次。

##### 1. 线程级并发

构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了**并发**。**使用线程，我们甚至能够在一个进程中执行多个控制流**。自 20 世纪 60 年代初期出现时间共享以来，计算机系统中就开始有了对并发执行的支持。传统意义上，这种并发执行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的，就好像一个杂耍艺人保持多个球在空中飞舞一样。这种并发形式允许多个用户同时与系统交互，例如，当许多人想要从一个 Web 服务器获取页面时。它还允许一个用户同时从事多个任务，例如，在一个窗口中开启 Web 浏览器，在另一窗口中运行字处理器，同时又播放音乐。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为**单处理器系统**。

当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个**多处理器系统**。其实从 20 世纪 80 年代开始，在大规模的计算中就有了这种系统，但是直到最近，随着多核处理器和**超线程**（hyperthreading）的出现，这种系统才变得常见。图 1-16 给出了这些不同处理器类型的分类。

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzl0fd6lZg8Hh-AE9H%2F-MI-0nKsOs98vF3fwNsm%2F01-16%20%E4%B8%8D%E5%90%8C%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8%E9%85%8D%E7%BD%AE%E5%88%86%E7%B1%BB.png?alt=media&token=1997d8e6-5082-445a-8a28-33113a277bb8)

图 1-16 不同的处理器配置分类。随着多核处理器和超线程的出现，多处理器变得普遍了

多核处理器是将多个 CPU（称为“核”）集成到一个集成电路芯片上。图 1-17 描述的是一个典型多核处理器的组织结构，其中微处理器芯片有 4 个 CPU 核，每个核都有自己的 L1 和 L2 高速缓存，其中的 L1 高速缓存分为两个部分——一个保存最近取到的指令，另一个存放数据。这些核共享更高层次的高速缓存，以及到主存的接口。工业界的专家预言他们能够将几十个、最终会是上百个核做到一个芯片上。

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzl0fd6lZg8Hh-AE9H%2F-MI-7jCviAytfKKxpbQG%2F01-17%20%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png?alt=media&token=268e2b0a-03ce-4e72-92ac-b209f776effe)

图 1-17 多核处理器的组织结构。4 个处理器核集成在一个芯片上

超线程，有时称为**同时多线程**（simultaneous multi-threading），是一项允许一个 CPU 执行多个控制流的技术。它涉及 CPU 某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。常规的处理器需要大约 20000 个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得 CPU 能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那 CPU 就可以继续去执行另一个线程。举例来说，Intel Core i7 处理器可以让每个核执行两个线程，所以一个 4 核的系统实际上可以并行地执行 8 个线程。

多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。正如前面提到的，即使是只有一个用户使用的个人计算机也需要并发地执行多个活动。其次，它可以使应用程序运行得更快，当然，这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。因此，虽然并发原理的形成和研究已经超过 50 年的时间了，但是多核和超线程系统的出现才极大地激发了一种愿望，即找到书写应用程序的方法利用硬件开发线程级并行性。第 12 章会更深入地探讨并发，以及使用并发来提供处理器资源的共享，使程序的执行允许有更多的并行。

##### 2. 指令级并行

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。早期的微处理器，如 1978 年的 Intel 8086，需要多个（通常是 3～10 个）时钟周期来执行一条指令。最近的处理器可以保持每个时钟周期 2～4 条指令的执行速率。其实每条指令从开始到结束需要长得多的时间，大约 20 个或者更多周期，但是处理器使用了非常多的聪明技巧来同时处理多达 100 条指令。在第 4 章中，我们会研究**流水线**（pipelining）的使用。在流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。我们会看到一个相当简单的硬件设计，它能够达到接近于一个时钟周期一条指令的执行速率。

如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为**超标量**（super-scalar）处理器。大多数现代处理器都支持超标量操作。第 5 章中，我们将描述超标量处理器的高级模型。应用程序员可以用这个模型来理解程序的性能。然后，他们就能写出拥有更高程度的指令级并行性的程序代码，因而也运行得更快。

##### 3. 单指令、多数据并行

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。例如，较新几代的 Intel 和 AMD 处理器都具有并行地对 8 对单精度浮点数（C 数据类型 float）做加法的指令。

提供这些 SIMD 指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从 C 程序中自动抽取 SIMD 并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如 GCC 就支持向量数据类型。作为对第 5 章中比较通用的程序优化描述的补充，我们在网络旁注 OPT：SIMD 中描述了这种编程方式。

#### 1.9.3 计算机系统中抽象的重要性

抽象的使用是计算机科学中最为重要的概念之一。例如，为一组函数规定一个简单的应用程序接口（API）就是一个很好的编程习惯，程序员无须了解它内部的工作便可以使用这些代码。不同的编程语言提供不同形式和等级的抽象支持，例如 Java 类的声明和C语言的函数原型。

我们已经介绍了计算机系统中使用的几个抽象，如图 1-18 所示。在处理器里，指令集架构提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上。底层的硬件远比抽象描述的要复杂精细，它并行地执行多条指令，但又总是与那个简单有序的模型保持一致。只要执行模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzl0fd6lZg8Hh-AE9H%2F-MI-82VB6DVGoG3z1MF_%2F01-18%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%BD%E8%B1%A1.png?alt=media&token=7d4d9259-9b84-46f9-a5a2-8f6ff9f0bd68)

> 图 1-18 计算机系统提供的一些抽象。计算机系统中的一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性

在学习操作系统时，我们介绍了三个抽象：文件是对 I/O 设备的抽象，虚拟内存是对程序存储器的抽象，而进程是对一个正在运行的程序的抽象。我们再增加一个新的抽象∶ **虚拟机**，它提供对整个计算机的抽象，包括操作系统、处理器和程序。虚拟机的思想是 IBM 在 20 世纪 60 年代提出来的，但是最近才显示出其管理计算机方式上的优势，因为一些计算机必须能够运行为不同的操作系统（例如，Microsoft Windows、MacOS 和 Linux）或同一操作系统的不同版本设计的程序。

在本书后续的章节中，我们会具体介绍这些抽象。

### **1.10 小结**

计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是 ASCII 文本，然后被编译器和链接器翻译成二进制可执行文件。

处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O 设备和 CPU 寄存器之间复制数据，所以将系统中的存储设备划分成层次结构——CPU 寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化C程序的性能。

操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象∶1）文件是对 I/O 设备的抽象；2）虚拟内存是对主存和磁盘的抽象；3）进程是处理器、主存和 I/O 设备的抽象。

最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种 I/O 设备。

#### 参考文献说明

Ritchie写了关于早期 C 和 Unix 的有趣的第一手资料【91，92】。Ritchie 和 Thompson 提供了最早出版的 Unix 资料【93】，Silberschatz、Galvin 和 Gagne【102】提供了关于 Unix 不同版本的详尽历史。GNU（www.gnu.org）和 Linux（www.linux.org）的网站上有大量的当前信息和历史资料。Posix 标准可以在线获得（www.unix.org）。

## 第 2 章：信息的表示和处理

**位**（bit）：现代计算机存储和处理的信息以二值信号表示。

三种最重要的数字表示：

+ **无符号**（unsigned）编码基于传统的二进制表示法，表示大于或者等于零的数字。
+ **补码** （two's-complement）编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。
+ **浮点数**（floating-point）编码是表示实数的科学记数法的以 2 为基数的版本。计算机用这些不同的表示方法实现算术运算，例如加法和乘法，类似于对应的整数和实数运算。

+ **溢出** （overflow）：计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会溢出。

  溢出会导致某些令人吃惊的后果。例如，在今天的大多数计算机上（使用 32 位来表示数据类型 int），计算表达式 200∗300∗400∗500\small 200*300*400*500200∗300∗400∗500  会得出结果 -884901888。这违背了整数运算的特性，计算一组正数的乘积不应产生一个负的结果。

  另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。例如，利用乘法的结合律和交换律，计算下面任何一个 C 表达式，都会得出结果 -884901888。

> C语言的演变：
>
> 最早开发：贝尔实验室Dennis Ritchie开发，目的是和Unix一起使用。
>
> 缺点：要使用汇编代码。
>
> 演变：1989年，美国国家国家标准学会推出ANSI C标准；90年，国际标准化组织推出"ISO C90"；99年，推出”C99“；2011年，推出”C11“。
>
> CNU编译器套装(GNU Compiler Collection, GCC)可以基于不同命令行选项的不同版本编译C语言。
>
> 根据ISO C11，我们可以用
>
> ```shell
> linux> gcc -std=c11 prog.c
> ```

### 2.1 信息存储

**字节(byte)**：8位的块，作为最小的可寻址内存单位。

**虚拟内存(virtual memory)**：机器级程序将内存视为一个非常大的字节数组。

**地址(address)**：内存每个字节都由一个唯一的数字标识。

**虚拟地址空间(virtual address space)**：所有可能地址的集合。

程序对象（program object）：即程序数据、指令和控制信息。可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。

例如，C 语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象）都是某个存储块的第一个字节的虚拟地址。

C编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管C编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。

#### 2.1.1 十六进制表示法

以16为基数，叫十六进制数(hexadecimal)，来表示位模式。

十六进制(hex)，使用数字0-9以及A-F来表示16个可能的值。一个字节的值域为$00_{16}$~$FF_{16}$。

![image-20220706155852712](深入理解计算机系统.assets/image-20220706155852712.png)

表示：`0x`或者`0X`；数字的末尾$_{16}$。

#### 2.1.2 字数据大小

**字长**：指明指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。对于一个字长我$w$位的机器而言，虚拟地址的范围是$0$~$2^w-1$，程序最多访问$2^w$个字节。

出现了大规模的从 32 位字长机器到 64 位字长机器的迁移。这种情况首先出现在为大型科学和数据库应用设计的高端机器上，之后是台式机和笔记本电脑，最近则出现在智能手机的处理器上。 32 位字长限制虚拟地址空间为4千兆字节（写作 4GB), 也就是说，刚刚 超过$4*10^9$字节。扩展到 64 位字长使得虚拟地址空间为 16EB, 大约是 $4*10^{19}$字节。

>  注：$1KB=1024B=2^{10}B$

大多数 64 位机器也可以运行为 32 位机器编译的程序，这是一种向后兼容。

多数64位机器可以向后兼容32位机器编译的程序。

<img src="深入理解计算机系统.assets/image-20220708172258101.png" alt="image-20220708172258101" style="zoom: 80%;" />

`int32_t`：4个字节

`int64_t`：8个字节

**如何声明指针？**

对于任何数据类型T，声明 T *p;

表明p是一个指针变量，指向一个类型为T的对象。例如，就将一个指针声明为指向一个char类型的对象。

还要注意可移植性。

#### 2.1.3 寻址和字节顺序

**小端法：最低有效字节在最前面的方式**

**大端法：最高有效字节在最前面的方式**

例：

假设变量x的类型为int，位于地址0x100处，它的十六进制值为0x01234567。地址范围0x100~0x103的字节顺序依赖于机器的类型：

![image-20220708182642636](深入理解计算机系统.assets/image-20220708182642636.png)

注意，在字0x01234567中，高位字节的十六进制值为0x01，而低位字节值为0x67。

大多数Intel兼容机都采用小端模式。许多比较新的微处理器是双端法。安卓和IOS都是小端模式。

要注意字节顺序规则转换。

反汇编器生成：4004d3:01 05 43 0b 20 00 add %eax,0x200b43(%rip)

反汇编器：一种确定可执行程序文件所表示的指令序列工具。十六进制字节串 01 05 43 0b 20 00 一条指令的字节级表示，这条指令是把一个字长的数据加到一个值上，该值的存储地址由 0x200b43 加上当前程序计数器的值得到，当前程序计数器的值即为下一条将要执行指令的地址。如果取出这个序列的最后4个字节：43 0b 20 00，并且按照相反的顺序写出，我们得到00 20 0b 43。去掉开头的0，得到值0x200b43，这就是右边的数值。

字节顺序变得重要的第三种情况是当编写规避正常的类型系统的程序时。C语言中，可以通过使用强制类型转换或联合来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。



> typedef的数据类型



>  练习题1：思考下面对show_bytes的三次调用:

```c
int val=0x87654321;
byte_pointer valp=(byte_pointer)&val;
show_bytes(valp,1);
show_bytes(valp,2);
show_bytes(valp,3);
```

结果：

A. 小端法：21        大端法：87

B. 小端法：21 43      大端法：87 65

C. 小端法：21 43 65   大端法：87 65 43

这是基于qemu模拟器的实现

![img](https://img-blog.csdnimg.cn/20190402174023800.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rhbmd1YW5odWFE,size_16,color_FFFFFF,t_70)



> 练习题2.6 使用show_int和show_float，我们确定整数3510593的十六进制表示为0x00359141，而浮点数3510593.0的十六进制表示为0x4A564504。

A. 写出这两个十六进制值的二进制表示。

B. 移动这两个二进制串的相对位置，使得它们匹配的位数最多。有多少位相匹配呢？

C. 串中的什么部分不相匹配？

解：

A.   0x00359141       0000 0000 0011 0101 1001 0001 0100 0001

       0x4A56504        0100 1010 0101 0110 0100 0101 0000 0100

B.  0000 0000 0011 0101 1001 0001 0100 0001

        0100 1010 0  1 0101 1001 0001 0100 0001  00

共有21位相匹配

C.  我们发现除了最高有效位1，整数的所有位都嵌在浮点数中。这正好也是书中示例的情况。另外，浮点数有一些非零的高位不与整数中的高位相匹配

#### 2.1.4 表示字符串

C语言中字符串被编码为一个以null字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符码。因此，如果我们以参数“12345”和6来运行例程show_bytes，我们得到结果31 32 33 34 35 00。

> 练习题2.7 下面对show_bytes的调用将输出什么结果？
>
> ```C++
> const char *s = "abcdef";
> show_bytes((byte_pointer) s, strlens(s));
> 
> >>>
> 注意字母 ‘a' ~ 'z' 的ASCII码为0x61~0x7A
> 
> 解：输出 61 62 63 64 65 66（库函数strlen不计算终止的空白符，所以show_bytes只打印到字符 ’f' ）

#### 2.1.5 表示代码

```c
int sum(int x, int y){
    return x+y;
}
```

![image-20220708195915068](深入理解计算机系统.assets/image-20220708195915068.png)

指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容。二进制代码很少能在不同机器和操作系统组合之间移植。

计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。

#### 2.1.6 布尔代数简介

二进制值是计算机编码、存储和操作信息的核心。

布尔注意到通过将逻辑值TRUE和FALSE编码为二进制值1和0，能够设计出一种代数，以研究逻辑推理的基本原则。

最简单的布尔代数是在二元集合{0,1}基础上的定义。

<img src="深入理解计算机系统.assets/image-20220708201105671.png" alt="image-20220708201105671" style="zoom: 67%;" />

#### 2.1.7 C语言中的位级运算

几种位级运算：OR 或 |；AND 与 &；NOT ~ 取反；EXCLUSIVE-OR 异或

![image-20220710105650489](深入理解计算机系统.assets/image-20220710105650489.png)

异或：其运算法则为：a⊕b = (¬a ∧ b) ∨ (a ∧¬b)如果a、b两个值不相同，则*异或*结果为1。如果a、b两个值相同，*异或*结果为0

**练习题2.10**

假设x和y指向的位置分别是a和b。完成下表：

| 步骤   | *x      | *y            |
| ------ | ------- | ------------- |
| 初始   | a       | b             |
| 第一步 | a       | a^b           |
| 第二步 | a^(a^b) | a^b           |
| 第三步 | a^(a^b) | a^(a^b)^(a^b) |

 由于异或运算满足交换率和结合率，且a ^ 0 = 0， a ^  = ~a。所以有 

| 步骤   | *x   | *y   |
| ------ | ---- | ---- |
| 初始   | a    | b    |
| 第一步 | a    | a^b  |
| 第二步 | b    | a^b  |
| 第三步 | b    | a    |



**练习题2.11**

A：最后一次循环时，两个变量值相同。奇数数组长度为2k+1，则变量值为中间的元素值array[k]。

B：当调用inplace_swap函数时，实际上两个参数指向同一个位置。*x=*y。由于a^a=0，第一步运算后，*y=0=*x。后两步再运算，值全是0。最终array[k]=0。

C：将for循环中的条件first <= last，改为first < last 即可。不让两个相同元素交换，即可保证代码逻辑正确。

位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。

例子：掩码 0xFF( 最低的 位为 1) 表示一个字的低位字节。位级运算 x&0xFF 生成一个由的最低有效字节组成的值，而其他的字节就被置为0。比如，对于 x= 0x89ABCDEF, 其表达式将得到0x000000EF。

**练习题2.12**

由于已经给出限定条件字长w>=8，所以基本的最低有效字节最小应该为0xFF。
1）任何位与(&)1都会得到它本身，任何位与(&)0都会得到0。所以得到 x & 0xFF。
2）任何位异或(^)0都会得到它本身，而异或(^)1则会得到它的非(~)，即它的补。需要取取补的位对应就全置为1，
需要不变的位对应就全置为0，然后在与之异或。所以得到 x ^ ~0xFF。
3）任何位或(|)1都会得到1，或(|)0都会得到它本身。所以得到 x | 0xFF 。

**练习题2.13**

```c++
int bis(int x, int m);
int bic(int x, int m);

int bool_or(int x, int y)
{
    int result = bis(x, y);
    return result;
}

int bool_xor(int x, int y)
{
    int result = bis(bic(x, y), bic(y, x));
    return result;
}
```

#### 2.1.8 C语言中的逻辑运算

C语言中有||、&&、！等逻辑运算符。

![image-20220715135803489](深入理解计算机系统.assets/image-20220715135803489.png)

逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE。它们返回1或者0。可以观察到，按位运算只有在特殊情况下，也就是参数被限制为0或者1时，才和与其对应的逻辑运算有相同的行为。

逻辑运算符&&和||与它们对应的位级运算&和|之间第二个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。因此，例如，表达式a&&5/a将不会造成被零除，而表达式p&&*p++t也不会导致间接引用空指针。

**练习题2.14**

假设x和y的字节值分别为0x66和0x39。填写下表，指明各个C表达式的字节值。

0x66 = 0110 0110(B)

0x39 = 0011 1001(B)

| 表达式     | 值   |
| ---------- | ---- |
| x & y      | 0x20 |
| x \| y     | 0x7F |
| ~x \| ~y   | 0xDF |
| x & !y     | 0x00 |
| x && y     | 0x01 |
| x \|\| y   | 0x01 |
| !x \|\| !y | 0x00 |
| x && ~y    | 0x01 |

**练习题2.15**

只使用位级运算和逻辑运算，编写一个C表达式，它等价于x==y。换句话说，当x和y相等时它将返回1，否则就返回0。

```
 !(x^y)
 当且仅当x的每一位和y相应的每一位匹配时, x ^ y 等于0,然后利用!来判定一个字是否包含任何非零位.
```

#### 2.1.9 C语言中的移位运算

移位运算：向左或向右移动位模式。

对于一个位表示为$[x_{w-1},x_{w-2},...,x_{0}]$的操作数$x$。

左移：$x<<k$，$[x_{w-k-1},x_{w-k-2},...,x_{0},0,...,0]$，向左移动k位，丢弃最高的k位，并在右端补$k$个0。移位量应该是一个$0$~$w-1$之间的值。移位运算是从左至右可结合的，所以$x<<j<<k$等价于$(x<<j)<<k$。

右移：$x>>k$。右移分为逻辑右移和算术右移。

+ 逻辑右移，左端补$k$个0，得到的结果是$[0,...,0,x_{w-1},x_{w-2},...,x_{k}]$；
+ 算术右移是左端补$k$个最高有效位的值$[x_{w-1},...,x_{w-1},x_{w-1},x_{w-2},...,x_{k}]$。

例：

|       操作       |          值           |
| :--------------: | :-------------------: |
|     参数$x$      | [01100011] [10010101] |
|      $x<<4$      | [00110000] [01010000] |
| $x>>4(逻辑右移)$ | [00000110] [00001001] |
| $x>>4(算术右移)$ | [00000110] [11111001] |

无符号数，必须是逻辑右移；几乎所有的编译器/及其组合都对有符号数使用算术右移。

Java会有明确定义。$x>>k$是算术右移，$x>>>k$会对$x$做逻辑右移。

> 旁注1：移动$k$位，这里$k$很大
> 

旁注2：



**练习题2.16**

填写下表，说明不同移位运算对单字节数的影响。

| x        |           | x<<3      |          | x>>2(逻辑) |          | x>>2(算术) |          |
| -------- | --------- | --------- | -------- | ---------- | -------- | ---------- | -------- |
| 十六进制 | 二进制    | 二进制    | 十六进制 | 二进制     | 十六进制 | 二进制     | 十六进制 |
| 0xC3     | 1100 0011 | 0001 1000 | 0x18     | 0011 0000  | 0x30     | 1111 0000  | 0xF0     |
| 0x75     | 0111 0101 | 1010 1000 | 0xA8     | 0001 1101  | 0x1D     | 0001 1101  | 0x1D     |
| 0x87     | 1000 0111 | 0011 1000 | 0x38     | 0010 0001  | 0x21     | 1110 0001  | 0xE1     |
| 0x66     | 0110 0110 | 0011 0000 | 0x30     | 0001 1001  | 0x19     | 0001 1001  | 0x19     |

### 2.2 整数表示

引入数学术语，用于精确定义和描述计算机如何编码和操作整数。

+ 非负数
+ 负数、零和整数



**复习：原码、反码、补码**

原码 ：最高位是符号位，0代表正数，1代表负数，非符号位为该数字绝对值的二进制。

反码：正数的反码与原码一致，负数的反码是对原码按位取反，只是最高位（符号位）不变。 

补码：正数的补码与原码一致，负数的补码是对原码按位取反加1，符号位不变。

例如十进制数字：5

> $5=2^2+2^0$  
>
> 5的二进制表示是101。  
>
> 至少要三位数字，如果加上符号位，就是4位数字。
>
> 原码：0101       
>
> 反码：0101
>
> 补码：0101

例如十进制数字：-5

> $5=2^2 + 2^0$     
>
> 5的二进制表示是101。
>
> 至少要三位数字，加上符号位，就是4位数字。
>
> 原码：**1**101
>
> 反码：1010
>
> 补码：1011
>

例如 将补码1011  转换为原码

> 补码：1011
>
> 符号位不变，数值位取反：1100
>
> 加1后得到原码：1101
>
> 补码变成原码的方式是：正数的补码与原码一致，负数的补码按位取反加1，符号位不变
>
> 反码变成原码的方式是：正数的反码与原码一致，负数的补码转换为源码后位取反，符号位不变

**用4位二进制原码表示0：-0=1000  +0=0000** 

**用4位二进制反码表示0：-0=1111  +0=0000** 

**用4位二进制补码表示0：-0=0000  +0=0000** 

**n+1位数字，绝对值最大的原码是  -(2^n - 1)和 2^n - 1**

**n+1位数字，绝对值最大的反码是  -(2^n - 1) 和 2^n - 1**

**n+1位数字，绝对值最大的补码是 −2^n ≤x ≤2^n−1**



```
1、正数的反码和补码都与原码相同。 
2、而负数的反码为对该数的原码除符号位外各位取反。 
3、负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1

1、原码表示法规定：用符号位和数值表示带符号数，正数的符号位用“0”表示，负数的符号位用“1”表示，数值部分用  二进制形式表示。 
2、反码表示法规定：正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反。 
3、补码表示法规定：正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1. 
4、正零和负零的补码相同，[+0]补=[-0]补=0000 0000B。

计算机中数值都是以补码的形式存储
======================================================================================
    真值             原码       ||       反码               补码              表示的数值
======================================================================================
    0             0000_0000   |                       0000_0000                  0
    1             0000_0001   |                       0000_0001                  1
   ...               ....     |                         ....
   ...               ....     |                         ....
   ...               ....     |                         ....
   ...               ....     |                         ....
   ...               ....     |                         ....
   127            0111_1111   |                       0111_1111                 127
=====================================================================================
   -0             1000_0000   |    1111_1111          1_0000_0000              -128  
   -1             1000_0001   |    1111_1110           1111_1111               -127
   -2             1000_0010   |    1111_1101           1111_1110               -126
  ...                ....     |
  ...                ....     |
  ...                ....     |
  -127            1111_1111   |    1000_0000           1000_0001                 -1
===================================================================================== 
  
=====================================================================================
    符号位         数值位
   1(负数)           7位 
   0(正数)           7位

   特殊：10000000  ：-0表示-128
   上述的-0位特殊情况，规定它在计算机中的表示的数为-128；
   -0:10000000按位取反再加1后为1_0000_0000超出了8位，把这个值规定为8位表示的-128；
   因此8位二进制数可表示的有符号数为0-255；可表示的无符号数为-128-0-127
=====================================================================================
在这里要说到一个概念 模，“模”是指一个计量系统的计数范围。如时钟等。 

时钟的计量范围是0～11，模=12。表示n位的二进制数计量范围是0～2(n)-1，模=2(n)，八位二进制数的模为2^8 。

任何有模的计量器，均可化减法为加法运算（这就是计算机二进制运算的原理）。假设当前时针指向10点，而准确时间是6点，调整时间可有以下两种拨法：一种是倒拨4小时，即：10-4=6；另一种是顺拨8小时：10+8=12+6=6 。在以12模的系统中，加8和减4效果是一样的，因此凡是减4运算，都可以用加8来代替。对“模”而言，8和4互为补数。实际上以12模的系统中，11和1，10和2，9和3，7和5，6和6都有这个特性。共同的特点是两者相加等于模。对于计算机，其概念和方法完全一样。n位计算机，设n=8， 所能表示的最大数是11111111，若再加1成为100000000(9位），但因只有8位，最高位1自然丢失。又回了00000000，所以8位二进制系统的模为2^8。在这样的系统中减法问题也可以化成加法问题，只需把减数用相应的补数表示就可以了，把补数用到计算机对数的处理上，就是补码。对一个正数的原码取反加一，得到这个正数对应负数的补码。例如~6=-7，而且加一之后会多出一个八进制补码1000 0000，而这个补码就对应着原码1000 0000，数字位同时当做符号位即-128 。所以根据以上我们可以理解为什么八位二进制数表示范围为-128~+127。八位二进制正数的补码范围是0000 0000 ~ 0111 1111 即0 ~ 127,负数的补码范围是正数的原码0000 0000 ~ 0111 1111 取反加一（也可以理解为负数1000 0000 ~ 1111 1111化为反码末尾再加一）。  所以得到 1 0000 0000 ~ 1000 0001,1000 0001作为补码，其原码是1111 1111（-127），依次往前推，可得到-1的补码为1111 1111，那么补码0000 0000的原码是1000 0000符号位同时也可以看做数字位即表示-128，这也解释了为什么127（0111 1111）+1（0000 0001）=-128（1000 0000）。
```



#### 2.2.1 整型数据类型

C语言支持多种整型数据类型——表示有限范围的整数。其中还给出了”典型”32 位和 64 位机器的取值范围。每种类型都能用关键字来指定大小，这些关键字包括char、short、long, 同时还可以指示被表示的数字是非负数 （声明为unsigned), 或者可能是负数（默认）。如图 2-3 所示，为这些不同的大小分配的字节数根据程序编译为32位还是64位而有所不同。根据字节分配，不同的大小所能表示 的值的范围是不同的 这里给出来的唯一一个与机器相关的取值范围是大小指示符 long 的。大多数 64 位机器使用8个字节的表示，比 32 位机器上使用的4个字节的表示的取值范围大很多。

char是1个字节，short是2个字节，int是4个字节，long在32位是4个字节，64位是8个字节。

> 在编程语言中，常见的数据类型包括原始类型（如：[整数](https://zh.wikipedia.org/wiki/整數)、[浮点数](https://zh.wikipedia.org/wiki/浮點數)或[字符](https://zh.wikipedia.org/wiki/字元)）、[多元组](https://zh.wikipedia.org/wiki/多元组)、记录单元、[代数数据类型](https://zh.wikipedia.org/w/index.php?title=代數資料類型&action=edit&redlink=1)、[抽象数据类型](https://zh.wikipedia.org/wiki/抽象資料類型)、[参考类型](https://zh.wikipedia.org/w/index.php?title=參考_(電腦科學)&action=edit&redlink=1)、[类](https://zh.wikipedia.org/wiki/类_(计算机科学))以及[函数类型](https://zh.wikipedia.org/w/index.php?title=函式物件&action=edit&redlink=1)。数据类型描述了[数值](https://zh.wikipedia.org/wiki/数值)的表示法、解释和结构，并以[算法](https://zh.wikipedia.org/wiki/演算法)操作，或是[对象](https://zh.wikipedia.org/wiki/物件_(電腦科學))在存储器中的存储区，或者其它存储设备。

![img](https://img-blog.csdn.net/20130913163641750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2t5X3Fpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

int_t 为一个结构的标注，可以理解为type/typedef的缩写，表示它是通过typedef定义的，而不是一种新的数据类型。因为跨平台，不同的平台会有不同的字长，所以利用预编译和typedef可以最有效的维护代码。

 int8_t      : typedef signed char; 1B
 uint8_t    : typedef unsigned char; 1B
 int16_t    : typedef signed short ; 2B
 uint16_t  : typedef unsigned short ; 2B
 int32_t    : typedef signed int; 4B
 uint32_t  : typedef unsigned int; 4B
 int64_t    : typedef signed  long long; 8B
 uint64_t  : typedef unsigned long long; 8B

![image-20220716190622922](深入理解计算机系统.assets/image-20220716190622922.png)

![image-20220716190635837](深入理解计算机系统.assets/image-20220716190635837.png)

为什么取值范围不对称？

![image-20220722160508531](深入理解计算机系统.assets/image-20220722160508531.png)

> C和C++都支持有符号和无符号数。Java只支持有符号数。

#### 2.2.2 无符号数的编码

假设有一个整数数据类型有$w$位。我们可以将位向量写成立$\vec x$表示整个向量，或者写成$[x_{w-1},x_{w-2},...,x_{0}]$，表示向量中的每一位。把$\vec x$看做一个二进制的数，就获得了$\vec x$的无符号表示。在这个编码中，我们用一个函数$B2U_w$ (Binary to Unsigned) 的缩写，长度为$w$来表示：

原理：无符号数编码的定义，对向量$\vec x=[x_{w-1},x_{w-2},...,x_0]:$
$$
B2U_w(\vec x)≐\sum_{i=0}^{w-1}x_i2^i
$$
≐：左边等于右边。





#### 2.2.3 补码编码

补码(two's-complement)。我们用函数$B2T_w$表示。

+ 字的最高有效位解释为负权(negative weight)。

![image-20220716195955828](深入理解计算机系统.assets/image-20220716195955828.png)

![image-20220716200112803](深入理解计算机系统.assets/image-20220716200112803.png)

![image-20220716200154323](深入理解计算机系统.assets/image-20220716200154323.png)

假设w=4，我们能给每个可能的十六进制数字赋予一个数值，假设用一个无符号或者补码表示。完成下表：

| x        |        | 无符号(B2U(x)) | 补码(B2T(x)) |
| -------- | ------ | -------------- | ------------ |
| 十六进制 | 二进制 |                |              |
| 0xE      | 1110   | 14             | -2           |
| 0x0      | 0000   | 0              | 0            |
| 0x5      | 0101   | 5              | 5            |
| 0x8      | 1000   | 8              | -8           |
| 0xD      | 1101   | 13             | -3           |
| 0xF      | 1111   | 15             | -1           |

补码的范围不对称。

![image-20220716201323427](深入理解计算机系统.assets/image-20220716201323427.png)

补码范围是不对称的，根据定义。$|TMin|=|TMax|+1$，$TMin$没有与之对应的正数。所以会容易造成细微的错误。原因是一半的位模式表示负数，另一半表示非负数。第二，最大的无符号数值刚好比补码的最大值两倍大1,即$UMax_w=2TMax_w+1$，补码表示中所有表示负数的位模式在无符号表示中都变成了正数。

> 关于确定大小的整数类型的更多内容
>
> 对于某些程序来说，用某个确定大小的表示来编码数据类型非常重要。例如，当编写程序，使得机器能够按照一个标准协议在因特网上通信时，让数据类型与协议指定的数据类型兼容是非常重要的。我们前面看到了，某些C数据类型，特别是long型，在不同的机器上有不同的取值范围，而实际上C语言标准只指定了每种数据类型的最小范围，而不是确定的范围。虽然我们可以选择与大多数机器上的标准表示兼容的数据类型，但是这也不能保证可移植性。
>
> 我们已经见过了32位和64位版本的确定大小的整数类型(图2-3)，它们是一个更大数据类型类的一部分。ISO C99标准在文件stdint.h中引入了这个整数类型类。这个文件定义了一组数据类型，它们的声明形如 intN_t和uintN_t，对不同的N值指定N位有符号和无符号整数。N的具体值与实现相关，但是大多数编译器允许的值为8、16、32和64。因此，通过将它的类型声明为uint16_t，我们可以无歧义地声明一个16位无符号变量，而如果声明为int32_t，就是一个32位有符号变量。
>
> E这些数据类型对应着一组宏，定义了每个N的值对应的最小和最大值。这些宏名字形如`INTN_MIN`、`INTN_MAX`和`UINTN_MAX`。
>
> 确定宽度类型的带格式打印需要使用宏，以与系统相关的方式扩展为格式串。因此，举个例子来说，变量x和y的类型是int32_t和uint64_t，可以通过调用printf来打印它们的值，如下所示:`printf ("x = %"PRId32 "，y = %PRIu64 "\n"，x，y);`
>
> 编译为64位程序时，宏PRId32展开成字符串“d”，宏PRIu64则展开成两个字符串“1”“”。当C预处理器遇到仅用空格(或其他空白字符)分隔的一个字符串常量序列时，就把它们串联起来。因此，上面的printf调用就变成了:`printf("x = %d, y = %luln"，x, y);`
>
> 使用宏能保证:不论代码是如何被编译的，都能生成正确的格式字符串。

Java中，采用补码表示。

![image-20220722163413398](深入理解计算机系统.assets/image-20220722163413398.png)

将32位补码表示的数转换为10进制数。

| 32位补码   | 十进制 |
| ---------- | ------ |
| 0x1b8      | 440    |
| 0x14       | 20     |
| 0xFFFFFE58 | -424   |
| 0xFFFFFE74 | -396   |
| 0x44       | 68     |
| 0xFFFFFEC8 | -312   |
| 0x10       | 16     |
| 0xC        | 12     |
| 0xFFFFFEEC | -276   |
| 0x20       | 32     |

#### 2.2.4 有符号数和无符号数之间的转换

C语言允许在不同的数字数据类型之间做强制类型转换。
![[image-20220718192852587.png]]

-12345的16位补码跟53191的16位无符号数是完全一样的。

```c
short int v=-12345;
unsigned short uv =(unsigned short) v;
printf("v=%d,uv=%u\n",v,uv);
```

强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。

![image-20220722171645899](深入理解计算机系统.assets/image-20220722171645899.png)
![[image-20220718210952925.png]]

![image-20220722182844747](深入理解计算机系统.assets/image-20220722182844747.png)

#### 2.2.5 C语言中的有符号数与无符号数

创建无符号常量，加上后缀字符`u`或者`U`。

C语言允许无符号数和有符号数之间的转换。

例子：显示的强制类型转换

```c
int tx, ty;
unsigned ux, uy;
tx=(int)ux;
uy=(unsigned)ty;
```

隐式的转换：

```c
int tx, ty;
unsigned ux, uy;
tx=ux; /*Cast to signed*/
uy=ty; /*Cast to unsigned*/
```

当使用`printf`输出数值时，以`%d`，`%u`，`%x`以有符号十进制、无符号十进制和十六进制格式输出一个数字。也可以用`%u`输出类型为`int`的值，`%d`输出类型为`unsigned`的数值。

例：

```c
int x=-1;
unsigned u=2147483648;
printf("x=%u=%d\n",x,x);
printf("u=%u=%d\n",u,u);
```

当在一个 32 位机器上运行时，它的输出如下：

```c
x=4294967295=-1
u=2147483648=-2147483648
```

在这两种情况下， `printf`首先将这个字当作一个无符号数输出，然后把它当作一个有符号数输出。$T2U_{32}(-1)=UMax_{32}=2^{32}-1$和$U2T_{32}(2^{31})=$$-2^{31}$=$TMin_{32}$。

由于C语言对同时包含有符号和无符号数表达式的这种处理方式，出现了一些奇特的行为。当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数。

![image-20220723154401548](深入理解计算机系统.assets/image-20220723154401548.png)

**练习2.21**

![img](https://pic2.zhimg.com/80/v2-03c799522aa4519af8724e58b046a245_720w.jpg)

> C语言中TMin的写法
>
> 在图2-19和练习题2.21中，我们很小心地将TMin32 写成-2147483647-1。为什么不简单地写成-2147483648或者0x80000000?看一下C头文件limits.h,注意到它们使用了跟我们写$TMin_{32}$和$TMax_{32}$类似的方法:
>
> ```c
> /* Minimum and maximum values a‘ signed int' can hold. */
> #define INT MAX 2147483647
> #define INT_MIN (-INT_MAX - 1) 
> ```
>
> 补码的不对称性和C语言的转换规则之间奇怪的交互，迫使我们用这种不寻常的方式写$TMin_{32}$。

#### 2.2.6 扩展一个数字的位来表示

将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加0。这种运算被称为**零扩展**。

![image-20220725182717927](深入理解计算机系统.assets/image-20220725182717927.png)

例代码：

```c
short sx = - 12345;/* -12345 */
unsigned short usx = sx;/* 53191 */
int x = sx;/* -12345 */
unsigned ux = usx;/* 53191 */
printf("sx = %d:\t",sx) ;
show_ bytes ( (byte. pointer) &sX， sizeof (short)) ;
printf ("usx = %u:\t",usx) ;
show_ bytes ( (byte. _pointer) &usx， sizeof (unsigned short));
printf ("x = %d:\t",x);
show_ bytes ((byte. pointer) &x， sizeof (int)) ;
printf("ux = %u:\t",ux);
show_ bytes((byte_ pointer) &ux， sizeof (unsigned));

>>>
sx = -12345: cf c7 
usx = 53191: cf c7 
X = -12345: ff ff cf c7 
ux = 53191: 00 00 cf c7 
```

我们看到，尽管一12345的补码表示和53191的无符号表示在16位字长时是相同的，但是在32位字长时却是不同的。特别地，一12 345的十六进制表示为0xEFFFCFC7，而53191的十六进制表示为0x0000CFC7。前者使用的是符号扩展一最开头加了16位，都是最高有效位1,表示为十六进制就是0xFFFF。后者开头使用16个0来扩展，表示为十六进制就是0x0000。

字节从$w$=3拓展到$w$=4的符号拓展结果。位向量[101]表示值-4+1=-3。符号拓展，得到[1101]，表示的值-8+4+1=-3。我们可以看到，对于$w$=4，最高两位的组合值是-8+4=-4，与$w$=3时符号位的值相同。类似地，位向量[111]和[1111]都表示值-1。


![[image-20220725201205395.png]]
展示保持补码值的符号扩展。

![image-20220725201516140](深入理解计算机系统.assets/image-20220725201516140.png)

**练习题2.22**
A.[1011]：-5的原码是1101，反码是1010，补码是1011

B.[11011]：-5的原码是11101，反码是11010，补码是11011

C.[111011]：-5的原码是111101，反码是111010，补码是111011

**数据大小位数的转换，以及无符号和有符号数字之间的相互转换能够影响一个程序的行为。**

```C
short sx=-12345;
unsigned uy=sx;
printf("uy=%u:\t",uy);
show_bytes((byte_pointer) &uy,sizeof(unsigned));
```
```
uy=42949549591: ff ff cf c7
```

这表明当把`short`转换成`unsigned`时，我们先要改变大小，之后再完成从有符号到无符号的转换。也就是说`(unsigned) sx`等价于`(unsigned)(int) sx`，求值得到4 294954 951，而不等价于`(unsigned)(unsigned short)sx`，后者求值得到53191。事实上,这个规则是C语言标准要求的。

**练习题2.23**
考虑下面 2 个 C 函数：
```C
int fun1(unsigned word)
{
    return (int) ((word << 24) >> 24);
}

int fun2(unsigned word)
{
    return ((int) word << 24) >> 24);
}
```

假设在采用补码的 32 位机上运行，且有符号数是算术右移，无符号数是逻辑右移。填写下表。
![[Pasted image 20220807113734.png]]
fun1 中是在无符号数上右移地，是逻辑右移，fun2 中 word 先被转换成了有符号数 int，故是算术右移。

B. 函数 fun1 完成提取 word 的低 8 位的功能。fun2 完成提取后，还进行符号扩展。

#### 2. 2. 7 截断数字
减少表示一个数字的位数，例如下面的代码：
```C
int x=53191;
short sx=(short)x;
int y=sx;
```
强制转换为short时，32位的int被截断为了16位的short int。16位的位模式是-12345的补码表示。强制类型转换回int时，符号扩展把高16位设置为1，从而生成-12345的32位补码表示。

当将一个w位的数$\vec x=[x_{w-1},x_{w-2},...,x_0]$截断为一个k位数字时，我们会丢弃高$w一k$位，得到一个位向量$\vec x=[x_{k-1},x_{k-2},...,x_0]$。截断一个数字可能会改变它的值——溢出的一种形式。对于一个无符号数，我们可以很容易得出其数值结果。

>原理：截断无符号数
>
>令$\vec x$等于位向量$[x_{w-1},x_{w-2},...,x_0]$，而$\vec x'$是将其截断为k位的结果：$\vec x'=[x_{k-1},x_{k-2},...,x_0]$。令$x=B2U_w(\vec x)$，$x'=B2U_w(\vec x')$。则$x'=x$ $mod$ $2^k$。

> 推导：截断无符号数 
>![[Pasted image 20220807130546.png]]

>原理：截断补码数值
>![[Pasted image 20220807131132.png]]

> 推导：截断补码数值
>![[Pasted image 20220807131159.png]]

1.  无符号数的截断直接截去高位多余的位，例如截断到 k 位，相当于进行了 mod $2^k$ 操作。
2.  有符号数的截断也是直接截去高位多余的位，但是数值要进行补码数值的解析。

**练习题 2.24 p93**

假设将一个 4 位的数(0~F) 截断到 3 位数据(0~7)。填写下表。
![[Pasted image 20220807163354.png]]

#### 2.2.8 关于有符号数与无符号数的建议

可能会造成某些非直观的行为：隐式强制类型转换的细微差别错误’无符号数据类型造成的细微的错误。

**练习题2.25**

下列代码试图计算数组 a 中所有元的各，当参数 length 等于 0 时，运行这段代码应该返回 0.0，但实际上会遇到内存错误。为什么？改进？

```C
/* WARNING: This is buggy code */
float sum_elements(float a[], unsigned length)
{
    int i;
    float result = 0;
    
    for (i=0; i <= length -1; i++)
        result += a[i];
    return result;
}
```

由于 length 是无符号数， 故 length -1 在当 length 为 0 时将不是 -1 ，而是 UMax，故会遇到内存出错。

改进：将 length 声明改为 int 即可。或者判断改为 `i<length`。

**练习题 2.26 **

要写一个函数用来判定一个字符串是否比另一个更长。前提是要用字符串库函数 `strlen`，它的声明为： `size_t strlen(const char *s);`，最开始你写的函数是这样的：

```C
/* Determine whether string s is longer than string t */
/* WARNING: This function is buggy */
int strlonger(char *s, char *t) {
    return strlen(s) - strlen(t) > 0;
}
```

当进行一些测试时，似乎一切正确。进一步研究发现在头文件 stdio.h 中数据类型 size_t 是定义成 unsigned int 的。

A. 在当 s 的长度小于 t 的长度时，结果会不正确。

B. 这是因为，在 A 情况下，负数会隐式转成了正数。

C. 修改： 改为 `return strlen(s) > strlen(t);`

> 函数`getpeername`的安全漏洞
> 
> 程序会遇到进程中非法地址的错误，但是程序还是能读到它没有被授权的内核内存区域。此问题是由于数据类型不匹配造成的。在一个地方，长度参数是有符号数；而另一个地方是无符号数。我们可以看到，这个问题是由于数据类型的不匹配造成的：在一个地方，长度参数是有符号数；而另一个地方，它又是无符号数正如这个例子表明的那样，这样的不匹配会成为缺陷的原因，甚至会导致安全漏洞幸运的是，还没有案例报告有程序员在FreeBSD上利用了这个漏洞他们发布了一个安全建议， "FreeBSD-SA-02: 38. signed-error", 建议系统管理员如何应用补丁消除这个漏d要修正这个缺陷，只要将 copy_from_kernel 的参数 maxlen 声明为类型 size_t,也就是与memcpy的参数n一致。
> 
> 同时，本地变量len和返回值声明为`size_t`。

我们已经看到了许多无符号运算的细微特性，尤其是有符号数到无符号数的隐式转换，会导致错误或者漏洞的方式。避免这类错误的一种方法就是绝不使用无符号数。实际上，除了C以外很少有语言支持无符号整数。很明显，这些语言的设计者认为它们带来的麻烦要比益处多得多。比如，Java只支持有符号整数，并且要求以补码运算来实现。正常的右移运算符>>被定义为执行算术右移。特殊的运算符>>>被指定为执行逻辑右移。

当我们想要把字仅仅看做是位的集合而没有任何数字意义时，无符号数值是非常有用的。例如，往一个字中放人描述各种布尔条件的标记(flag)时，就是这样。地址自然地就是无符号的，所以系统程序员发现无符号类型是很有帮助的。当实现模运算和多精度运算的数学包时，数字是由字的数组来表示的，无符号值也会非常有用。

### 2.3 整数运算
#### 2.3.1 无符号加法
考虑两个非负整数x和y，满足0≤x，y<2^w。每个数都能表示为w位无符号数字。然而，如果计算它们的和，我们就有一个可能的范围$0≤+y≤2^{w+1}-2$。表示这个和可能需要w+1位。例如，图2-21展示了当x和y有4位表示时，函数x＋y的坐标图。参数(显示在水平轴上)取值范围为0~15，但是和的取值范围为0~30。函数的形状是一个有坡度的平面(在两个维度上，函数都是线性的)。如果保持和为一个$w+1$位的数字，并且把它加上另外一个数值，我们可能需要$w+2$个位，以此类推。这种持续的“字长膨胀”意味着，要想完整地表示算术运算的结果，我们不能对字长做任何限制。一些编程语言，例如Lisp，实际上就支持无限精度的运算，允许任意的(当然，要在机器的内存限制之内)整数运算。更常见的是，编程语言支持固定精度的运算，因此像“加法”和“乘法”这样的运算不同于它们在整数上的相应运算。
![[Pasted image 20220809151950.png]]
参数x和y定义运算$+_w^u$，其中$0≤x$，$y<2^w$，该操作是把整数和 x+y 截断为w位得到的结果，再把这个结果看做是一个无符号数。这可以被视为一种形式的模运算，对x+y的位级表示，简单丢弃任何权重大于$2^{w-1}$的位就可以计算出和模$2^w$。比如，考虑一个4位数字表示，x=9和y=12的位表示分别为[1001]和[1100]。它们的和是21，5位的表示为[10101]。但是如果丢弃最高位，我们就得到[0101]，也就是说，十进制值的5。这就和值21 mod 16=5一致。

我们可以将操作$+_w^u$描述为：![[Pasted image 20220809153038.png]]

算术运算溢出：_完整的整数结果不能放到数据类型的字节限制中去_。两个运算数的和为$2^w$或者更大时，就发生了溢出。图展示了字长w=4的无符号加法函数的坐标图。这个和是按模$2^4$=16计算的。当x十y<16时，没有溢出，并且$x+^u_4y$就是x+y。这对应于图中标记为“正常”的斜面。当x+y≥16时，加法溢出，结果相当于从和中减去16。这对应于图中标记为“溢出”的斜面。
![[Pasted image 20220811111007.png]]

![[Pasted image 20220811111035.png]]
**练习题2.27**

```C
int uadd_ok(unsigned x, unsigned y){
    unsigned result = x + y;
    printf("%u + %u = %u\n", x, y, result);
    return (result < x) || (result < y);
}
int usub_ok(unsigned x, unsigned y){
    unsigned result = x - y;
    printf("%u - %u = %u\n", x, y, result);
    return result > x;
}
int tadd_ok(int x, int y){
    int result = x + y;
    printf("%d + %d = %d\n", x, y, result);
    return ((result ^ x) & (result ^ y)) >> 31;
}
int tsub_ok(int x, int y){
    int result = x - y;
    printf("%d - %d = %d\n", x, y, result);
    return ((result ^ x) & (result ^ (-y))) >> 31;
}
```

模数加法形成了一种数学结构，称为**阿贝尔群**。可交换和可结合。有一个单位元0，并且每个元素有一个加法逆元。考虑$w$位的无符号数的集合，执行加法计算$+^u_w$，对于每个值，必然有某个值$-^u_wx$满足$-^u_wx+^u_wx=0$。

该加法的逆操作可以表述如下：


 0的无符号加法逆元是0

#### 2.3.2 补码加法

范围：$-2$

#### 2.3.3 补码的非

#### 2.3.4 无符号乘法

#### 2.3.5 补码乘法

#### 2.3.6 乘以常数

背景：

原理：乘以2的幂

设$x$为位模式$[x_{w-1},x_{w-2},...,x_0]$。

#### 2.3.7 除法

右移

算术右移

### 2.4 浮点数

$$
d=\sum_{i=-n}^m\times d_i
$$

#### 2.4.2 IEEE浮点表示





























### 第3章 程序的机器级表示

计算机执行**机器代码**，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据。

编译器：基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。

GCC C语言编译器：以汇编代码的形式产生输出。

汇编代码：机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。

高级语言编程中，机器屏蔽了程序的细节——机器级的实现，提供的抽象级别比较高，工作效率会更高，也更可靠。

汇编代码编程中，程序员指定程序用来执行的计算的低级指令。高级语言工作效率更高，具有可移植性。

> 网络旁注：ASM：IA32 IA32编程
>
> IA32是x86-64的32位前身，是Intel在1985年提出。

32位机器：4GB的随机访问存储器。

64位机器：多达256TB、16EB的内存空间。

#### 3.1 历史观点

Intel处理器俗称x86。

表示：K表示1000，M表示1000000，G表示1000000000。

8086：1978年，29K的晶体管。

80286：1985年，134K个晶体管。

#### 3.2 程序编码

















## 第三部分 程序间的交互和通信

目标：了解UNIX操作系统提供的基本`I/O`服务。

> 例：Web客户端和服务器，通过Internet彼此通信。

### 第10章：系统级`I/O`

含义：输入/输出(`I/O`)是在主存和外部设备(磁盘驱动器、终端和网络之间复制数据的过程)。

> 输入：从I/O设备复制数据到主存；
>
> 输出：从主存复制数据到`I/O`设备；

所有语言的运行时系统都提供执行I/O较高级别的工具。

> 例：ANSI C提供标准`I/O`库，包含`printf`或`scanf`这样执行带缓冲区的I/O函数。
>
> C++语言用它的重载操作符、`<<`(输入)和`>>`(输出)提供了类似的功能。
>
> Linux系统中，通过使用内核提供的系统级`Unix I/O`函数实现这些较高级别的`I/O`函数。

标准 IO 库没有提供读取**元文件**数据的方式，例如文件大小或文件创建时间

学习`Unix I/O`好处：

1. 理解其它系统概念。
2. 没有选择的选择。

#### 10.1 Unix I/O

一个`Linux`文件就是一个$m$个字节的序列：
$$
B_0,B_1,...,B_k,...,B_{m-1}
$$
`Unix I/O`：所有的`I/O`设备(网络、磁盘和终端)都被模型化为==**文件**==，所有输入和输出都被当作相应文件的读和写执行。这种将设备映射为文件的方式，允许`Linux`内核引出简单、低级的应用接口，即是`Unix I/O`。

这使得输入和输出都能以一种统一方式执行：

1. **打开文件**。一个应用程序通过要求内核打开相应的文件，宣告它想访问一个`I/O`设备。内核返回一个小的非负整数，叫做**描述符**，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。

   概念：描述符。

2. `Linux shell`创建的每个进程开始时都有三个打开的文件：

   + **标准输入**(描述符是0)
   + **标准输出(**描述符是1)
   + **标准错误**(描述符是2)
   + 头文件`<unistd.h>`定义了常量`STDIN_FILENO`、`STDOUT_FILENO`、`STDERR_FILENO`，用来代替显示的描述符值。

3. **改变当前的文件位置**。

   + 对于每个打开的文件，内核保持着一个文件位置$k$，初始为0。
   + 这个文件位置是从文件开头起始的**字节偏移量**。
   + 应用程序能够通过执行`seek`操作，显式地设置文件的当前位置为$k$。

4. **读写文件**。

   + 读操作
     + 从文件复制$n>0$个字节到内存，从当前文件位置$k$开始，然后将飞增加到$k+n$。
     + 给定一个大小为$m$字节的文件，当$k>m$时执行读操作会触发一个称为`end-of-file(EOF)`的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF 符号”。

   + 写操作
     + 从内存复制$n>0$个字节到一个文件，从当前文件位置$k$开始，然后更新$k$。

5. **关闭文件**。

   + 当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构。
   + 将这个描述符恢复到可用的描述符池中。
   + 无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。

#### 10.2 文件

每个Linux文件都有一个类型(type)表明它在系统中的角色：

+ `普通文件(regular file)`

  + 包含任意数据。
  + 应用程序
    + 文本文件(text file)
      + 文本文件只含有ASCII或Unicode字符的普通文件。
    + 二进制文件(binary file)
      + 二进制文件包含其他文件。

  + 内核不区分文本文件和二进制文件。

  + `Linux`文本文件包含了一个`文本行(text line)`序列，每一行都是一个字符序列，以一个新行符("\n")结束。
    + 新行符与ASCII的换行符(LF)相同，数字值为`0X0a`。

+ `目录(directory)`

  + 包含一组`链接(link)`的文件。
  + 每个链接都将一个`文件名(filename)`映射到一个文件，这个文件可能是另一个目录。
  + 每个目录至少含有两个条目：`“.”`是到该目录自身的链接，以及`“..”`是到目录层次结构中`父目录(parent directory)`的链接。
  + 用 `mkdir`命令创建一个目录，用`ls`查看其内容，用`rmdir`删除该目录

+ `套接字(socket)`：与另一个进程进行跨网络通信的文件。

其他文件类型：

+ 命名通道(named pipe)；
+ 符号链接(symbolic link)；
+ 字符和块设备(character and block device)；

`Linux`内核将所有文件组织成一个`目录层次结构(directory hierarchy)`，由名为`/`(斜杠)的根目录确定。系统中的每个文件都是根目录的直接或间接的后代。

<img src="深入理解计算机系统.assets/image-20221114230303570.png" alt="image-20221114230303570" style="zoom: 67%;" />

作为上下文的一部分，每个进程都有一个`当前工作目录(current working directory)`来确定其在目录层次结构中的当前位置。可以用`cd`命令来修改`shell`中的当前工作目录。

目录层次结构中的位置用`路径名(pathname)`来指定。路径名是一个字符串，包括一个可选斜杠，其后紧跟一系列的文件名，文件名之间用斜杠分隔。路径名有两种形式：

+ `绝对路径名(absolute pathname)`：以一个斜杠开始，表示从根节点开始的路径。例如，在图10-1中，`hello.c`的绝对路径名为`/home/droh/hello.c`。
+ `相对路径名(relative pathname)`：以文件名开始，表示从当前工作目录开始的路径。例如，在图10-1中，如果`/home/droh`是当前工作目录，那么`hello.c`的相对路径名就是`./hello.c`。反之，如果`/home/bryant`是当前工作目录，那么相对路径名就是`../home/droh/hello.c`。

#### 10.3 打开和关闭文件

进程通过调用`open`函数打开一个已存在的文件或创建一个新文件：

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(char *filename,int flags,mode_t mode);

//返回:若成功则为新文件描述符，若出错为-1。
```

`open`函数将`filename`转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。

##### flag参数

`flags`参数指明了进程打算如何访问这个文件:

+ `O_RDONLY`：只读。
+ `O_WRONLY`：只写
+ `O_RDWR`：可读可写。

例，下面的代码说明如何以读的方式打开一个已存在的文件：

`fd = Open("foo.txt",O_RDONLY,0);`

`flags`参数也可以是一个或者更多位掩码的或，为写提供给一些额外的指示：

+ `O_CREAT`：如果文件不存在，就创建它的一个`截断的(truncated)`(空)文件。
+ `O_TRUNC`：如果文件已经存在，就截断它。
+ `O_APPEND`:在每次写操作前，设置文件位置到文件的结尾处。

例如，下面的代码说明的是如何打开一个已存在文件，并在后面添加一些数据

`fd = Open("foo.txt",0_WRONLY|O_APPEND,0);`

> `|`表示管道：前面的结果作为后面的输入

##### mode参数

`mode`参数

+ 指定了新文件的访问权限位。

+ 访问权限位。在 `sys/stat.h` 中定义：

| 掩码 | 描述    |                                    |
| ---- | ------- | ---------------------------------- |
| usr  | S_IRUSR | 使用者（拥有者）能够读这个文件     |
|      | S_IWUSR | 使用者（拥有者）能够写这个文件     |
|      | S_IXUSR | 使用者（拥有者）能够执行这个文件   |
| grp  | S_IRGRP | 拥有者所在组的成员能够读这个文件   |
|      | S_IWGRP | 拥有者所在组的成员能够写这个文件   |
|      | S_IXGRP | 拥有者所在组的成员能够执行这个文件 |
| oth  | S_IROTH | 其他人（任何人）能够读这个文件     |
|      | S_IWOTH | 其他人（任何人）能够写这个文件     |
|      | S_IXOTH | 其他人（任何人）能够执行这个文件   |

作为上下文的一部分，每个进程都有一个`umask`，通过调用`umask`函数来设置的。当进程通过带某个`mode`参数的`open`函数调用来创建一个新文件时，文件的访问权限位被设置为`mode & ~ umask`。例如，假设我们给定下面的`mode`和`umask`默认值：

```c
#define DEF_MODE S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH
#define DEF_UMASK S_IWGRP|S_IWOTH
```

接下来，下面的代码片段创建一个新文件，文件的拥有者有读写权限，而所有其他的拥堵都有读权限：

```c
umask(DEF_UMASK);
fd = Open("foo.txt"，0_CREAT|O_TRUNC|O_WRONLY，DEF_MODE);
```

最后，进程通过调用`close`函数关闭打开的文件

```c
#include<unistd.h>
int close(int fd);
// 返回：若成功则为 0， 若出错则为 -1
```

关闭一个已关闭的描述符会出错。

**练习题10.1** 

```c
#include "csapp.h"
int main ()
{
  int fd1, fd2;
  fd1 = Open("foo. txt", 0_RDONLY, 0);
  fd2 = Open("bar.txt", 0_RDONLY, 0);
  Close(fd2);
  fd2 = Open("baz. txt", 0_RDONLY, 0);
  printf("fd2 = %d\n",  fd2);
  exit(0) ;
}
```

答案：Unix进程生命周期开始时，打开的描述符赋给了stdin(描述符 0) 、stdout(描述符 1)和stderr描述符 2)。`open函数`总是返回最低的未打开的描述符，所以第一次调用open会返回描述符3。调用close函数会释放描述符，最后对`open`的调用会返回描述符3，因此程序的输出是 "fd2=3"。

#### 10.4 读和写文件

应用程序通过调用`read`和`write`函数执行输入和输出。

```c
#include <unistd.h>
// fd 文件描述符       *buf 内存位置	 n 大小
ssize_t read(int fd, void *buf, size_t n);
// 返回： 若成功则为读的字节数，若 EOF(end of file) 则为0，若出错则为 -1.
ssize_t write(int fd, const void *buf, size_t n);
// 返回： 若成功则为写的字节数，若出错则为 -1.
```

##### `read`函数

含义：

+ 从描述符为`fd`的当前文件位置复制最多$n$个字节到内存位置 `buf`。

- 返回值
  - -1表示一个错误；
  - 0表示`EOF(end of file)；
  - 否则返回值表示的是实际传送的字节数量；

##### `write`函数

含义：从内存位置`buf`复制至多$n$个字节到描述符`fd`的当前文件位置。

以下程序使用`read`和`write`调用一次一个字节地从标准输入复制到标准输出。

```c
/* $begin cpstdin */
#include "csapp.h"

int main(void) 
{
    char c;

    while(Read(STDIN_FILENO, &c, 1) != 0) 
        Write(STDOUT_FILENO, &c, 1);
    exit(0);
}
/* $end cpstdin */
```

调用`lseek`函数，应用程序能够显式地修改当前文件的位置。

> ##### `ssize_t`和`size_t`的区别
>
> - read()函数`size_t`为参数，返回值为`ssize_t`。
> - x86-64 系统中，`size_t`定义为`unsigned long`，而`ssize_t` (**有符号的大小**) 被定义为`long`。
> - `read`函数返回一个有符号的大小，保证出错时能返回 **-1。**
> - 返回-1的可能性使得`read`的最大值减小了一半。

##### 不足值

背景：在某些情况下， read 和write传送的字节比应用程序要求的要少。这些不足值（ short count ）不表示有错误。

> **不足值是已经读到的文本**。

出现不足值的原因：

- 读时遇到 EOF
  - 准备读一个文件，该文件从当前文件位置开始只含有20个字节的。而文件以50个字节的片段进行读取。下一个`read`返回不足值为20，此后的`read`将通过返回不足值0发出EOF信号。
- 从终端读取文本行
  - 打开文件是与终端相关联的，每个`read`函数一次传送一个文本行，返回的不足值等于文本行的大小。
- **读和写网络套接字 socket**
  + 如果打开的文件对应于网络套接字，那么内部缓冲约束和较长的网络延迟会引起函数返回不足值。
  + 对Linux Pipe调用函数时，也有可能出现不足值。
- 读/写磁盘文件时，将会遇到不足值。
- 创建可靠诸如Web服务器的网络应用，须通过反复调用`read`和`write`处理不足值，直到所有需要字节传送完毕。

#### 10.5 用RIO包健壮地读写

RIO(Robust I/O) ：健壮的`I/O`包。

功能：

1. 自动处理上文中的不足值。
2. 在容易出现不足值的应用中，RIO包提供方便、健壮和高效的`I/O`。

RIO提供了两类函数：

- 无缓冲的输入输出函数
  - 函数直接在内存和文件中传送数据，没有应用级缓冲。
  -  对将**二进制数据**读写到网络和从网络读写**二进制数据**尤其有用。
- 带缓冲的输入函数
  - 高效地从文件中读取**文本行**和**二进制数据**。
  - 这些文件的内容缓存在**应用级缓冲区**中，类似于为 `printf` 这样的标准I/O函数提供的缓冲区。
  - 是**线程安全**的（见 Chapter 12.7.1 节）。
  - 在同一个描述符上可以被交错地调用。
  - 可以从一个描述符中读一些文本行，然后读取一些二进制数据，接着再多读取一些文本行。

##### 10.5.1 RIP的无缓冲的输入输出函数

调用`rio_readn`和`rio_writen`函数，应用程序可以在内存和文件之间直接传送数据。

```c
#include <unistd.h>
// fd 文件描述符       *usrbuf 内存位置	 n 大小
ssize_t rio_readn(int fd, void *usrbuf, size_t n);
ssize_t rio_writen(int fd, void *usrbuf, size_t n);
// 返回:若成功则为写传送的字节数,若EOF则为0(只对rio_readn而言)，若出错则为-1
```

`rio_readn`函数：

+ 从描述符`fd`的当前文件位置最多传送$n$个字节到内存位置`usrbuf`。
+ 遇到EOF时只能返回一个不足值。

`rio_writen`函数：

+ 从描述符`fd`的当前文件位置最多传送$n$个字节到描述符`fd`。
+ 不会返回不足值。
+ 对同一个描述符，可以任意交错地调用`rio_readn`和`rio_writen`。

`rio_readn`函数：

```c
/*
 * rio_readn - Robustly read n bytes (unbuffered)
 */
/* $begin rio_readn */
ssize_t rio_readn(int fd, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) {
		if ((nread = read(fd, bufp, nleft)) < 0) {
	    	if (errno == EINTR) /* Interrupted by sig handler return */
				nread = 0;      /* and call read() again */
	    	else
				return -1;      /* errno set by read() */ 
			} 
		else if (nread == 0)
	    	break;              /* EOF */
		nleft -= nread;
		bufp += nread;
    	}
    	return (n - nleft);         /* Return >= 0 */
}
/* $end rio_readn */
```

`rio_writen`函数：

```c
/*
 * rio_readn - Robustly read n bytes (unbuffered)
 */
/* $begin rio_readn */
ssize_t rio_readn(int fd, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) {
		if ((nread = read(fd, bufp, nleft)) < 0) {
	    	if (errno == EINTR) /* Interrupted by sig handler return */
				nread = 0;      /* and call read() again */
	    	else
				return -1;      /* errno set by read() */ 
			} 
		else if (nread == 0)
	   		break;              /* EOF */
		nleft -= nread;
		bufp += nread;
    	}
    	return (n - nleft);         /* Return >= 0 */
}
/* $end rio_readn */
```

> 如果`rio_readn`和`rio_writen`函数被一个从应用信号处理程序的返回中断，那么每个函数会手动地重启`read`或`write`。为了尽可能有较好的可移植性，我们允许被中断的系统调用，且在必要时重启它们。
