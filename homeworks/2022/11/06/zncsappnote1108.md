### 2.2 整数表示

引入数学术语，用于精确定义和描述计算机如何编码和操作整数。

![image-20220715150708163](../../../../../../体系结构/深入理解计算机系统.assets/image-20220715150708163.png)

**复习：原码、反码、补码**

原码 ：最高位是符号位，0代表正数，1代表负数，非符号位为该数字绝对值的二进制。

反码：正数的反码与原码一致，负数的反码是对原码按位取反，只是最高位（符号位）不变。 

补码：正数的补码与原码一致，负数的补码是对原码按位取反加1，符号位不变。

例如 十进制数字：5

> 5=2^2 + 2^0     101   至少要三位数字   加上符号位   就是4位数字
>
> 原码：0101       
>
> 反码：0101
>
> 补码：0101

例如 十进制数字：-5

> 5=2^2 + 2^0     101   至少要三位数字   加上符号位   就是4位数字
>
> 原码：1101
>
> 反码：1010
>
> 补码：1011

例如 将补码1011  转换为原码

> 补码：1011
>
> 符号位不变，数值位取反：1100
>
> 加1后得到原码：1101
>
> 补码变成原码的方式是：正数的补码与原码一致，负数的补码按位取反加1，符号位不变
>
> 反码变成原码的方式是：正数的反码与原码一致，负数的补码转换为源码后位取反，符号位不变

**用4位二进制原码表示0：-0=1000  +0=0000** 

**用4位二进制反码表示0：-0=1111  +0=0000** 

**用4位二进制补码表示0：-0=0000  +0=0000** 

**n+1位数字，绝对值最大的原码是  -(2^n - 1)和 2^n - 1**

**n+1位数字，绝对值最大的反码是  -(2^n - 1) 和 2^n - 1**

**n+1位数字，绝对值最大的补码是 −2^n ≤x ≤2^n−1**

![image-20220716200729163](../../../../../../体系结构/深入理解计算机系统.assets/image-20220716200729163.png)

```
=====================================================================================
1、正数的反码和补码都与原码相同。 
2、而负数的反码为对该数的原码除符号位外各位取反。 
3、负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1

1、原码表示法规定：用符号位和数值表示带符号数，正数的符号位用“0”表示，负数的符号位用“1”表示，数值部分用  二进制形式表示。 
2、反码表示法规定：正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反。 
3、补码表示法规定：正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1. 
4、正零和负零的补码相同，[+0]补=[-0]补=0000 0000B。

计算机中数值都是以补码的形式存储
======================================================================================
    真值             原码       ||       反码               补码              表示的数值
======================================================================================
    0             0000_0000   |                       0000_0000                  0
    1             0000_0001   |                       0000_0001                  1
   ...               ....     |                         ....
   ...               ....     |                         ....
   ...               ....     |                         ....
   ...               ....     |                         ....
   ...               ....     |                         ....
   127            0111_1111   |                       0111_1111                 127
=====================================================================================
   -0             1000_0000   |    1111_1111          1_0000_0000              -128  
   -1             1000_0001   |    1111_1110           1111_1111               -127
   -2             1000_0010   |    1111_1101           1111_1110               -126
  ...                ....     |
  ...                ....     |
  ...                ....     |
  -127            1111_1111   |    1000_0000           1000_0001                 -1
===================================================================================== 
  
=====================================================================================
    符号位         数值位
   1(负数)           7位 
   0(正数)           7位

   特殊：10000000  ：-0表示-128
   上述的-0位特殊情况，规定它在计算机中的表示的数为-128；
   -0:10000000按位取反再加1后为1_0000_0000超出了8位，把这个值规定为8位表示的-128；
   因此8位二进制数可表示的有符号数为0-255；可表示的无符号数为-128-0-127
=====================================================================================
在这里要说到一个概念 模，“模”是指一个计量系统的计数范围。如时钟等。 

时钟的计量范围是0～11，模=12。表示n位的二进制数计量范围是0～2(n)-1，模=2(n)，八位二进制数的模为2^8 。

任何有模的计量器，均可化减法为加法运算（这就是计算机二进制运算的原理）。假设当前时针指向10点，而准确时间是6点，调整时间可有以下两种拨法：一种是倒拨4小时，即：10-4=6；另一种是顺拨8小时：10+8=12+6=6 。在以12模的系统中，加8和减4效果是一样的，因此凡是减4运算，都可以用加8来代替。对“模”而言，8和4互为补数。实际上以12模的系统中，11和1，10和2，9和3，7和5，6和6都有这个特性。共同的特点是两者相加等于模。对于计算机，其概念和方法完全一样。n位计算机，设n=8， 所能表示的最大数是11111111，若再加1成为100000000(9位），但因只有8位，最高位1自然丢失。又回了00000000，所以8位二进制系统的模为2^8。在这样的系统中减法问题也可以化成加法问题，只需把减数用相应的补数表示就可以了，把补数用到计算机对数的处理上，就是补码。对一个正数的原码取反加一，得到这个正数对应负数的补码。例如~6=-7，而且加一之后会多出一个八进制补码1000 0000，而这个补码就对应着原码1000 0000，数字位同时当做符号位即-128 。所以根据以上我们可以理解为什么八位二进制数表示范围为-128~+127。八位二进制正数的补码范围是0000 0000 ~ 0111 1111 即0 ~ 127,负数的补码范围是正数的原码0000 0000 ~ 0111 1111 取反加一（也可以理解为负数1000 0000 ~ 1111 1111化为反码末尾再加一）。  所以得到 1 0000 0000 ~ 1000 0001,1000 0001作为补码，其原码是1111 1111（-127），依次往前推，可得到-1的补码为1111 1111，那么补码0000 0000的原码是1000 0000符号位同时也可以看做数字位即表示-128，这也解释了为什么127（0111 1111）+1（0000 0001）=-128（1000 0000）。
```



#### 2.2.1 整型数据类型

C语言支持多种整型数据类型——表示有限范围的整数。其中还给出了”典型”32 位和 64 位机器的取值范围。每种类型都能用关键字来指定大小，这些关键字包括char、short、long, 同时还可以指示被表示的数字是非负数 （声明为unsigned), 或者可能是负数（默认）。如图 2-3 所示，为这些不同的大小分配的字节数根据程序编译为32位还是64位而有所不同。根据字节分配，不同的大小所能表示 的值的范围是不同的 这里给出来的唯一一个与机器相关的取值范围是大小指示符 long 的。大多数 64 位机器使用8个字节的表示，比 32 位机器上使用的4个字节的表示的取值范围大很多。

char是1个字节，short是2个字节，int是4个字节，long在32位是4个字节，64位是8个字节。

> 在编程语言中，常见的数据类型包括原始类型（如：[整数](https://zh.wikipedia.org/wiki/整數)、[浮点数](https://zh.wikipedia.org/wiki/浮點數)或[字符](https://zh.wikipedia.org/wiki/字元)）、[多元组](https://zh.wikipedia.org/wiki/多元组)、记录单元、[代数数据类型](https://zh.wikipedia.org/w/index.php?title=代數資料類型&action=edit&redlink=1)、[抽象数据类型](https://zh.wikipedia.org/wiki/抽象資料類型)、[参考类型](https://zh.wikipedia.org/w/index.php?title=參考_(電腦科學)&action=edit&redlink=1)、[类](https://zh.wikipedia.org/wiki/类_(计算机科学))以及[函数类型](https://zh.wikipedia.org/w/index.php?title=函式物件&action=edit&redlink=1)。数据类型描述了[数值](https://zh.wikipedia.org/wiki/数值)的表示法、解释和结构，并以[算法](https://zh.wikipedia.org/wiki/演算法)操作，或是[对象](https://zh.wikipedia.org/wiki/物件_(電腦科學))在存储器中的存储区，或者其它存储设备。

![img](https://img-blog.csdn.net/20130913163641750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2t5X3Fpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

int_t 为一个结构的标注，可以理解为type/typedef的缩写，表示它是通过typedef定义的，而不是一种新的数据类型。因为跨平台，不同的平台会有不同的字长，所以利用预编译和typedef可以最有效的维护代码。

 int8_t      : typedef signed char; 1B
 uint8_t    : typedef unsigned char; 1B
 int16_t    : typedef signed short ; 2B
 uint16_t  : typedef unsigned short ; 2B
 int32_t    : typedef signed int; 4B
 uint32_t  : typedef unsigned int; 4B
 int64_t    : typedef signed  long long; 8B
 uint64_t  : typedef unsigned long long; 8B

![image-20220716190622922](../../../../../../体系结构/深入理解计算机系统.assets/image-20220716190622922.png)

![image-20220716190635837](../../../../../../体系结构/深入理解计算机系统.assets/image-20220716190635837.png)

为什么取值范围不对称？

![image-20220722160508531](../../../../../../体系结构/深入理解计算机系统.assets/image-20220722160508531.png)

> C和C++都支持有符号和无符号数。Java只支持有符号数。

#### 2.2.2 无符号数的编码

假设有一个整数数据类型有$w$位。我们可以将位向量写成立$\vec x$表示整个向量，或者写成$[x_{w-1},x_{w-2},...,x_{0}]$，表示向量中的每一位。把$\vec x$看做一个二进制的数，就获得了$\vec x$的无符号表示。在这个编码中，我们用一个函数${B2U_w}$ (Binary to Unsigned) 的缩写，长度为$w$)来表示：

![image-20220716192138190](../../../../../../体系结构/深入理解计算机系统.assets/image-20220716192138190.png)

![image-20220716192525706](../../../../../../体系结构/深入理解计算机系统.assets/image-20220716192525706.png)

#### 2.2.3 补码编码

补码(two's-complement)。我们用函数$B2T_w$表示。

+ 字的最高有效位解释为负权(negative weight)。

![image-20220716195955828](../../../../../../体系结构/深入理解计算机系统.assets/image-20220716195955828.png)

![image-20220716200112803](../../../../../../体系结构/深入理解计算机系统.assets/image-20220716200112803.png)

![image-20220716200154323](../../../../../../体系结构/深入理解计算机系统.assets/image-20220716200154323.png)

假设w=4，我们能给每个可能的十六进制数字赋予一个数值，假设用一个无符号或者补码表示。完成下表：

| x        |        | 无符号(B2U(x)) | 补码(B2T(x)) |
| -------- | ------ | -------------- | ------------ |
| 十六进制 | 二进制 |                |              |
| 0xE      | 1110   | 14             | -2           |
| 0x0      | 0000   | 0              | 0            |
| 0x5      | 0101   | 5              | 5            |
| 0x8      | 1000   | 8              | -8           |
| 0xD      | 1101   | 13             | -3           |
| 0xF      | 1111   | 15             | -1           |

补码的范围不对称。

![image-20220716201323427](../../../../../../体系结构/深入理解计算机系统.assets/image-20220716201323427.png)

补码范围是不对称的，根据定义。$|TMin|=|TMax|+1$，$TMin$没有与之对应的正数。所以会容易造成细微的错误。原因是一半的位模式表示负数，另一半表示非负数。第二，最大的无符号数值刚好比补码的最大值两倍大1,即$UMax_w=2TMax_w+1$，补码表示中所有表示负数的位模式在无符号表示中都变成了正数。

> 关于确定大小的整数类型的更多内容
>
> 对于某些程序来说，用某个确定大小的表示来编码数据类型非常重要。例如，当编写程序，使得机器能够按照一个标准协议在因特网上通信时，让数据类型与协议指定的数据类型兼容是非常重要的。我们前面看到了，某些C数据类型，特别是long型，在不同的机器上有不同的取值范围，而实际上C语言标准只指定了每种数据类型的最小范围，而不是确定的范围。虽然我们可以选择与大多数机器上的标准表示兼容的数据类型，但是这也不能保证可移植性。
>
> 我们已经见过了32位和64位版本的确定大小的整数类型(图2-3)，它们是一个更大数据类型类的一部分。ISO C99标准在文件stdint.h中引入了这个整数类型类。这个文件定义了一组数据类型，它们的声明形如 intN_t和uintN_t，对不同的N值指定N位有符号和无符号整数。N的具体值与实现相关，但是大多数编译器允许的值为8、16、32和64。因此，通过将它的类型声明为uint16_t，我们可以无歧义地声明一个16位无符号变量，而如果声明为int32_t，就是一个32位有符号变量。
>
> E这些数据类型对应着一组宏，定义了每个N的值对应的最小和最大值。这些宏名字形如`INTN_MIN`、`INTN_MAX`和`UINTN_MAX`。
>
> 确定宽度类型的带格式打印需要使用宏，以与系统相关的方式扩展为格式串。因此，举个例子来说，变量x和y的类型是int32_t和uint64_t，可以通过调用printf来打印它们的值，如下所示:`printf ("x = %"PRId32 "，y = %PRIu64 "\n"，x，y);`
>
> 编译为64位程序时，宏PRId32展开成字符串“d”，宏PRIu64则展开成两个字符串“1”“”。当C预处理器遇到仅用空格(或其他空白字符)分隔的一个字符串常量序列时，就把它们串联起来。因此，上面的printf调用就变成了:`printf("x = %d, y = %luln"，x, y);`
>
> 使用宏能保证:不论代码是如何被编译的，都能生成正确的格式字符串。

Java中，采用补码表示。

![image-20220722163413398](../../../../../../体系结构/深入理解计算机系统.assets/image-20220722163413398.png)

将32位补码表示的数转换为10进制数。

| 32位补码   | 十进制 |
| ---------- | ------ |
| 0x1b8      | 440    |
| 0x14       | 20     |
| 0xFFFFFE58 | -424   |
| 0xFFFFFE74 | -396   |
| 0x44       | 68     |
| 0xFFFFFEC8 | -312   |
| 0x10       | 16     |
| 0xC        | 12     |
| 0xFFFFFEEC | -276   |
| 0x20       | 32     |

#### 2.2.4 有符号数和无符号数之间的转换

C语言允许在不同的数字数据类型之间做强制类型转换。
![[image-20220718192852587.png]]

-12345的16位补码跟53191的16位无符号数是完全一样的。

```c
short int v=-12345;
unsigned short uv =(unsigned short) v;
printf("v=%d,uv=%u\n",v,uv);
```

强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。

![image-20220722171645899](../../../../../../体系结构/深入理解计算机系统.assets/image-20220722171645899.png)
![[image-20220718210952925.png]]

![image-20220722182844747](../../../../../../体系结构/深入理解计算机系统.assets/image-20220722182844747.png)

#### 2.2.5 C语言中的有符号数与无符号数

创建无符号常量，加上后缀字符`u`或者`U`。

C语言允许无符号数和有符号数之间的转换。

例子：显示的强制类型转换

```c
int tx, ty;
unsigned ux, uy;
tx=(int)ux;
uy=(unsigned)ty;
```

隐式的转换：

```c
int tx, ty;
unsigned ux, uy;
tx=ux; /*Cast to signed*/
uy=ty; /*Cast to unsigned*/
```

当使用`printf`输出数值时，以`%d`，`%u`，`%x`以有符号十进制、无符号十进制和十六进制格式输出一个数字。也可以用`%u`输出类型为`int`的值，`%d`输出类型为`unsigned`的数值。

例：

```c
int x=-1;
unsigned u=2147483648;
printf("x=%u=%d\n",x,x);
printf("u=%u=%d\n",u,u);
```

当在一个 32 位机器上运行时，它的输出如下：

```c
x=4294967295=-1
u=2147483648=-2147483648
```

在这两种情况下， `printf`首先将这个字当作一个无符号数输出，然后把它当作一个有符号数输出。$T2U_{32}(-1)=UMax_{32}=2^{32}-1$和$U2T_{32}(2^{31})=$$-2^{31}$=$TMin_{32}$。

由于C语言对同时包含有符号和无符号数表达式的这种处理方式，出现了一些奇特的行为。当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数。

![image-20220723154401548](../../../../../../体系结构/深入理解计算机系统.assets/image-20220723154401548.png)

**练习2.21**

![img](https://pic2.zhimg.com/80/v2-03c799522aa4519af8724e58b046a245_720w.jpg)

> C语言中TMin的写法
>
> 在图2-19和练习题2.21中，我们很小心地将TMin32 写成-2147483647-1。为什么不简单地写成-2147483648或者0x80000000?看一下C头文件limits.h,注意到它们使用了跟我们写$TMin_{32}$和$TMax_{32}$类似的方法:
>
> ```c
> /* Minimum and maximum values a‘ signed int' can hold. */
> #define INT MAX 2147483647
> #define INT_MIN (-INT_MAX - 1) 
> ```
>
> 补码的不对称性和C语言的转换规则之间奇怪的交互，迫使我们用这种不寻常的方式写$TMin_{32}$。

#### 2.2.6 扩展一个数字的位来表示

将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加0。这种运算被称为**零扩展**。

![image-20220725182717927](../../../../../../体系结构/深入理解计算机系统.assets/image-20220725182717927.png)

例代码：

```c
short sx = - 12345;/* -12345 */
unsigned short usx = sx;/* 53191 */
int x = sx;/* -12345 */
unsigned ux = usx;/* 53191 */
printf("sx = %d:\t",sx) ;
show_ bytes ( (byte. pointer) &sX， sizeof (short)) ;
printf ("usx = %u:\t",usx) ;
show_ bytes ( (byte. _pointer) &usx， sizeof (unsigned short));
printf ("x = %d:\t",x);
show_ bytes ((byte. pointer) &x， sizeof (int)) ;
printf("ux = %u:\t",ux);
show_ bytes((byte_ pointer) &ux， sizeof (unsigned));

>>>
sx = -12345: cf c7 
usx = 53191: cf c7 
X = -12345: ff ff cf c7 
ux = 53191: 00 00 cf c7 
```

我们看到，尽管一12345的补码表示和53191的无符号表示在16位字长时是相同的，但是在32位字长时却是不同的。特别地，一12 345的十六进制表示为0xEFFFCFC7，而53191的十六进制表示为0x0000CFC7。前者使用的是符号扩展一最开头加了16位，都是最高有效位1,表示为十六进制就是0xFFFF。后者开头使用16个0来扩展，表示为十六进制就是0x0000。

字节从$w$=3拓展到$w$=4的符号拓展结果。位向量[101]表示值-4+1=-3。符号拓展，得到[1101]，表示的值-8+4+1=-3。我们可以看到，对于$w$=4，最高两位的组合值是-8+4=-4，与$w$=3时符号位的值相同。类似地，位向量[111]和[1111]都表示值-1。


![[image-20220725201205395.png]]
展示保持补码值的符号扩展。

![image-20220725201516140](../../../../../../体系结构/深入理解计算机系统.assets/image-20220725201516140.png)

**练习题2.22**
A.[1011]：-5的原码是1101，反码是1010，补码是1011

B.[11011]：-5的原码是11101，反码是11010，补码是11011

C.[111011]：-5的原码是111101，反码是111010，补码是111011

**数据大小位数的转换，以及无符号和有符号数字之间的相互转换能够影响一个程序的行为。**

```C
short sx=-12345;
unsigned uy=sx;
printf("uy=%u:\t",uy);
show_bytes((byte_pointer) &uy,sizeof(unsigned));
```

```
uy=42949549591: ff ff cf c7
```

这表明当把`short`转换成`unsigned`时，我们先要改变大小，之后再完成从有符号到无符号的转换。也就是说`(unsigned) sx`等价于`(unsigned)(int) sx`，求值得到4 294954 951，而不等价于`(unsigned)(unsigned short)sx`，后者求值得到53191。事实上,这个规则是C语言标准要求的。

**练习题2.23**
考虑下面 2 个 C 函数：

```C
int fun1(unsigned word)
{
    return (int) ((word << 24) >> 24);
}

int fun2(unsigned word)
{
    return ((int) word << 24) >> 24);
}
```

假设在采用补码的 32 位机上运行，且有符号数是算术右移，无符号数是逻辑右移。填写下表。
![[Pasted image 20220807113734.png]]
fun1 中是在无符号数上右移地，是逻辑右移，fun2 中 word 先被转换成了有符号数 int，故是算术右移。

B. 函数 fun1 完成提取 word 的低 8 位的功能。fun2 完成提取后，还进行符号扩展。

#### 2. 2. 7 截断数字

减少表示一个数字的位数，例如下面的代码：

```C
int x=53191;
short sx=(short)x;
int y=sx;
```

强制转换为short时，32位的int被截断为了16位的short int。16位的位模式是-12345的补码表示。强制类型转换回int时，符号扩展把高16位设置为1，从而生成-12345的32位补码表示。

当将一个w位的数$\vec x=[x_{w-1},x_{w-2},...,x_0]$截断为一个k位数字时，我们会丢弃高$w一k$位，得到一个位向量$\vec x=[x_{k-1},x_{k-2},...,x_0]$。截断一个数字可能会改变它的值——溢出的一种形式。对于一个无符号数，我们可以很容易得出其数值结果。

>原理：截断无符号数
>
>令$\vec x$等于位向量$[x_{w-1},x_{w-2},...,x_0]$，而$\vec x'$是将其截断为k位的结果：$\vec x'=[x_{k-1},x_{k-2},...,x_0]$。令$x=B2U_w(\vec x)$，$x'=B2U_w(\vec x')$。则$x'=x$ $mod$ $2^k$。

> 推导：截断无符号数 
> ![[Pasted image 20220807130546.png]]

>原理：截断补码数值
>![[Pasted image 20220807131132.png]]

> 推导：截断补码数值
> ![[Pasted image 20220807131159.png]]

1.  无符号数的截断直接截去高位多余的位，例如截断到 k 位，相当于进行了 mod $2^k$ 操作。
2.  有符号数的截断也是直接截去高位多余的位，但是数值要进行补码数值的解析。

**练习题 2.24 p93**

假设将一个 4 位的数(0~F) 截断到 3 位数据(0~7)。填写下表。
![[Pasted image 20220807163354.png]]



#### 2.2.8 关于有符号数与无符号数的建议

可能会造成某些非直观的行为：隐式强制类型转换的细微差别错误’无符号数据类型造成的细微的错误。

**练习题2.25**

下列代码试图计算数组 a 中所有元的各，当参数 length 等于 0 时，运行这段代码应该返回 0.0，但实际上会遇到内存错误。为什么？改进？

```C
/* WARNING: This is buggy code */
float sum_elements(float a[], unsigned length)
{
    int i;
    float result = 0;
    
    for (i=0; i <= length -1; i++)
        result += a[i];
    return result;
}
```

由于 length 是无符号数， 故 length -1 在当 length 为 0 时将不是 -1 ，而是 UMax，故会遇到内存出错。

改进：将 length 声明改为 int 即可。或者判断改为 `i<length`。

**练习题 2.26 **

要写一个函数用来判定一个字符串是否比另一个更长。前提是要用字符串库函数 `strlen`，它的声明为： `size_t strlen(const char *s);`，最开始你写的函数是这样的：

```C
/* Determine whether string s is longer than string t */
/* WARNING: This function is buggy */
int strlonger(char *s, char *t) {
    return strlen(s) - strlen(t) > 0;
}
```

当进行一些测试时，似乎一切正确。进一步研究发现在头文件 stdio.h 中数据类型 size_t 是定义成 unsigned int 的。

A. 在当 s 的长度小于 t 的长度时，结果会不正确。

B. 这是因为，在 A 情况下，负数会隐式转成了正数。

C. 修改： 改为 `return strlen(s) > strlen(t);`

> 函数`getpeername`的安全漏洞
>
> 程序会遇到进程中非法地址的错误，但是程序还是能读到它没有被授权的内核内存区域。此问题是由于数据类型不匹配造成的。在一个地方，长度参数是有符号数；而另一个地方是无符号数。我们可以看到，这个问题是由于数据类型的不匹配造成的：在一个地方，长度参数是有符号数；而另一个地方，它又是无符号数正如这个例子表明的那样，这样的不匹配会成为缺陷的原因，甚至会导致安全漏洞幸运的是，还没有案例报告有程序员在FreeBSD上利用了这个漏洞他们发布了一个安全建议， "FreeBSD-SA-02: 38. signed-error", 建议系统管理员如何应用补丁消除这个漏d要修正这个缺陷，只要将 copy_from_kernel 的参数 maxlen 声明为类型 size_t,也就是与memcpy的参数n一致。
>
> 同时，本地变量len和返回值声明为`size_t`。

我们已经看到了许多无符号运算的细微特性，尤其是有符号数到无符号数的隐式转换，会导致错误或者漏洞的方式。避免这类错误的一种方法就是绝不使用无符号数。实际上，除了C以外很少有语言支持无符号整数。很明显，这些语言的设计者认为它们带来的麻烦要比益处多得多。比如，Java只支持有符号整数，并且要求以补码运算来实现。正常的右移运算符>>被定义为执行算术右移。特殊的运算符>>>被指定为执行逻辑右移。

当我们想要把字仅仅看做是位的集合而没有任何数字意义时，无符号数值是非常有用的。例如，往一个字中放人描述各种布尔条件的标记(flag)时，就是这样。地址自然地就是无符号的，所以系统程序员发现无符号类型是很有帮助的。当实现模运算和多精度运算的数学包时，数字是由字的数组来表示的，无符号值也会非常有用。

### 2.3 整数运算

#### 2.3.1 无符号加法

考虑两个非负整数x和y，满足0≤x，y<2^w。每个数都能表示为w位无符号数字。然而，如果计算它们的和，我们就有一个可能的范围$0≤+y≤2^{w+1}-2$。表示这个和可能需要w+1位。例如，图2-21展示了当x和y有4位表示时，函数x＋y的坐标图。参数(显示在水平轴上)取值范围为0~15，但是和的取值范围为0~30。函数的形状是一个有坡度的平面(在两个维度上，函数都是线性的)。如果保持和为一个$w+1$位的数字，并且把它加上另外一个数值，我们可能需要$w+2$个位，以此类推。这种持续的“字长膨胀”意味着，要想完整地表示算术运算的结果，我们不能对字长做任何限制。一些编程语言，例如Lisp，实际上就支持无限精度的运算，允许任意的(当然，要在机器的内存限制之内)整数运算。更常见的是，编程语言支持固定精度的运算，因此像“加法”和“乘法”这样的运算不同于它们在整数上的相应运算。
![[Pasted image 20220809151950.png]]
参数x和y定义运算$+_w^u$，其中$0≤x$，$y<2^w$，该操作是把整数和 x+y 截断为w位得到的结果，再把这个结果看做是一个无符号数。这可以被视为一种形式的模运算，对x+y的位级表示，简单丢弃任何权重大于$2^{w-1}$的位就可以计算出和模$2^w$。比如，考虑一个4位数字表示，x=9和y=12的位表示分别为[1001]和[1100]。它们的和是21，5位的表示为[10101]。但是如果丢弃最高位，我们就得到[0101]，也就是说，十进制值的5。这就和值21 mod 16=5一致。

我们可以将操作$+_w^u$描述为：![[Pasted image 20220809153038.png]]

算术运算溢出：_完整的整数结果不能放到数据类型的字节限制中去_。两个运算数的和为$2^w$或者更大时，就发生了溢出。图展示了字长w=4的无符号加法函数的坐标图。这个和是按模$2^4$=16计算的。当x十y<16时，没有溢出，并且$x+^u_4y$就是x+y。这对应于图中标记为“正常”的斜面。当x+y≥16时，加法溢出，结果相当于从和中减去16。这对应于图中标记为“溢出”的斜面。
![[Pasted image 20220811111007.png]]

![[Pasted image 20220811111035.png]]
**练习题2.27**

```C
int uadd_ok(unsigned x, unsigned y){
    unsigned result = x + y;
    printf("%u + %u = %u\n", x, y, result);
    return (result < x) || (result < y);
}
int usub_ok(unsigned x, unsigned y){
    unsigned result = x - y;
    printf("%u - %u = %u\n", x, y, result);
    return result > x;
}
int tadd_ok(int x, int y){
    int result = x + y;
    printf("%d + %d = %d\n", x, y, result);
    return ((result ^ x) & (result ^ y)) >> 31;
}
int tsub_ok(int x, int y){
    int result = x - y;
    printf("%d - %d = %d\n", x, y, result);
    return ((result ^ x) & (result ^ (-y))) >> 31;
}
```

模数加法形成了一种数学结构，称为**阿贝尔群**。可交换和可结合。有一个单位元0，并且每个元素有一个加法逆元。考虑$w$位的无符号数的集合，执行加法计算$+^u_w$，对于每个值，必然有某个值$-^u_wx$满足$-^u_wx+^u_wx=0$。

该加法的逆操作可以表述如下：
![[Pasted image 20220811112028.png]]

 0的无符号加法逆元是0