控制冒险：
取指令和指令译码不会需要遇到任何停顿，这是基于一个假设。就是，所有的指令代码都是顺序加载执行的。不过这个假设，在执行的代码中，一旦遇到 if…else 这样的条件分支，或者 for/while 循环，就会不成立。
在执行条件分支时，无法确定是按顺序执行下一条指令还是直接跳转到另一个内存地址去取别的指令，这种为了确保能取到正确的指令，而不得不进行等待延迟的情况，就是控制冒险；
解决办法一：缩短分支延迟
无论是条件跳转，还是地址跳转，都是在指令译码阶段就能获得的。所以，可以将条件判断、地址跳转，都提前到指令译码阶段进行，而不需要放在指令执行阶段。对应的，也要在 CPU 里面设计对应的旁路，在指令译码阶段，就提供对应的判断比较的电路。
这种方式，本质上和操作数前推的解决方案类似，就是在硬件电路层面，把一些条件计算结果更早地反馈到流水线中。这样反馈变得更快了，后面的指令需要等待的时间就变短了。不过只是改造硬件，并不能彻底解决问题。
跳转指令的比较结果，仍然要在指令执行的时候才能知道。在流水线里，第一条指令进行指令译码的时钟周期里，其实就要去取下一条指令了。这个时候，其实还没有开始指令执行阶段，自然也就不知道比较的结果。