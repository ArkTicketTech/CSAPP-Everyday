# 3.4 访问信息

一个x86-64的中央处理器单元（CPU）包含一组16个存储64位值的**通用目的寄存器**。这些寄存器用来存储整数数据和指针。

指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。

生成1字节和2字节数字的指令会保持剩下的字节不变， 生成4字节数字的指令会把高位4个字节置为0。

## 3.4.1 操作数指示符

大多数指令有一个或多个**操作数**，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。操作数分为三种类型：

1. **立即数**：用来表示常数值。立即数的书写方式是“后面跟一个用标准表示法表示的整数，如-577或$0x1F。
2. **寄存器**：表示某个寄存器的内容。
3. **内存引用**：它会根据计算出来的地址（通常称为**有效地址**）访问某个内存位置。

## 3.4.2 数据传送指令

最简单形式的数据传送指令——MOV类。这些指令把数据从源位置复制到目的位置，不做任何变化。

限制：传送指令的两个操作数不能都指向内存位置。

MOV指令只会更新目的操作数制定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。

常规的movq指令只能以表示为32位补码数字的立即数作为源操作数。movabsq指令能以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。

MOVZ和MOVS可以将较小的源值复制到较大的目的。

- MOVZ类中的指令把目的中剩余的字节填充为0。
- MOVS类中的指令通过符号拓展来填充。

注意没有一条明确的指令把4字节源值零扩展到8字节目的。这样的数据传送可以用movl指令来实现。

## 3.4.3 数据传送示例

C语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。

## 3.4.4 压入和弹出栈数据

pushq指令的功能是把数据压到栈上，而popq指令时弹出数据。这些指令只有一个操作数——压入的数据源和弹出的数据目的。