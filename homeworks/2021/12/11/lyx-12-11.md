## 缓冲区溢出

程序在内存中是以一下形式进行组织的:

![img](https://wdxtub.com/images/csapp/14611833392466.jpg)

最上面是运行时栈，有 8MB 的大小限制，一般用来保存局部变量。然后是堆，动态的内存分配会在这里处理，例如 `malloc()`, `calloc()`, `new()` 等。然后是数据，指的是静态分配的数据，比如说全局变量，静态变量，常量字符串。最后是共享库等可执行的机器指令，这一部分是只读的。

可以见到，栈在最上面，也就是说，栈再往上就是另一个程序的内存范围了，这种时候我们就可以通过这种方式修改内存的其他部分了。

举个例子

```
typedef struct 
{
    int a[2];
    double d;
} struct_t;

double fun(int i)
{
    volatile struct_t s;
    s.d = 3.14;
    s.a[i] = 1073741824; // 可能会越界
    return s.d;
}
```

复制

不同的 i 可能的执行结果是：

- `fun(0)` -> 3.14
- `fun(1)` -> 3.14
- `fun(2)` -> 3.1399998664856
- `fun(3)` -> 2.00000061035156
- `fun(4)` -> 3.14
- `fun(6)` -> Segmentation fault

之所以会产生这种错误，是因为访问内存的时候跨过了数组本身的界限修改了 d 的值。你没看错，这是个大问题！如果不检查输入字符串的长度，就很容易出现这种问题，尤其是针对在栈上有界限的字符数组。

在 Unix 中，`gets()` 函数的实现是这样的：

```
// 从 stdin 中获取输入
char *gets(char *dest)
{
    int c = getchar();
    char *p = dest;
    while (c != EOF && c != '\n')
    {
        *p++ = c;
        c = getchar();
    }
    *p = '\0';
    return dest;
}
```

复制

可以看到并没有去检测最多能读入多少字符（于是很容易出问题），类似的情况还在 `strcpy`, `strcat`, `scanf`, `fscanf`, `sscanf` 中出现。比如说

```
void echo() {
	char buf[4]; // 太小
	gets(buf);
	puts(buf);
}

void call_echo() {
	echo();
}
```

复制

我们来测试一下这个函数，可能的结果是：

```
unix> ./echodemo
 Input: 012345678901234567890123
Output: 012345678901234567890123

unix> ./echodemo
 Input: 0123456789012345678901234
Segmentation Fault
```

复制

为什么明明在 `echo()` 中声明 `buf` 为 4 个 char，居然一开始输入这么多都没问题？我们到汇编代码里去看看：

```
00000000004006cf <echo>:
    4006cf: 48 83 ec 18         sub   $0x18, %rsp
    4006d3: 48 89 e7            mov   %rsp, %rdi
    4006d6: e8 a5 ff ff ff      callq 400680 <gets>
    4006db: 48 89 e7            mov   %rsp, %rdi
    4006de: e8 3d fe ff ff      callq 400520 <puts@plt>
    4006e3: 48 83 c4 18         add   $0x18, %rsp
    4006e7: c3                  retq

# call_echo 部分
    4006e8: 48 83 ec 08         sub   $0x8, %rsp
    4006ec: b8 00 00 00 00      mov   $0x0, %eax
    4006f1: e8 d9 ff ff ff      callq 4006cf <echo>
    4006f6: 48 83 c4 08         add   $0x8, %rsp
    4006fa: c3                  retq
```

复制

我们看 `4006cf` 这一行，可以发现实际上给 %rsp 分配了 0x18 的空间，所以可以容纳不止 4 个 char。

在调用 `gets` 函数之前（第 `4006d6` 行），内存中栈帧示意图为：

![img](https://wdxtub.com/images/csapp/14611853013958.jpg)

结合上面代码可以看到，`call_echo` 栈帧中保存着调用之前执行指令的地址 `4006f6`，用于返回之后继续执行。我们输入字符串 `01234567890123456789012` 之后，栈帧中缓冲区被填充，如下：

![img](https://wdxtub.com/images/csapp/14611855170102.jpg)

虽然缓冲区溢出了，但是并没有损害当前的状态，程序还是可以继续运行（也就是没有出现段错误），但是如果再多一点的话，也就是输入 `0123456789012345678901234`，内存中的情况是这样的：

![img](https://wdxtub.com/images/csapp/14611856222781.jpg)

就把返回地址给覆盖掉了，当 `echo` 执行完成要回到 `call_echo` 函数时，就跳转到 `0x400034` 这个内容未知的地址中了。也就是说，通过缓冲区溢出，我们可以在程序返回时跳转到任何我们想要跳转到的地方！攻击者可以利用这种方式来执行恶意代码！

那么我们现在来看看，怎么处理缓冲区溢出攻击，有几种方式：

1. 好好写代码，尽量不让缓冲区异常
2. 程序容易出问题，那么提供系统层级的保护
3. 编译器也可以来个认证(stack canaries)

第一种，避免缓冲区溢出，我们用更安全的方法，如：`fgets`, `strncpy` 等等。

第二种，栈的位置不确定，让缓冲区溢出没办法影响到，并且每次位置都不一样，就不怕被暴力破解。并且也可以把一段内存标记为只读，那么就避免因为缓冲区溢出而导致的重写。

第三种，使用认证机制(Stack Canaries)。简单来说，就是在超出缓冲区的位置加一个特殊的值，如果发现这个值变化了，那么就知道出问题了。

但是，除了缓冲区溢出，还有另一种攻击的方式，称为返回导向编程[4]。可以利用修改已有的代码，来绕过系统和编译器的保护机制，攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为Gadgets）。每一段 gadget 通常结束于 return 指令，并位于共享库代码中的子程序。系列调用这些代码，攻击者可以在拥有更简单攻击防范的程序内执行任意操作。

具体利用缓冲区进行攻击的例子，会在[【读厚 CSAPP】III Attack Lab](https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/2016/04/16/thick-csapp-lab-3/) 中进行讲解，这里不再赘述。

