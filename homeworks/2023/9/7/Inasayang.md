#### 消除不必要的内存引用

combine3的例子中，在循环中直接对目标值进行读写，每次迭代时，累计变量的值都要从内存中读出再写入，这样虽然很浪费，但是保守正确

combine4的例子中，引入了临时变量，每次迭代时，只需要写到局部变量里，消除了每次循环迭代中从内存中读出并将更新值写回的需要，需要注意函数的设计

1.  acc 是函数内部定义的临时变量,存储在栈内存中。它的访问速度比较快,因为:
    -   不存在间接访问,可以直接用寄存器访问acc。
    -   存储在栈顶附近,访问时间短。
    -   优化器可能会将acc缓存到寄存器中。
2.  *dest 是传入的指针参数,需要一次间接访问才能获取其指向的变量。相比acc:
    -   需要额外的间接访问时间。
    -   存储在栈底部,访问时间略长。
    -   无法缓存到寄存器中。
3.  综上,acc的访问速度会比*dest快一些。具体的差距需要实际运行测试。
4.  如果*dest缓存优化效果好,或者处理器prefetch管线优化明显,两者速度也会很接近。
5.  如果去掉acc变量,直接用*dest计算,则不会存在访问差异。



#### 理解现代处理器

##### 整体操作

超标量（superscalar），在每个时钟周期执行多个操作，且是乱序的；需要更大更复杂的硬件，能更好的达到指令集并行度

-   指令控制单元（Instruction Control Unit，ICU）
    -   从指令高速缓存（instruction cache）中读出指令序列，包含最近访问的指令，根据指令序列生成一组针对程序数据的基本操作
    -   分支问题
        -   选择分支
            -   控制被传递到分支目标
        -   不选择分支
            -   控制被传递到指令序列的下一条指令
        -   使用分支预测（branch prediction）
            -   处理器草测是否会选择分支，预测分支的目标地址
            -   使用投机执行（speculation execution）（P358）
-   执行单元（Execution Unit，EU）
    -   执行操作
    -   P359-P360



Pp. 354-360