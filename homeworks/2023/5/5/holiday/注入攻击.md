1

【给我举例子解释一下C语言中的注入攻击】

注入攻击(Injection Attack)是一种常见的网络攻击手段,它通过向Web应用程序输入恶意的代码或命令,以达到如扣费、篡改数据等目的。C语言中也存在这方面的漏洞,主要体现在对用户输入的Validate不严,导致恶意输入被当做程序命令或SQL语句执行。下面举个简单的例子加以说明:

```
c
#include <stdio.h>
#include <string.h>

int main() {
    char str[100];
    printf("Please input your name: ");
    scanf("%s", str);

    char command[100];
    sprintf(command, "echo 'Hello, %s!'", str);
    system(command);
}
```

该程序获取用户输入的名字,并拼接在echo命令中输出打招呼信息。但如果用户输入:

```
;rm -rf *
```

则command变为:

```
echo 'Hello, ;rm -rf * !'
```

系统在执行system(command)时,会将;当做命令分隔符,将后续的rm -rf *当做一个系统命令执行,导致文件删除。这个例子漏洞在于:

1. 对用户输入str未做严格过滤和校验,没有限制或转义特殊字符。
2. sprintf将用户输入str直接拼接在系统命令中执行,这提供了注入恶意命令的途径。
3. system函数在执行多个命令时,将;当做命令分隔符。相比Web注入,C语言注入更加危险,因为攻击者可以直接在系统命令行注入恶意命令

修复上例代码的方法是:

1. 对用户输入进行校验,过滤或转义特殊字符
2. 不使用sprintf将用户输入直接拼在系统命令中
3. 系统命令使用其他拼接方式,而非;分隔多个命令

2

【有和内存相关的注入攻击的例子吗】

是的,C语言中也存在与内存相关的注入攻击,主要是缓冲区溢出攻击(Buffer Overflow Attack)。缓冲区溢出是指向存储在缓冲区(内存中的一段连续区域)中的数据写入超过缓冲区大小的数据,导致相邻的内存区域被覆盖。攻击者可以精心构造输入数据,覆盖相邻内存区域中程序流程控制所依赖的数据,使程序执行流程偏离正常方向,达到恶意攻击目的。下面是一个简单的例子:

```
c
#include <stdio.h>
#include <string.h>

int main() {
    char buf[8];
    printf("Enter your name: ");
    scanf("%s", buf);
    printf("Hello, %s!", buf);
}
```

上例允许用户输入长度不超过8字节的名字。但如果攻击者输入"123456789AB",则会发生如下缓冲区溢出:

```
    buf[8] -> | 12345678 | ABxxxxxxxx <- 模式后续地址
             |        8 |   2        <- 输入数据长度
```

"A" 和 "B"覆盖buf数组之后的两个字节,如果这两个字节正好是程序流程控制所依赖的数据,比如函数的返回地址,那么程序执行流程就会被攻击者控制。修复上例代码的方法是:1. 限制scanf读取的数据长度,如scanf("%7s", buf)2. 使用更安全的函数替代scanf,如fgets()3. 对输入数据的长度进行校验,不超过buf大小4. 采用栈防护技术,如堆栈随机化等所以,和注入攻击类似,要防止缓冲区溢出攻击,开发人员必须意识到来自外部的输入数据可能包含精心构造的恶意代码,以达到破坏程序正常执行流程的目的。如果不对输入数据的长度和格式进行严格控制,那么缓冲区溢出就会成为一个巨大的软件漏洞,危害程度不亚于注入攻击。

3

【上面的例子中，如果A和B正好是程序流程控制所依赖的数据,比如函数的返回地址，那么程序执行流程就会被攻击者控制，这句话要怎么理解】

这句话的意思是,如果输入数据中植入的恶意代码(例如AB)正好覆盖了程序控制流所依赖的内存数据(比如函数返回地址),那么程序的执行流程就会被攻击者控制。举个更具体的例子加以说明:

```
c
void foo() {
    char buf[8];
    gets(buf);
    ...
}

int main() {
    foo();
    printf("Hello\\n");
}
```

foo函数允许用户输入8个字节的数据,如果攻击者输入"12345678AB",那么内存布局是:

```
     buf[8] -> |12345678|ABxxxxxx <- foo()栈帧之后的内存
              |        |
             缓冲区    函数返回地址(存放主调main函数的地址)
```

由于AB覆盖了foo函数的返回地址,所以当foo函数返回时,程序会跳转到AB这个非法地址执行,而不是返回到main函数。这时,执行流程就被攻击者控制了。攻击者构造特定的输入数据,可以使程序跳转到buf数组之外已经植入的恶意代码,从而执行危害操作。这就实现了利用缓冲区溢出攻击控制程序执行流程。所以,输入数据覆盖了程序控制流所依赖的关键内存数据(如返回地址),会导致程序执行与预期不符的行为,执行流程就被攻击者篡改控制。这是缓冲区溢出攻击的关键之处。要防止这种攻击,就必须对所有的输入数据长度和格式进行严格控制,保证它们不会覆盖任何程序控制流所依赖与使用的内存数据。同时,也可以采用其他安全措施,如堆栈随机化等,增加攻击者控制程序执行流程的难度。