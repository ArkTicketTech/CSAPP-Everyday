- # 7.12 Position-Independent Code (PIC)  
	- 共享库的核心目的在于允许多个运行进程共享内存中的相同库代码，从而节省宝贵的内存资源。  
	- 一种简单的方式就是为每个共享库分配一个专用的地址空间块，并要求加载器始终将共享库加载到该地址。但这样的坏处在于，即使进程不适用该库，也会分配一块空间。系统中存在的数百个苦和不同的版本可能会让地址空间呗分裂成许多小的碎片。  
	- 为了避免这个问题，现代系统对共享模块的代码段进行编译，以便可以在内存中的任何位置加载，而无需由链接器进行修改。使用这种方法，共享模块的代码段的单个副本可以被无限数量的进程共享。  
	- 在x86-64系统上，对同一可执行对象模块中的符号的引用不需要特殊处理即可成为PIC。这些引用可以使用PC相对寻址进行编译，并在静态链接器构建对象文件时由其进行重定位。  
	- 然而，对由共享模块定义的外部过程和全局变量的引用需要一些特殊的技术。我们下面来介绍。  
	- ## PIC Data References  
		- ![image.png](../assets/image_1686838850499_0.png)  
		- 这个设计的核心在于 code segment 是不让改的，所以我们选择修改 data segment ，建立一个 GOT 在 segment 区。 每个进程都有一个自己的 GOT 表。 每个变量指向 GOT 表的记录是固定的。编译器为GOT中的每个条目生成了一个重定位记录。在加载时，动态链接器对每个GOT条目进行重定位，使其包含对象的绝对地址。  
	- ## PIC Function Calls  
		- ![image.png](../assets/image_1686840201171_0.png)  
		- 实现采用延迟绑定。主要好处是减少加载时的重定位次数，从而提高加载的效率和性能。在典型的应用程序中，对于一个共享库（如libc.so）导出的数百或数千个函数，实际上只会调用其中的一小部分。通过将函数地址的解析推迟到第一次调用函数时进行，动态链接器可以避免在加载时进行数百或数千次不必要的重定位。  
		- 具体过程需要 PLT 和 GOT 的协作。  
			- 过程链接表（PLT）：PLT是一个由指令序列组成的代码段的一部分。它包含了一系列的过程链接条目，每个条目对应一个函数。每个过程链接条目由两个部分组成：一个简单的跳转指令和一个延迟绑定的解析过程。当第一次调用函数时，跳转指令将控制转移到解析过程。解析过程负责从GOT中获取函数的真实地址，并将其写入PLT中，以便下次直接调用。之后的调用将直接跳转到函数的真实地址，避免了重复的解析过程。  
			- 全局偏移表（GOT）：GOT是数据段的一部分，它包含了全局数据对象和函数的地址。对于每个函数，在GOT中都有一个对应的条目。初始时，这些条目包含的是一个特殊的跳转指令，称为延迟绑定跳转指令。当函数首次被调用时，延迟绑定跳转指令会触发PLT中的解析过程，并将函数的真实地址写入到对应的GOT条目中。之后的调用将直接跳转到该地址，无需再经过解析过程。  
		- 在上面的例子中就是 初次调用先从 GOT[4] 跳转到 PLT[2] 然后将 addvec 入栈，然后跳转到 PLT[0] 通过 GOT[0] 跳入 动态链接器，决定 addvec 的运行时地址，然后覆写 GOT[4]；之后的调用则可以直接从 GOT[4] 跳转 addvec  
		-  