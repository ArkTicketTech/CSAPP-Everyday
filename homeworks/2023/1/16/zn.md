# CSAPP笔记

**3.5 算术和逻辑操作**

x86-64 的每个指令类都有**对应四种不同大小数据**的指令

算术和逻辑操作共有四组：

1. 加载有效地址

2. 1. leaq S, D：将 S 的地址保存到 D 中，D 必须是寄存器

3. 一元操作

4. 1. inc D: D+1
   2. dec D: D-1
   3. neg D：取负
   4. not D：取补

5. 二元操作（加减乘，与或异或，没有除法）

6. 1. add s, d: d=d+s
   2. sub s, d:  d=d-s
   3. imul s, d: d=d*s 乘
   4. xor s, d: d=d^s 异或
   5. or s, d: d=d|s 或
   6. and s,d: d=d&s 与

7. 移位

8. 1. sal k,d: d=d<
   2. shl k,d: d=d<
   3. sar k,d: d=d<
   4. shr k,d: d=d<

**3.5.1 加载有效地址**

leaq 实际上是 movq 指令的变形。操作是从内存读数据地址到寄存器。

leaq 在实际应用中常常不用来取地址，而用来计算加法和有限形式的乘法

​                leaq 9(rdi, rsi, 4), rax;//x in rdi,y in rsi。此操作实际上等于将 x+4*y+9 的结果存入 rax              

**3.5.2 一元和二元操作**

一元操作中的操作数既是源又是目的。

二元操作中的第二个操作数既是源又是目的。

因为不能从内存到内存，因此当第二个操作数是内存地址时，要先从内存读出值，执行操作后再把结果写回去。

注意 sub s,d 是 d-s 而不是 s-d

**3.5.3 移位操作**

移位操作的移位量可以是一个立即数或放在单字节寄存器 cl 中。

当移位量大于目的数的长度时，只取移位量低字节中的值（小于目的数长度）来作为真实的移位量。

**3.5.4 特殊的算术操作**

两个 64 位数的乘积需要 128 位来表示，x86-64指令集可以有限的支持对 128 位数的操作，包括乘法和除法。

128 位数需要两个寄存器来存储，移动时也需要两个 movq 指令来移动。

这种情况对于有符号数和无符号数采用了不同的指令。