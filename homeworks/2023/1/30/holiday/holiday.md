## 操作系统控制硬件

我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d0a491c4-9467-4e35-9360-0e4d313f4f85/Untitled.png)

## 操作系统两个基本功能

（1）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

（2）防止硬件被失控的应用程序滥用

操作系统通过几个基本的抽象概念（**进程**、**虚拟内存**和**文件**）来实现这两个功能。如图 1-11 所示，**文件**是对 I/O 设备的抽象表示， **虚拟内存**是对主存和磁盘 I/O 设备的抽象表示 **进程**则是对处理器、主存和 I/O 设备的抽象表示。我们将依次讨论每种抽象表示

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/76e24bf7-0524-47f7-a660-d37d755a948b/Untitled.png)

## 进程

像 hello 这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和 I/O 设备。处理器看上去就像在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。

### **并发运行**

在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件

### 上下文切换

操作系统实现这种交错执行的机制称为上下文切换

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文 ，包括许多信息，比如 **PC 和寄存器文件的当前值，以及主存的内容**。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。

### 进程上下文切换例子

示例场景中有两个并发的进程∶shell 进程和 hello 进程。最开始，只有 shell 进程在运行，即等待命令行上的输入。当我们让它运行 hello 程序时，shell 通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存 shell 进程的上下文，创建一个新的 hello 进程及其上下文，然后将控制权传给新的 hello 进程。hello 进程终止后，操作系统恢复 shell 进程的上下文，并将控制权传回给它，shell 进程会继续等待下一个命令行输入。

如图 1-12 所示，从一个进程到另一个进程的转换是由操作系统**内核**（kernel）管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的**系统调用**（system call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/536c6014-e78a-4bda-a7c5-400911e3931e/Untitled.png)

## 线程

尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为**线程**的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。

由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型。

多线程之间比多进程之间**更容易共享数据**，也因为线程一般来说都**比进程更高效**。

## 虚拟内容

虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。**每个进程看到的内存都是一致的，称为虚拟地址空间。**

图 1-13 所示的是 Linux 进程的虚拟地址空间（其他 Unix 系统的设计也与此类似）。在 Linux 中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。请注意，图中的地址是从下往上增大的。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/29f2ce6f-28c2-4516-abc0-b468ef0be71e/Untitled.png)

每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。

- **程序代码和数据**

  对所有的进程来说，代码是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件 hello。

- **堆**

  代码和数据区后紧随着的是运行时堆。**代码和数据区在进程一开始运行时就被指定了大小**，与此不同，当调用像 malloc 和 free 这样的 C 标准库函数时，**堆可以在运行时动态地扩展和收缩**。

- **共享库** 大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂

- **栈**

  位于用户虚拟地址空间顶部的是**用户栈**，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩

- **内核虚拟内存**

  地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作

虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。**基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存**。

## 文件

**文件**就是字节序列，仅此而已

每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的。

文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的 I/O 设备。