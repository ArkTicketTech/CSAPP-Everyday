**3.6 控制**

条件语句、循环语句、分支语句都要求有条件的执行。

机器代码提供两种低级机制来实现有条件的行为：

1. **测试数据值**，然后根据测试的结果来改变控制流或数据流
2. **使用 jump 指令进行跳转**

**3.6.1 条件码**

**条件码寄存器**都是单个位的，是不同于整数寄存器的另一组寄存器。

条件码描述了最近的算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令。

常用条件码：

1. **CF：进位标志。**最近的操作使最高位产生了进位。可以用来检查无符号数的溢出
2. **ZF：零标志。**最近的操作的结果为 0
3. **SF：符号标志。**最近的操作的结果为负数。
4. **OF：溢出标志。**最近的操作导致了补码溢出

除了 leaq 指令外，其余的所有算术和逻辑指令都会**根据运算结果设置条件码**。

此外还有两类特殊的指令，他们只设置条件码不更新目的寄存器：

- **cmp s1, s2：**除了不更新目的寄存器外与 sub 指令的行为相同
- **test s1, s2：**除了不更新目的寄存器外与 and 指令的行为相同

**3.6.2 访问条件码**

条件码一般不直接读取，常用的使用方法有 3 种：

1. 根据条件码的某种组合，使用 set 指令类将一个字节设置为 0 或 1。
2. 条件跳转到程序的某个其他部分
3. 有条件地传送数据

**set 指令类**

set 指令的目的操作数是低位单字节寄存器元素或一个字节的内存位置。set 会将该字节设置为 0 或 1

set 指令类的后缀指明了所考虑的条件码的组合，如 setl (set less) 表示“小于时设置”

​    ![0](https://note.youdao.com/yws/public/resource/fc45065e632e1d7a6f07ab4b11152fbe/xmlnote/C48232938D984A2BAE77556E75599457/14185)

注意到上图中，set 指令对于大于、小于的比较分为了有符号和无符号两类。

大多数时候，机器代码对无符号和有符号两种情况使用一样的指令。

使用不同指令来处理无符号和有符号操作的情况：

1. 不同的条件码组合：
2. 不同版本的右移：sar 和 shr
3. 不同的乘法和除法指令

汇编语言中数据本身不区分有符号和无符号，通过不同的指令来区分有符号操作和无符号操作。

注意在汇编代码中，8字节的操作数可能是 long，long long 或 指针

**3.6.3 跳转指令**

跳转指令的目的地由一个标号指明

​                    jmp .L1 ;//跳转到 .L1 。在实际的跳转指令中，.L1 会直接编码为跳转目标的地址。    movq (rax),rdx .L1:    popq rdx              

jmp 可以是直接跳转，即操作数为标号。也可以间接跳转，即操作数是寄存器或内存引用，这种情况下跳转到寄存器中存储的地址处。

跳转指令分为**有条件跳转**和**无条件跳转**，只有 jmp 是无条件跳转。有条件跳转都只能是直接跳转。

有条件跳转类似 set 指令系列，根据条件码寄存器的值来判断是否进行跳转。

​    ![0](https://note.youdao.com/yws/public/resource/fc45065e632e1d7a6f07ab4b11152fbe/xmlnote/A4D988D637244C2B8C7DC439F7AD9DE2/14239)

**3.6.4 跳转指令的编码**

**跳转指令的机器编码**（就是纯粹数字表示的机器语言）有几种方式，其中两种如下：

- **PC 相对跳转**：使用目标地址与跳转指令之后下一条指令的地址之间的差来编码。可以用 1、2 或 4 个字节来编码。
- **绝对地址编码**：使用目标的绝对地址。用 4 个字节直接指出。

汇编器和链接器会自己选择适当的编码方式

**3.6.5 用条件控制来实现条件分支**

汇编代码层面的条件控制类似于 c 语言的 goto 语句。

汇编语言使用条件码和条件跳转来起到和 c 语言中 if 相似的作用

​                'C 语言' if( x<y ) { i++ } else { i-- } '汇编' cmpq rsi,rdi jge .L2 incl rax; .L2:    decl rax;              