无论我们在内存中的何处加载一个目标模块（包括共享目标模块），数据段与代码段的距离总保持不变。代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置无关。

PIC函数调用：编译器没有办法预测函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，动态链接器在程序加载的时候再解析。GNU编译系统使用了延迟绑定技术，将过程地址的绑定推迟到第一次调用该过程时候。把函数地址的解析推迟到它实际被调用的地方，能避免动态链接器在加载时进行成百上千个并不需要的重定位。第一次调用过程的运行时开销很大，但其后每次调用都只会花费一条指令和一个间接的内存引用。


GOT和过程连接表的交互实现延迟绑定，GOT是数据段的一部分（每个条目是8字节地址），PLT是代码段的一部分（每个条目是16字节代码）。

Linux链接器支持一个很强大的技术，称为库打桩，它允许你截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入输出，甚至替换成一个完全不同的实现。

给定一个需要打桩的目标函数，创建一个包装函数。使用某种打桩机制，可以欺骗系统调用包装函数而不是目标函数了。包装函数会执行它自己的逻辑，调用目标函数，再将目标函数返回值传递给调用者。

打桩可发生在编译时、链接时或当程序被加载和执行的运行时。
