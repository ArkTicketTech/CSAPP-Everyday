位置无关代码

共享库的目的是允许多个进程共享内存中相同的库代码

-   给每个共享库分配专用的地址空间片，加载器总是从这个地址加载
    -   对地址空间的使用率不高，即使进程不适用，也会被分配
    -   难以管理，无法保证片不会重叠，库被修改后，必须确保已分配的片还是适合的，否则会出现一个库的多个版本
-   位置无关代码，加载而无需重定位的代码 Position-Independent Code，PIC
    -   gcc使用-fpic选项生成PIC代码，共享库的编译选项总是使用这个



PIC数据引用

代码段中的任何指令和数据段中的任何变量之间的距离都是一个运行时常量，与绝对内存位置无关

生成全局变量PIC引用，在数据段开始的地方创建全局偏移量表（Global Offset Table，GOT）

在GOT中，每个被目标模块引用的全局数据目标有一个8字节条目，编译器为每个条目生成一个重定位记录

加载时，动态链接器重定位每个条目，使之包含目标的绝对地址



PIC函数调用

延迟绑定lazy binding 将过程地址的绑定推迟到第一次调用

-   GOT
-   过程链接表Procedure Linkage Table，PLT



库打桩机制

library interpositioning

允许截获对共享库函数的调用，取代为执行自己的代码

可以追踪对某个函数的调用次数，验证和追踪输入输出值，或者替换成不同的实现

可以发生在编译，链接，加载，运行时



编译时打桩

使用-I. 参数



链接时打桩

使用--wrap f标志

把对符号f的引用解析成`__wrap_f`，把对符号`__real_f`的引用解析为f



Pp. 489-494