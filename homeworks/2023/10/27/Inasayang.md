重定位条目

代码的重定位条目放在.rel.text

已初始化数据的重定位条目放在.rel.data



ELF中两种最基本的重定位类型

-   R_X86_64_PC32
    -   重定位一个使用32位PC相对地址的引用
    -   一个PC相对地址就是距PC当前运行时值的偏移量
    -   当CPU执行一条使用PC相对寻址的指令时，在指令中编码的32位值上加上PC的当前运行时值，得到有效地址
    -   PC值通常是下一条指令在内存中的地址
-   R_X86_64_32
    -   重定位一个使用32位绝对地址的引用
    -   CPU通过绝对寻址，可以直接使用在指令中编码的32位值作为有效地址



-   小型代码模型small code model 默认
-   中型代码模型medium code model -mcmodel=medium
-   大型代码模型large code model -mcmodel=large



重定位符号引用 略



可执行目标文件

-   只读内存段|代码段
    -   ELF头
        -   包括程序的入口点entry point，要执行的第一条指令的地址
    -   段头部表
    -   .init
        -   定义了_init函数，程序的初始化代码会调用它
    -   .text
    -   .rodata
-   读写内存段|数据段
    -   .data
    -   .bss
-   不加载到内存的符号表和调试信息
    -   .symtab
    -   .debug
    -   .line
    -   .strtab
    -   节头部表



加载可执行目标文件

shell调用称为加载器loader的操作系统代码来运行

通过调用execve函数来调用加载器

加载器将可执行目标文件的代码和数据从磁盘复制到内存中，再跳转到第一条指令或入口点来运行

每个linux程序都有一个运行时内存映像

-   代码段总是从地址0x400000处开始
-   接着是数据段
-   运行时堆在数据段之后，调用malloc库往上增长
-   堆后面的区域是为共享模块保留
-   用户栈总是从最大的合法用户地址2^28-1开始，向较小内存地址增长
-   栈上从2^48开始，是为kernel中代码和数据保留的



Pp. 479-485