你想要通过块以利用空间局部 性的想法，如果的你缓存没有命中，你将会遇到一些麻烦，你只能去内存中获取一些数据，你希望通过获取多个字节，来分摊获取该数据的成本，因为特别是在空间局部性的原则上，你可能会引用附近的字，这也是一个结尾，块的整个目的就是利用空间局部性，如果你的块太小，那么你就不会摊销。因为内存中已存在的块，你会命中缓存。

写

有多个数据副本，我们正在进行子设置，因为我们在层次结构中向上移动，我们在缓存中**创造数据的子集**，那么我们对当前在缓存中的块内的数据字进行写操作，我们有这么大的一个块，我们正在更新它的一小部分，**我们可以进行更新，然后立即将他们刷新到内存中，因此，内存中始终保持着缓存的镜像**，意思是你知道内存访问时非常费时的。

另一个选择是所谓的【写回】，在这种情况下我们写入缓存中的块，直到我们选择的那条特定的组作为被替换者，才会被覆盖，只有这样我们只是推迟写入的时间，我们将其推迟到缓存覆盖该数据块之前，对于写回，你需要在行中加一些**额外的位**来指示是否写入了这些块。

算法就是：当缓存识别出一个特定的行将覆盖时，它检查该行上的【修改位】，如果已设置，则将该数据写回磁盘，如果数据没有写入，那么没有必要将其写回来，因为它与磁盘上块的副本具有相同的值