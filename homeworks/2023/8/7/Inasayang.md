# 第一章 计算机系统漫游

例子`hello.c`，

```c
#include <stdio.h>

int main()
{
    printf("hello,world\n");
    return 0;
}
```

### **信息就是位+上下文**

源程序时一个由0和1组成的位（`bit`）序列，8个位被组织成1组（`byte`）

使用`ASCII`标准保存文本字符

系统中所有的信息（磁盘文件，内存中的程序，内存中的用户数据，网络上的数据）都是一串bit表示

区分不同数据对象的唯一方法：通过数据对象的上下文；在不同的上下文中，一个同样的`byte sequence`可能表示一个整数，浮点数，字符串或机器指令

> 数字的机器表示方式与实际的整数和实数不同。只是真值的有限近似值。（Mark）
> 

### **程序被其他程序翻译成不同的格式**

***每条***C语句都被其他程序转为***一系列***低级机器语言指令

把指令按照***可执行目标程序***的格式打包，以***二进制磁盘文件***存储，称为***可执行目标文件***

```bash
gcc -o hello hello.c
```

`GCC`把`hello.c`翻译成`hello`，一共四个阶段（执行四个阶段的程序：***预处理器***，***编译器***，***汇编器***，***链接器***），这四个阶段构成***编译系统***（***compilation system***）

`hello.c`

|

预处理器（`cpp`）

|

`hello.i`（修改了的源程序，文本）

|

编译器（ccl）

|

`hello.s`（汇编程序，文本）

|

汇编器（`as`）

|

`hello.o`（可重定位目标程序，二进制）

|

链接器（`ld`）（`printf.o`）

|

hello（可执行目标程序，二进制）

- 预处理阶段
    - `cpp`以`#`开头的命令，修改`c`文件
    - 读取头文件的内容，直接插入程序文本中，得到另一个`c`程序（`.i`作为文件扩展名）
- 编译阶段
    - `ccl`将文本文件`hello.i`翻译成文本文件`hello.s`（汇编语言程序）
    - `hello.s`是一条条低级机器语言指令（汇编）
- 汇编阶段
    - `as`将`hello.s`翻译成机器语言指令
    - 打包成***可重定位目标程序***（***relocatable object program***）的格式，保存到`hello.o`
    - 此时，`hello.o`中一系列指令编码
- 链接阶段
    - `printf`函数位于`printf.o`的单独的预编译好的目标文件中
    - `ld`把`printf.o`合并到`hello.o`中，得到`hello`

Pp.1-5
