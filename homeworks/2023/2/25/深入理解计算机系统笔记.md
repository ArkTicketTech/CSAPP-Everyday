# 深入理解计算机系统(CSAPP)

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHtt00XBvS4gFjhfw7b%2F-MHttfdsLWUPlWSz8ANj%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88.pdf..20200922190952319_00.png?alt=media&token=f65abe2d-0a5c-4e2c-91b8-5f008051209c)

> 作者：兰德尔 E. 布莱恩特

## 第 1 章：计算机系统漫游

**计算机系统**是由硬件和系统软件组成的，它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有相似的硬件和软件组件，它们又执行着相似的功能。一些程序员希望深入了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的，以此来提高自身的技能。本书便是为这些读者而写的。

在 Kernighan 和 Ritchie 的关于 C 编程语言的经典教材【61】中，他们通过图 1-1 中所示的 hello 程序来向读者介绍 C。尽管 hello 程序非常简单，但是为了让它实现运行，系统的每个主要组成部分都需要协调工作。从某种意义上来说，本书的目的就是要帮助你了解当你在系统上执行 hello 程序时，系统发生了什么以及为什么会这样。

```c
#include <stdio.h>
int main()
{
    printf("hello, world\n");
    return 0;
}
```

我们通过跟踪 hello 程序的生命周期来开始对系统的学习——从它被程序员创建开始，到在系统上运行，输出简单的消息，然后终止。我们将沿着这个程序的生命周期，简要地介绍一些逐步出现的关键概念、专业术语和组成部分。后面的章节将围绕这些内容展开。

### **1.1 信息就是位 + 上下文**

hello 程序的生命周期是从一个**源程序**（或者说源文件）开始的，即程序员通过编辑器创建并保存的文本文件，文件名是 hello.c。源程序实际上就是一个由值 0 和 1 组成的位（又称为比特）序列，8 个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。

大部分的现代计算机系统都使用 ASCII 标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数值来表示每个字符。比如，图 1-2 中给出了 hello.c 程序的 ASCII 码表示。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2Fsync%2Fb21fa77cbcdfba62be01af7b13234cf5eed3c055.png?generation=1624553050781139&alt=media" alt="img" style="zoom: 50%;" />

程序如何存储在文件中？`hello.c`程序是以字节序列的方式储存在文件中的。每个字节都有一个整数值，对应于某些字符。例如，第一个字节的整数值是 35，它对应的就是字符 “#”。第二个字节的整数值为 105，它对应的字符是 ‘i’，依此类推。注意，每个文本行都是以一个看不见的换行符 ‘\n’ 来结束的，它所对应的整数值为 10。像 hello.c 这样只由 ASCII 字符构成的文件称为**文本文件**，所有其他文件都称为**二进制文件**。

hello.c 的表示方法说明了一个基本思想∶系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串**比特**表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。 作为程序员，我们需要了解数字的机器表示方式，因为它们与实际的整数和实数是不同的。它们是对真值的有限近似值，有时候会有意想不到的行为表现。这方面的基本原理将在第 2 章中详细描述。

> **旁注 编程语言的起源**
>
> C 语言是**贝尔实验室**的 **Dennis Ritchie** 于 **1969 年 ~ 1973 年间创建的。**美国国家标准学会（American National Standards Institute，ANSI）在 1989 年颁布了 ANSI C 的标准，后来 C 语言的标准化成了国际标准化组织（International StandardsOrganization，ISO）的责任。这些标准定义了C语言和一系列函数库，即所谓的 **C 标准库**。Kernighan 和 Ritchie 在他们的经典著作中描述了 ANSI C，这本著作被人们满怀感情地称为 “K&R”【61】。用 Ritchic 的话来说【92】，C 语言是“古怪的、有缺陷的，但同时也是一个巨大的成功”。为什么会成功呢?
>
> - **C 语言与 Unix 操作系统关系密切。**C 从一开始就是作为一种用于 Unix 系统的程序语言开发出来的。大部分 Unix 内核（操作系统的核心部分），以及所有支撑工具和函数库都是用 C 语言编写的。20 世纪 70 年代后期到 80 年代初期，Unix 风行于高等院校，许多人开始接触 C 语言并喜欢上它。因为 Unix 几乎全部是用 C 编写的，它可以很方便地移植到新的机器上，这种特点为 C 和 Unix 赢得了更为广泛的支持。
> - **C 语言小而简单。**C语言的设计是由一个人而非一个协会掌控的，因此这是一个简洁明了、没有什么冗赘的设计。K&R 这本书用大量的例子和练习描述了完整的 C 语言及其标准库，而全书不过  261 页。C 语言的简单使它相对而言易于学习，也易于移植到不同的计算机上。 
> - **C语言是为实践目的设计的。**C 语言是设计用来实现 Unix 操作系统的。后来，其他人发现能够用这门语言无障碍地编写他们想要的程序。
>
> C 语言是系统级编程的首选，同时它也非常适用于应用级程序的编写。然而，它也并非适用于所有的程序员和所有的情况。C 语言的指针是造成程序员困惑和程序错误的一个常见原因。同时，C 语言还缺乏对非常有用的抽象的显式支持，例如类、对象和异常。像 C++ 和 Java 这样针对应用级程序的新程序语言解决了这些问题。

### 1.2 程序被其他程序翻译成不同的格式

hello程序的生命周期是从一个高级C语言程序开始的。然而，为了在系统上运行hello.c程序，每条 C 语句都必须被其他程序转化为一系列的低级**机器语言**指令。然后这些指令按照一种称为**可执行目标程序**的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为**可执行目标文件。**

在 Unix 系统上，从源文件到目标文件的转化是由**编译器驱动程序**完成的∶

```shell
linux> gcc -o hello hello.c
```

程序执行的四个阶段：GCC 编译器驱动程序读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译过程可分为四个阶段完成，如图 1-3 所示。执行这四个阶段的程序（**预处理器**、**编译器**、**汇编器**和**链接器**）一起构成了**编译系统**（compilation system）。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzZfEIY91yIzOD0Rce%2F-MHzZpZI-gs8CNcwHIyv%2F01-03%20compilation%20systems.png?alt=media&token=91ca688e-1cfc-4ec6-8b99-d52e672bbac7" alt="img" style="zoom: 50%;" />

+ **预处理阶段。**预处理器（cpp）根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c 中第 1 行的`#include <stdio.h>`命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。 

+ **编译阶段。**编译器（ccl）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个**汇编语言程序**。该程序包含函数 main 的定义，如下所示∶

```c
main:
    subq $8, %rsp
    movl $.LC0, %edi
    call puts
    movl $0, %eax
    addq $8, %rsp
    ret
```

定义中 2～7 行的每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C编译器和 Fortran 编译器产生的输出文件用的都是一样的汇编语言。

+ **汇编阶段。**接下来，汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做**可重定位目标程序**（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码。如果我们在文本编辑器中打开 hello.o文件，将看到一堆乱码。
+ **链接阶段。**请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器（ld）就负责处理这种合并。结果就得到 hello 文件，它是一个**可执行目标文件**（或者简称为**可执行文件**），可以被加载到内存中，由系统执行。

> 旁注 - GNU项目
>
> GCC 是 GNU（GNU 是GNU's Not Unix 的缩写）项目开发出来的众多有用工具之一。GNU 项目是 1984 年由 Richard Stallman 发起的一个免税的慈善项目。该项目的目标非常宏大，就是开发出一个完整的类 Unix 的系统，其源代码能够不受限制地被修改和传播。GNU 项目已经开发出了一个包含 Unix 操作系统的所有主要部件的环境，但内核除外，内核是由 Linux 项目独立发展而来的。GNU 环境包括 EMACS 编辑器、GCC 编译器、GDB 调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。GCC 编译器已经发展到支持许多不同的语言，能够为许多不同的机器生成代码。支持的语言包括 C、C++、Fortran、Java、Pascal、面向对象 C 语言（Objective-C）和 Ada。
>
> GNU 项目取得了非凡的成绩，但是却常常被忽略。现代开放源码运动（通常和 Linux 联系在一起）的思想起源是 GNU 项目中自由软件（free software）的概念。（此处的free 为自由言论（free speech）中的“自由”之意，而非免费啤酒（free beer）中的“免费”之意。）而且，Linux 如此受欢迎在很大程度上还要归功于 GNU 工具，它们给 Linux 内核提供了环境。

### 1.3 了解编译系统如何工作是大有益处的

对于像 hello.c 这样简单的程序，我们可以依靠编译系统生成正确有效的机器代码。但是，有一些重要的原因促使程序员必须知道编译系统是如何工作的。 

- **优化程序性能。**现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序员，我们无须为了写出高效代码而去了解编译器的内部工作。但是，为了在 C 程序中做出好的编码选择，我们确实需要了解一些机器代码以及编译器将不同的 C 语句转化为机器代码的方式。比如，一个 switch 语句是否总是比一系列的 if-else 语句高效得多？一个函数调用的开销有多大？while 循环比 for 循环更有效吗？指针引用比数组索引更有效吗？为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多呢？为什么我们只是简单地重新排列一下算术表达式中的括号就能让函数运行得更快?？

  在第3章中，我们将介绍 x86-64，最近几代 Linux、Macintosh 和 Windows 计算机的机器语言。我们会讲述编译器是怎样把不同的 C 语言结构翻译成这种机器语言的。在第 5 章中，你将学习如何通过简单转换C语言代码，帮助编译器更好地完成工作，从而调整 C 程序的性能。在第 6 章中，你将学习存储器系统的层次结构特性，C 语言编译器如何将数组存放在内存中，以及 C 程序又是如何能够利用这些知识从而更高效地运行。 

- **理解链接时出现的错误。**根据我们的经验，一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。比如，链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？如果你在不同的 C 文件中定义了名字相同的两个全局变量会发生什么？静态库和动态库的区别是什么？我们在命令行上排列库的顺序有什么影响？最严重的是，为什么有些链接错误直到运行时才会出现？在第 7 章中，你将得到这些问题的答案。 

- **避免安全漏洞。**多年来，缓冲区溢出错误是造成大多数网络和 Internet 服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。作为学习汇编语言的一部分，我们将在第 3 章中描述堆栈原理和缓冲区溢出错误。我们还将学习程序员、编译器和操作系统可以用来降低攻击威胁的方法。

### **1.4 处理器读并解释储存在内存中的指令**

此刻，hello.c 源程序已经被编译系统翻译成了可执行目标文件 hello，并被存放在磁盘上。要想在 Unix 系统上运行该可执行文件，我们将它的文件名输入到称为 shell 的应用程序中∶ 

```shell
linux> ./hello
hello, world
linux> 
```

shell 是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的名字，它将加载并运行这个文件。所以在此例中，shell 将加载并运行 hello 程序，然后等待程序终止。hello 程序在屏幕上输出它的消息，然后终止。shell 随后输出一个提示符，等待下一个输入的命令行。

#### 1.4.1 系统的硬件组成

为了理解运行 hello 程序时发生了什么，我们需要了解一个典型系统的硬件组织，如图 1-4 所示。这张图是近期 Intel 系统产品族的模型，但是所有其他系统也有相同的外观和特性。现在不要担心这张图很复杂——我们将在本书分阶段对其进行详尽的介绍。

##### 1. 总线

贯穿整个系统的是一组电子管道，称作**总线**，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。**字中的字节数（即字长）是一个基本的系统参数**，各个系统中都不尽相同。现在的大多数机器字长要么是 4 个字节（32 位），要么是 8 个字节（64 位）。本书中，我们不对字长做任何固定的假设。相反，我们将在需要明确定义的上下文中具体说明一个“字”是多大。 

##### 2. I/O 设备

I/O（输入/输出）设备是系统与外部世界的联系通道。我们的示例系统包括四个 I/O 设备∶作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器（简单地说就是磁盘）。最开始，**可执行程序 hello 就存放在磁盘上**。

每个 I/O 设备都通过一个**控制器**或**适配器**与 I/O 总线相连。**控制器和适配器之间的区别主要在于它们的封装方式**。**控制器是 I/O 设备本身或者系统的主印制电路板（通常称作主板）上的芯片组**。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在 I/O 总线和 I/O 设备之间传递信息。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzautgnqCcwmhp1v0t%2F-MHzbJTPxV8WF5Cpigw-%2F01-04%20system%20hardwares.png?alt=media&token=78949ed7-8d53-4392-b21d-e6123cd2dc50" alt="img" style="zoom:50%;" />

> 图 1-4 一个典型系统的硬件组成
>
> CPU：中央处理单元；ALU：算术/逻辑单元；PC：程序计数器；USB：通用串行总线

第 6 章会更多地说明磁盘之类的 I/O 设备是如何工作的。在第 10 章中，你将学习如何在应用程序中利用 Unix I/O 接口访问设备。我们将特别关注网络类设备，不过这些技术对于其他设备来说也是通用的。 

##### 3. 主存

**主存**是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组**动态随机存取存储器**（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。与 C 程序变量相对应的数据项的大小是根据类型变化的。比如，在运行 Linux 的 x86-64 机器上，short 类型的数据需要 2 个字节，int 和 float 类型需要 4 个字节，而 long 和 double 类型需要 8 个字节。 第 6 章将具体介绍存储器技术，比如 DRAM 芯片是如何工作的，它们又是如何组合起来构成主存的。 

##### 4. 处理器

**中央处理单元**（CPU），简称**处理器**，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或**寄存器**），称为**程序计数器**（PC）。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。

> PC 也普遍地被用来作为“个人计算机”的缩写。然面，两者之间的区别应该可以很清楚地从上下文中看出来。

从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新 PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。

这样的简单操作并不多，它们围绕着**主存**、**寄存器文件**（register file）和**算术/逻辑单元**（ALU）进行。寄存器文件是一个小的存储设备，**由一些单个字长的寄存器组成，每个寄存器都有唯一的名字**。ALU 计算新的数据和地址值。下面是一些简单操作的例子，CPU 在指令的要求下可能会执行这些操作。

- **加载：**从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。

- **存储：**从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。 

- **操作：**把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。 

- **跳转：**从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖 PC 中原来的值。

处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的**指令集架构**和处理器的**微体系结构**区分开来：**指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。**在第 3 章研究机器代码时，我们考虑的是机器的指令集架构所提供的抽象性。第 4 章将更详细地介绍处理器实际上是如何实现的。第 5 章用一个模型说明现代处理器是如何工作的，从而能预测和优化机器语言程序的性能。

#### 1.4.2 运行 hello 程序

前面简单描述了系统的硬件组成和操作，现在开始介绍当我们运行示例程序时到底发生了些什么。在这里必须省略很多细节，稍后会做补充，但是现在我们将很满意于这种整体上的描述。 初始时，shell 程序执行它的指令，等待我们输人一个命令。当我们在键盘上输人字符串 “./hello” 后，shell 程序将字符逐一读入寄存器，再把它存放到内存中，如图 1-5 所示。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzbjGHhw9P3BFyZTKk%2F-MHzeim3VxH0O0hbd4Uh%2F01-05%20read%20hello%20from%20keyboard.png?alt=media&token=5956c888-1728-418c-8d21-83432d24ce77" alt="img" style="zoom:50%;" />

图 1-5 从键盘上读取 hello 命令

当我们在键盘上敲回车键时，shell 程序就知道我们已经结束了命令的输入。然后 shell 执行一系列指令来加载可执行的 hello 文件，这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串 “hello, world\n”。

利用**直接存储器存取**（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存。这个步骤如图 1-6 所示。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzfLHp5XFUFTsUJAKx%2F-MHzfN_gwQJSG2YnC5Gk%2F01-06%20%E4%BB%8E%E7%A3%81%E7%9B%98%E5%8A%A0%E8%BD%BD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%BB%E5%AD%98.png?alt=media&token=9a49507e-f20d-4af8-b277-bebf57cc597f" alt="img" style="zoom:50%;" />

图 1-6 从磁盘加载可执行文件到主存

一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将 “hello, world\n” 字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。这个步骤如图 1-7 所示。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzfVZwd5iIwJfDkOPj%2F-MHzffvOB90toXVTON5G%2F01-07%20%E5%B0%86%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%8E%E5%AD%98%E5%82%A8%E5%99%A8%E5%86%99%E5%88%B0%E6%98%BE%E7%A4%BA%E5%99%A8.png?alt=media&token=d0480c36-9640-4159-bc71-8f5db262a6ba" alt="img" style="zoom:50%;" />

图 1-7 将输出字符串从存储器写到显示器

### 1.5 高速缓存至关重要

这个简单的示例揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。hello 程序的机器指令最初是存放在磁盘上，当程序加载时，它们被复制到主存；**当处理器运行程序时，指令又从主存复制到处理器**。相似地，数据串 “hello, world\n” 开始时在磁盘上，然后被复制到主存，最后从主存上复制到显示设备。

开销：从程序员的角度来看，**这些复制就是开销，减慢了程序“真正”的工作。因此，系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。**

根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。比如说，一个典型系统上的磁盘驱动器可能比主存大 1000 倍，但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大 1000 万倍。

类似地，**一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节**。然而，**处理器从寄存器文件中读数据比从主存中读取几乎要快 100 倍**。更麻烦的是，随着这些年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。 针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为**高速缓存存储器**（cache memory，简称为 **cache 或高速缓存**），作为暂时的集结区域，存放处理器近期可能会需要的信息。图 1-8 展示了一个典型系统中的高速缓存存储器。位于处理器芯片上的 L1 高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的 L2 高速缓存通过一条特殊的总线连接到处理器。进程访问 L2 高速缓存的时间要比访问 L1 高速缓存的时间长 5 倍，但是这仍然比访问主存的时间快 5~10 倍。L1 和 L2 高速缓存是用一种叫做**静态随机访问存储器**（SRAM）的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存∶L1、L2 和 L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzgjEHwVipe3eiOGOu%2F-MHzhPegzo92o0T7BqNJ%2F01-08%20%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8.png?alt=media&token=c8cb0d2f-bb3c-4a99-8c16-b9db3835a0c4" alt="img" style="zoom:50%;" />

图 1-8 高速缓存存储器

意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。你将在第 6 章里学习这些重要的设备以及如何利用它们。

### 1.6 存储设备形成层次结构

在处理器和一个较大较慢的设备（例如主存）之间插**入**一个更小更快的存储设备（例如高速缓存）的想法已经成为一个普遍的观念。实际上，每个计算机系统中的存储设备都被组织成了一个**存储器层次结构**，如图 1-9 所示。在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第 0 级或记为 L0。这里我们展示的是三层高速缓存 L1 到 L3，占据存储器层次结构的第 1 层到第 3 层。主存在第 4 层，以此类推。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzhX2vrq6mFP3tN9EU%2F-MHzi1Edm9hUsnQdAkkL%2F01-09%20%E4%B8%80%E4%B8%AA%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E7%9A%84%E7%A4%BA%E4%BE%8B.png?alt=media&token=afb8208e-17dc-475f-9f61-acf0bd0ca891" alt="img" style="zoom:50%;" />

图 1-9 一个存储器层次结构的示例

存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是 L1 的高速缓存，L1 是 L2 的高速缓存，L2 是 L3 的高速缓存，L3 是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。 正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。第 6 章将更详细地讨论这个问题。

### **1.7 操作系统管理硬件**

让我们回到 hello 程序的例子。当 shell 加载和运行 hello 程序时，以及 hello 程序输出自己的消息时，shell  和 hello 程序都没有直接访问键盘、显示器、磁盘或者主存。取而代之的是，它们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，如图 1-10 所示。所有应用程序对硬件的操作尝试都必须通过操作系统。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzi6gd3YrHlZtNiGnn%2F-MHziSfWGuHFYHC0c9kb%2F01-10%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E5%B1%82%E8%A7%86%E5%9B%BE.png?alt=media&token=4166d09b-61ba-4d06-a185-2484867737fe" alt="img" style="zoom:50%;" />

图 1-10 计算机系统的分层视图

操作系统有两个基本功能∶（1）防止硬件被失控的应用程序滥用；（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（**进程**、**虚拟内存**和**文件**）来实现这两个功能。如图 1-11 所示，文件是对 I/O 设备的抽象表示，虚拟内存是对主存和磁盘 I/O 设备的抽象表示，进程则是对处理器、主存和 I/O 设备的抽象表示。我们将依次讨论每种抽象表示。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzi6gd3YrHlZtNiGnn%2F-MHzibk5fcFFoAm7QN5W%2F01-11%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%A1%A8%E7%A4%BA.png?alt=media&token=27d4ecf7-428d-43ca-a754-c841c327f065" alt="img" style="zoom:50%;" />

图 1-11 操作系统提供的抽象表示

> 旁注 - Unix、Posix 和标准 Unix 规范
>
> 20 世纪 60 年代是大型、复杂操作系统盛行的年代，比如 IBM 的 OS/360 和 Honey-well 的 Multics 系统。OS/360 是历史上最成功的软件项目之一，而 Multics 虽然持续存在了多年，却从来没有被广泛应用过。贝尔实验室曾经是 Multics 项目的最初参与者，但是因为考虑到该项目的复杂性和缺乏进展而于 1969 年退出。鉴于 Mutics 项目不愉快的经历，一群贝尔实验室的研究人员——Ken Thompson、Dennis Ritchie、Doug Mcllroy 和 Joe Ossanna，从 1969 年开始在 DEC PDP-7 计算机上完全用机器语言编写了一个简单得多的操作系统。这个新系统中的很多思想，比如层次文件系统、作为用户级进程的 shell 概念，都是来自于 Multics，只不过在一个更小、更简单的程序包里实现。1970 年，Brian Kernighan 给新系统命名为 “Unix”，这也是一个双关语，暗指 “Multics” 的复杂性。1973 年用 C 重新编写其内核，1974 年，Unix 开始正式对外发布【93】。
>
> 贝尔实验室以慷慨的条件向学校提供源代码，所以 Unix 在大专院校里获得了很多支持并得以持续发展。最有影响的工作发生在 20 世纪 70 年代晚期到 80 年代早期，在美国加州大学伯克利分校，研究人员在一系列发布版本中增加了虚拟内存和 Internet 协议，称为 Unix 4.xBSD（Berkeley Software Distribution）。与此同时，贝尔实验室也在发布自己的版本，称为 System V Unix。其他厂商的版本，比如 Sun Microsystems 的 Solaris 系统，则是从这些原始的 BSD 和 System V 版本中衍生而来。
>
> 20 世纪 80 年代中期，Unix 厂商试图通过加入新的、往往不兼容的特性来使它们的程序与众不同，麻烦也就随之而来了。为了阻止这种趋势，IEEE（电气和电子工程师协会）开始努力标准化 Unix 的开发，后来由 Richard Stallman 命名为 “Posix”。结果就得到了一系列的标准，称作 Posix 标准。这套标准涵盖了很多方面，比如 Unix 系统调用的 C 语言接口、shell 程序和工具、线程及网络编程。最近，一个被称为“标准 Unix 规范”的独立标准化工作已经与 Posix 一起创建了统一的 Unix 系统标准。这些标准化工作的结果是 Unix 版本之间的差异已经基本消失。

#### 1.7.1 进程

像 hello 这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和 I/O 设备。处理器看上去就像在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。

**进程是操作系统对一个正在运行的程序的一种抽象**。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而**并发运行**，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的 CPU 个数的。传统系统在一个时刻只能执行一个程序，而先进的**多核**处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，**这是通过处理器在进程间切换来实现的**。操作系统实现这种交错执行的机制称为**上下文切换**。为了简化讨论，我们只考虑包含一个 CPU 的**单处理器系统**的情况。我们会在 1.9.2 节中讨论**多处理器系统**。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是**上下文**，包括许多信息，比如 PC 和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。图 1-12 展示了示例 hello 程序运行场景的基本理念。

示例场景中有两个并发的进程∶shell 进程和 hello 进程。最开始，只有 shell 进程在运行，即等待命令行上的输入。当我们让它运行 hello 程序时，shell 通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存 shell 进程的上下文，创建一个新的 hello 进程及其上下文，然后将控制权传给新的 hello 进程。hello 进程终止后，操作系统恢复 shell 进程的上下文，并将控制权传回给它，shell 进程会继续等待下一个命令行输入。

如图 1-12 所示，从一个进程到另一个进程的转换是由操作系统**内核**（kernel）管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的**系统调用**（system call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzietxOnE2XCBTZHJ7%2F-MHziqrI26zhGJA9_NLL%2F01-12%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.png?alt=media&token=5df4420b-e3c7-46ca-8192-ba207aa49f15)

图 1-12 进程的上下文切换

实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。我们将在第 8 章中揭示这项工作的原理，以及应用程序是如何创建和控制它们的进程的。

#### 1.7.2 线程

尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为**线程**的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法，我们将在 1.9.2 节中讨论这个问题。在第 12 章中，你将学习并发的基本概念，包括如何写线程化的程序。

#### 1.7.3 虚拟内存

**虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。**图 1-13 所示的是 Linux 进程的虚拟地址空间（其他 Unix 系统的设计也与此类似）。在 Linux 中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。请注意，图中的地址是从下往上增大的。

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzietxOnE2XCBTZHJ7%2F-MHzj3WC193cZbjm8s4A%2F01-13%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png?alt=media&token=e75f285a-1895-46f5-83fd-e8857326e5f9)

图 1-13 进程的虚拟地址空间

每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。在本书的后续章节你将学到更多有关这些区的知识，但是先简单了解每一个区是非常有益的。我们从最低的地址开始，逐步向上介绍。 

- **程序代码和数据。**对所有的进程来说，代码是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件 hello。在第 7 章我们研究链接和加载时，你会学习更多有关地址空间的内容。
- **堆。**代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 malloc 和 free 这样的 C 标准库函数时，*堆可以在运行时动态地扩展和收缩*。在第 9 章学习管理虚拟内存时，我们将更详细地研究堆。 
- **共享库。**大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。在第 7 章介绍动态链接时，将学习共享库是如何工作的。 
- **栈。**位于用户虚拟地址空间顶部的是**用户栈**，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。**特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩**。在第 3 章中将学习编译器是如何使用栈的。
- **内核虚拟内存。**地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。

虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。第 9 章将解释它如何工作，以及为什么对现代系统的运行如此重要。

#### 1.7.4 文件

**文件**就是**字节序列**，仅此而已。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。**系统中的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的**。

文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的 I/O 设备。例如，处理磁盘文件内容的应用程序员可以非常幸福，因为他们无须了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。你将在第 10 章中学习 Unix I/O。 

> **旁注 - Linux项目**
>
> 1991年8月，芬兰研究生 Linus Torvalds 谨慎地发布了一个新的类 Unix 的操作系统内核，内容如下。
>
> > 来自∶ torvalds@klaava.Helsinki.FI（Linus Benedict Torvalds）
> >
> > 新闻组∶comp.os.minix
> >
> > 主题∶在 minix中你最想看到什么？
> >
> > 摘要∶关于我的新操作系统的小调查
> >
> > 时间∶1991 年 8 月 25 日 20:57:08 GMT 
> >
> > 每个使用 minix 的朋友，你们好。
> >
> > 我正在做一个（免费的）用在 386（486）AT 上的操作系统（只是业余爱好，它不会像 GNU 那样庞大和专业）。这个想法自 4 月份就开始酝酿，现在快要完成了。我希望得到各位对 minix 的任何反馈意见，因为我的操作系统在某些方面与它相类似（其中包括相同的文件系统的物理设计（因为某些实际的原 因））。
> >
> > 我现在已经移植了 bash（1.08）和 gc（1.40），并且看上去能运行。这意味着我需要几个月的时间来让它变得更实用一些，并且，我想要知道大多数人想要什么特性。欢迎任何建议，但是我无法保证我能实现它们。:-)
> >
> > **Linus (torvalds@kruna.helsinki.fi)** 
>
> 就像 Torvalds 所说的，他创建 Linux 的起点是 Minix，由 Andrew S. Tanenbaum 出于教育目的开发的一个操作系统【113】。 接下来，如他们所说，这就成了历史。Linux 逐渐发展成为一个技术和文化现象。通过和 GNU 项目的力量结合，Linux 项目发展成了一个完整的、符合 Posix 标准的 Unix 操作系统的版本，包括内核和所有支撑的基础设施。从手持设备到大型计算机，Linux 在范围如此广泛的计算机上得到了应用。IBM 的一个工作组甚至把 Linux 移植到了一块腕表中！

### **1.8 系统之间利用网络通信**

系统漫游至此，我们一直是把系统视为一个孤立的硬件和软件的集合体。实际上，现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个 I/O 设备，如图 1-14 所示。**当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。**

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzkHZkDb2pAz2UFj6L%2F-MHzkTNuWPTixbySY2Yc%2F01-14%20%E7%BD%91%E7%BB%9C%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8DIO%E8%AE%BE%E5%A4%87.png?alt=media&token=d06f41b1-bb97-42e1-ad6d-35f30948cbc7" alt="img" style="zoom:50%;" />

图 1-14 网络也是一种 I/O 设备

随着 Internet 这样的全球网络的出现，从一台主机复制信息到另外一台主机已经成为计算机系统最重要的用途之一。比如，像电子邮件、即时通信、万维网、FTP 和 telnet 这样的应用都是基于网络复制信息的功能。 回到 hello 示例，我们可以使用熟悉的 telnet 应用在一个远程主机上运行 hello 程序。假设用本地主机上的 telnet 客户端连接远程主机上的 telnet 服务器。在我们登录到远程主机并运行 shell 后，远端的 shell 就在等待接收输入命令。此后在远端运行 hello 程序包括如图 1-15  所示的五个基本步骤。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzkHZkDb2pAz2UFj6L%2F-MHzkrKbCqYNGK5oVdPg%2F01-15%20%E5%88%A9%E7%94%A8telnet%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E8%BF%9C%E7%A8%8B%E8%BF%90%E8%A1%8Chello.png?alt=media&token=686ab00c-5876-4a23-bb52-6760cdc22591" alt="img" style="zoom:50%;" />

图 1-15 利用 telnet 通过网络远程运行 hello

当我们在 telnet 客户端键入 “hello” 字符串并敲下回车键后，客户端软件就会将这个字符串发送到 telnet 的服务器。telnet 服务器从网络上接收到这个字符串后，会把它传递给远端 shell 程序。接下来，远端 shell 运行 hello 程序，并将输出行返回给 telnet 服务器。最后，telnet 服务器通过网络把输出串转发给 telnet 客户端，客户端就将输出串输出到我们的本地终端上。 这种客户端和服务器之间交互的类型在所有的网络应用中是非常典型的。在第 11 章中，你将学会如何构造网络应用程序，并利用这些知识创建一个简单的 Web 服务器。

### **1.9 重要主题**

系统不仅仅只是硬件。系统是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。

#### 1.9.1 Amdahl 定律

Gene Amdahl，计算领域的早期先锋之一，**对提升系统某一部分性能所带来的效果做出了简单却有见地的观察**。这个观察被称为 **Amdahl 定律**（Amdahl's law，阿姆达尔定律）。该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。若系统执行某应用程序需要时间为$T_{old}$假设系统某部分所需执行时间与该时间的比例为$\alpha$，而该部分性能提升比例为$k$ 。即该部分初始所需时间为$aT_{old}$，现在所需时间为$aT_{old}/k$。因此，总的执行时间应为

$T_{new} = (1-\alpha)T_{old}+(\alpha T_{old})/k=T_{old}[(1-\alpha)+\alpha/k]$

由此，可以计算加速比$S=T_{old}/T_{new}$ 为

$S=\frac{1}{(1-\alpha)+\alpha/k} \tag{1.1}$

举个例子，考虑这样一种情况，系统的某个部分初始耗时比例为 60%（α =0.6），其加速比例因子为 3（k=3）。则我们可以获得的加速比为 1/[0.4+0.6/3]=1.67 倍。虽然我们对系统的一个主要部分做出了重大改进，但是获得的系统加速比却明显小于这部分的加速比。这就是 Amdahl 定律的主要观点——要想显著加速整个系统，必须提升全系统中相当大的部分的速度。

> **旁注 - 表示相对性能**
>
> 性能提升最好的表示方法就是用比例的形式 $T_{old}/T_{new}$，其中，$T_{old}$为原始系统所需时间， $T_{new}$为修改后的系统所需时间。如果有所改进，则比值应大于 1。我们用后缀 “×” 来表示比例，因此，“2.2×” 读作 “2.2 倍”。
>
> 表示相对变化更传统的方法是用百分比，这种方法适用于变化小的情况，但其定义是模糊的。应该等于 $100 \cdot (T_{old}-T_{new})/T_{new}$ ，还是 $100 \cdot (T_{old}-T_{new})/T_{old}$，还是其他的值？此外，它对较大的变化也没有太大意义。与简单地说性能提升 2.2× 相比，“性能提升了 120%” 更难理解。 

**练习题1.1**

假设你是个卡车司机，要将土豆从爱达荷州的 Boise 运送到明尼苏达州的 Minneapolis，全程 2500 公里。在限速范围内，你估计平均速度为 100 公里/小时，整个行程需要 25 个小时。

A. 你听到新闻说蒙大拿州刚刚取消了限速，这使得行程中有 1500 公里卡车的速度可以为 150 公里/小时。那么这对整个行程的加速比是多少？

B. 你可以在 www.fasttrucks.com 网站上为自已的卡车买个新的涡轮增压器。网站现货供应各种型号，不过速度越快，价格越高。如果想要让整个行程的加速比为 1.67×，那么你必须以多快的速度通过蒙大拿州？

> 答案：
>
> 该问题说明 Amdahl 定律不仅仅适用于计算机系统。
>
> A. 根据公式 1.1，有 α=0.6，k=1.5。更直接地说，在蒙大拿行驶的 1500 公里需要10个小时，而其他行程也需要 10 个小时。则加速比为 25/(10＋10)=1.25×。
>
> B. 根据公式 1.1，有 α=0.6，要求 S=1.67，则可算出 k。更直接地说，要使行程加速度达到 1.67×，我们必须把全程时间减少到 15 个小时。蒙大拿以外仍要求为 10 小时，因此，通过蒙大拿的时间就为 5 个小时。这就要求行驶速度为 300 公里/小时，对卡车来说这个速度太快了！

**练习题 1.2**

公司的市场部向你的客户承诺，下一个版本的软件性能将改进 2×。这项任务被分配给你。你已经确认只有 80% 的系统能够被改进，那么，这部分需要被改进多少（即 k 取何值）才能达到整体性能目标？ 

> 答案
>
> 理解 Amdahl 定律最好的方法就是解决一些实例。本题要求你从特殊的角度来看公式 1.1。
>
> 本题是公式的简单应用。已知 S=2，α=0.8，则计算 k：
>
> $2=\frac{1}{(1-0.8)+0.8/k}\\$
>
> $0.4+1.6/k=1.0$
>
> $k=2.67$

Amdahl 定律一个有趣的特殊情况是考虑 k 趋向于 ∞ 时的效果。这就意味着，我们可以取系统的某一部分将其加速到一个点，在这个点上，这部分花费的时间可以忽略不计。于是我们得到

$S_{\infty}=\frac{1}{(1-\alpha)} \tag{1.2}$

举个例子，如果 60% 的系统能够加速到不花时间的程度，我们获得的净加速比将仍只有 1/0.4=2.5×。

Amdahl 定律描述了改善任何过程的一般原则。除了可以用在加速计算机系统方面之外，它还可以用在公司试图降低刀片制造成本，或学生想要提高自己的绩点平均值等方面。也许它在计算机世界里是最有意义的，在这里我们常常把性能提升 2 倍或更高的比例因子。这么高的比例因子只有通过优化系统的大部分组件才能获得。

#### 1.9.2 并发和并行

数字计算机的整个历史中，有两个需求是驱动进步的持续动力：一个是我们想要计算机做得更多，另一个是我们想要计算机运行得更快。当处理器能够同时做更多的事情时，这两个因素都会改进。我们用的术语**并发**（concurrency）*是一个通用的概念，指一个同时具有多个活动的系统*；而术语**并行**（parallelism）指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。在此，我们按照系统层次结构中由高到低的顺序重点强调三个层次。

##### 1. 线程级并发

构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了**并发**。**使用线程，我们甚至能够在一个进程中执行多个控制流**。自 20 世纪 60 年代初期出现时间共享以来，计算机系统中就开始有了对并发执行的支持。传统意义上，这种并发执行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的，就好像一个杂耍艺人保持多个球在空中飞舞一样。这种并发形式允许多个用户同时与系统交互，例如，当许多人想要从一个 Web 服务器获取页面时。它还允许一个用户同时从事多个任务，例如，在一个窗口中开启 Web 浏览器，在另一窗口中运行字处理器，同时又播放音乐。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为**单处理器系统**。

当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个**多处理器系统**。其实从 20 世纪 80 年代开始，在大规模的计算中就有了这种系统，但是直到最近，随着多核处理器和**超线程**（hyperthreading）的出现，这种系统才变得常见。图 1-16 给出了这些不同处理器类型的分类。

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzl0fd6lZg8Hh-AE9H%2F-MI-0nKsOs98vF3fwNsm%2F01-16%20%E4%B8%8D%E5%90%8C%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8%E9%85%8D%E7%BD%AE%E5%88%86%E7%B1%BB.png?alt=media&token=1997d8e6-5082-445a-8a28-33113a277bb8)

图 1-16 不同的处理器配置分类。随着多核处理器和超线程的出现，多处理器变得普遍了

多核处理器是将多个 CPU（称为“核”）集成到一个集成电路芯片上。图 1-17 描述的是一个典型多核处理器的组织结构，其中微处理器芯片有 4 个 CPU 核，每个核都有自己的 L1 和 L2 高速缓存，其中的 L1 高速缓存分为两个部分——一个保存最近取到的指令，另一个存放数据。这些核共享更高层次的高速缓存，以及到主存的接口。工业界的专家预言他们能够将几十个、最终会是上百个核做到一个芯片上。

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzl0fd6lZg8Hh-AE9H%2F-MI-7jCviAytfKKxpbQG%2F01-17%20%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png?alt=media&token=268e2b0a-03ce-4e72-92ac-b209f776effe)

图 1-17 多核处理器的组织结构。4 个处理器核集成在一个芯片上

超线程，有时称为**同时多线程**（simultaneous multi-threading），是一项允许一个 CPU 执行多个控制流的技术。它涉及 CPU 某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。常规的处理器需要大约 20000 个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得 CPU 能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那 CPU 就可以继续去执行另一个线程。举例来说，Intel Core i7 处理器可以让每个核执行两个线程，所以一个 4 核的系统实际上可以并行地执行 8 个线程。

多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。正如前面提到的，即使是只有一个用户使用的个人计算机也需要并发地执行多个活动。其次，它可以使应用程序运行得更快，当然，这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。因此，虽然并发原理的形成和研究已经超过 50 年的时间了，但是多核和超线程系统的出现才极大地激发了一种愿望，即找到书写应用程序的方法利用硬件开发线程级并行性。第 12 章会更深入地探讨并发，以及使用并发来提供处理器资源的共享，使程序的执行允许有更多的并行。

##### 2. 指令级并行

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。早期的微处理器，如 1978 年的 Intel 8086，需要多个（通常是 3～10 个）时钟周期来执行一条指令。最近的处理器可以保持每个时钟周期 2～4 条指令的执行速率。其实每条指令从开始到结束需要长得多的时间，大约 20 个或者更多周期，但是处理器使用了非常多的聪明技巧来同时处理多达 100 条指令。在第 4 章中，我们会研究**流水线**（pipelining）的使用。在流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。我们会看到一个相当简单的硬件设计，它能够达到接近于一个时钟周期一条指令的执行速率。

如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为**超标量**（super-scalar）处理器。大多数现代处理器都支持超标量操作。第 5 章中，我们将描述超标量处理器的高级模型。应用程序员可以用这个模型来理解程序的性能。然后，他们就能写出拥有更高程度的指令级并行性的程序代码，因而也运行得更快。

##### 3. 单指令、多数据并行

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。例如，较新几代的 Intel 和 AMD 处理器都具有并行地对 8 对单精度浮点数（C 数据类型 float）做加法的指令。

提供这些 SIMD 指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从 C 程序中自动抽取 SIMD 并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如 GCC 就支持向量数据类型。作为对第 5 章中比较通用的程序优化描述的补充，我们在网络旁注 OPT：SIMD 中描述了这种编程方式。

#### 1.9.3 计算机系统中抽象的重要性

抽象的使用是计算机科学中最为重要的概念之一。例如，为一组函数规定一个简单的应用程序接口（API）就是一个很好的编程习惯，程序员无须了解它内部的工作便可以使用这些代码。不同的编程语言提供不同形式和等级的抽象支持，例如 Java 类的声明和C语言的函数原型。

我们已经介绍了计算机系统中使用的几个抽象，如图 1-18 所示。在处理器里，指令集架构提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上。底层的硬件远比抽象描述的要复杂精细，它并行地执行多条指令，但又总是与那个简单有序的模型保持一致。只要执行模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzl0fd6lZg8Hh-AE9H%2F-MI-82VB6DVGoG3z1MF_%2F01-18%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%BD%E8%B1%A1.png?alt=media&token=7d4d9259-9b84-46f9-a5a2-8f6ff9f0bd68)

> 图 1-18 计算机系统提供的一些抽象。计算机系统中的一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性

在学习操作系统时，我们介绍了三个抽象：文件是对 I/O 设备的抽象，虚拟内存是对程序存储器的抽象，而进程是对一个正在运行的程序的抽象。我们再增加一个新的抽象∶ **虚拟机**，它提供对整个计算机的抽象，包括操作系统、处理器和程序。虚拟机的思想是 IBM 在 20 世纪 60 年代提出来的，但是最近才显示出其管理计算机方式上的优势，因为一些计算机必须能够运行为不同的操作系统（例如，Microsoft Windows、MacOS 和 Linux）或同一操作系统的不同版本设计的程序。

在本书后续的章节中，我们会具体介绍这些抽象。

### **1.10 小结**

计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是 ASCII 文本，然后被编译器和链接器翻译成二进制可执行文件。

处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O 设备和 CPU 寄存器之间复制数据，所以将系统中的存储设备划分成层次结构——CPU 寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化C程序的性能。

操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象∶1）文件是对 I/O 设备的抽象；2）虚拟内存是对主存和磁盘的抽象；3）进程是处理器、主存和 I/O 设备的抽象。

最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种 I/O 设备。

#### 参考文献说明

Ritchie写了关于早期 C 和 Unix 的有趣的第一手资料【91，92】。Ritchie 和 Thompson 提供了最早出版的 Unix 资料【93】，Silberschatz、Galvin 和 Gagne【102】提供了关于 Unix 不同版本的详尽历史。GNU（www.gnu.org）和 Linux（www.linux.org）的网站上有大量的当前信息和历史资料。Posix 标准可以在线获得（www.unix.org）。

## 第 2 章：信息的表示和处理

**位**（bit）：现代计算机存储和处理的信息以二值信号表示。

三种最重要的数字表示：

+ **无符号**（unsigned）编码基于传统的二进制表示法，表示大于或者等于零的数字。
+ **补码** （two's-complement）编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。
+ **浮点数**（floating-point）编码是表示实数的科学记数法的以 2 为基数的版本。计算机用这些不同的表示方法实现算术运算，例如加法和乘法，类似于对应的整数和实数运算。

+ **溢出** （overflow）：计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会溢出。

  溢出会导致某些令人吃惊的后果。例如，在今天的大多数计算机上（使用 32 位来表示数据类型 int），计算表达式 200∗300∗400∗500\small 200*300*400*500200∗300∗400∗500  会得出结果 -884901888。这违背了整数运算的特性，计算一组正数的乘积不应产生一个负的结果。

  另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。例如，利用乘法的结合律和交换律，计算下面任何一个 C 表达式，都会得出结果 -884901888。

> C语言的演变：
>
> 最早开发：贝尔实验室Dennis Ritchie开发，目的是和Unix一起使用。
>
> 缺点：要使用汇编代码。
>
> 演变：1989年，美国国家国家标准学会推出ANSI C标准；90年，国际标准化组织推出"ISO C90"；99年，推出”C99“；2011年，推出”C11“。
>
> CNU编译器套装(GNU Compiler Collection, GCC)可以基于不同命令行选项的不同版本编译C语言。
>
> 根据ISO C11，我们可以用
>
> ```shell
> linux> gcc -std=c11 prog.c
> ```

### 2.1 信息存储

**字节(byte)**：8位的块，作为最小的可寻址内存单位。

**虚拟内存(virtual memory)**：机器级程序将内存视为一个非常大的字节数组。

**地址(address)**：内存每个字节都由一个唯一的数字标识。

**虚拟地址空间(virtual address space)**：所有可能地址的集合。

程序对象（program object）：即程序数据、指令和控制信息。可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。

例如，C 语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象）都是某个存储块的第一个字节的虚拟地址。

C编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管C编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。

#### 2.1.1 十六进制表示法

以16为基数，叫十六进制数(hexadecimal)，来表示位模式。

十六进制(hex)，使用数字0-9以及A-F来表示16个可能的值。一个字节的值域为$00_{16}$~$FF_{16}$。

![image-20220706155852712](深入理解计算机系统.assets/image-20220706155852712.png)

表示：`0x`或者`0X`；数字的末尾$_{16}$。

#### 2.1.2 字数据大小

**字长**：指明指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。对于一个字长我$w$位的机器而言，虚拟地址的范围是$0$~$2^w-1$，程序最多访问$2^w$个字节。

出现了大规模的从 32 位字长机器到 64 位字长机器的迁移。这种情况首先出现在为大型科学和数据库应用设计的高端机器上，之后是台式机和笔记本电脑，最近则出现在智能手机的处理器上。 32 位字长限制虚拟地址空间为4千兆字节（写作 4GB), 也就是说，刚刚 超过$4*10^9$字节。扩展到 64 位字长使得虚拟地址空间为 16EB, 大约是 $4*10^{19}$字节。

>  注：$1KB=1024B=2^{10}B$

大多数 64 位机器也可以运行为 32 位机器编译的程序，这是一种向后兼容。

多数64位机器可以向后兼容32位机器编译的程序。

<img src="深入理解计算机系统.assets/image-20220708172258101.png" alt="image-20220708172258101" style="zoom: 80%;" />

`int32_t`：4个字节

`int64_t`：8个字节

**如何声明指针？**

对于任何数据类型T，声明 T *p;

表明p是一个指针变量，指向一个类型为T的对象。例如，就将一个指针声明为指向一个char类型的对象。

还要注意可移植性。

#### 2.1.3 寻址和字节顺序

**小端法：最低有效字节在最前面的方式**

**大端法：最高有效字节在最前面的方式**

例：

假设变量x的类型为int，位于地址0x100处，它的十六进制值为0x01234567。地址范围0x100~0x103的字节顺序依赖于机器的类型：

![image-20220708182642636](深入理解计算机系统.assets/image-20220708182642636.png)

注意，在字0x01234567中，高位字节的十六进制值为0x01，而低位字节值为0x67。

大多数Intel兼容机都采用小端模式。许多比较新的微处理器是双端法。安卓和IOS都是小端模式。

要注意字节顺序规则转换。

反汇编器生成：4004d3:01 05 43 0b 20 00 add %eax,0x200b43(%rip)

反汇编器：一种确定可执行程序文件所表示的指令序列工具。十六进制字节串 01 05 43 0b 20 00 一条指令的字节级表示，这条指令是把一个字长的数据加到一个值上，该值的存储地址由 0x200b43 加上当前程序计数器的值得到，当前程序计数器的值即为下一条将要执行指令的地址。如果取出这个序列的最后4个字节：43 0b 20 00，并且按照相反的顺序写出，我们得到00 20 0b 43。去掉开头的0，得到值0x200b43，这就是右边的数值。

字节顺序变得重要的第三种情况是当编写规避正常的类型系统的程序时。C语言中，可以通过使用强制类型转换或联合来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。



> typedef的数据类型



>  练习题1：思考下面对show_bytes的三次调用:

```c
int val=0x87654321;
byte_pointer valp=(byte_pointer)&val;
show_bytes(valp,1);
show_bytes(valp,2);
show_bytes(valp,3);
```

结果：

A. 小端法：21        大端法：87

B. 小端法：21 43      大端法：87 65

C. 小端法：21 43 65   大端法：87 65 43

这是基于qemu模拟器的实现

![img](https://img-blog.csdnimg.cn/20190402174023800.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rhbmd1YW5odWFE,size_16,color_FFFFFF,t_70)



> 练习题2.6 使用show_int和show_float，我们确定整数3510593的十六进制表示为0x00359141，而浮点数3510593.0的十六进制表示为0x4A564504。

A. 写出这两个十六进制值的二进制表示。

B. 移动这两个二进制串的相对位置，使得它们匹配的位数最多。有多少位相匹配呢？

C. 串中的什么部分不相匹配？

解：

A.   0x00359141       0000 0000 0011 0101 1001 0001 0100 0001

       0x4A56504        0100 1010 0101 0110 0100 0101 0000 0100

B.  0000 0000 0011 0101 1001 0001 0100 0001

        0100 1010 0  1 0101 1001 0001 0100 0001  00

共有21位相匹配

C.  我们发现除了最高有效位1，整数的所有位都嵌在浮点数中。这正好也是书中示例的情况。另外，浮点数有一些非零的高位不与整数中的高位相匹配

#### 2.1.4 表示字符串

C语言中字符串被编码为一个以null字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符码。因此，如果我们以参数“12345”和6来运行例程show_bytes，我们得到结果31 32 33 34 35 00。

> 练习题2.7 下面对show_bytes的调用将输出什么结果？
>
> ```C++
> const char *s = "abcdef";
> show_bytes((byte_pointer) s, strlens(s));
> 
> >>>
> 注意字母 ‘a' ~ 'z' 的ASCII码为0x61~0x7A
> 
> 解：输出 61 62 63 64 65 66（库函数strlen不计算终止的空白符，所以show_bytes只打印到字符 ’f' ）
> ```

#### 2.1.5 表示代码

```c
int sum(int x, int y){
    return x+y;
}
```

![image-20220708195915068](深入理解计算机系统.assets/image-20220708195915068.png)

指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容。二进制代码很少能在不同机器和操作系统组合之间移植。

计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。

#### 2.1.6 布尔代数简介

二进制值是计算机编码、存储和操作信息的核心。

布尔注意到通过将逻辑值TRUE和FALSE编码为二进制值1和0，能够设计出一种代数，以研究逻辑推理的基本原则。

最简单的布尔代数是在二元集合{0,1}基础上的定义。

<img src="深入理解计算机系统.assets/image-20220708201105671.png" alt="image-20220708201105671" style="zoom: 67%;" />

#### 2.1.7 C语言中的位级运算

几种位级运算：OR 或 |；AND 与 &；NOT ~ 取反；EXCLUSIVE-OR 异或

![image-20220710105650489](深入理解计算机系统.assets/image-20220710105650489.png)

异或：其运算法则为：a⊕b = (¬a ∧ b) ∨ (a ∧¬b)如果a、b两个值不相同，则*异或*结果为1。如果a、b两个值相同，*异或*结果为0

**练习题2.10**

假设x和y指向的位置分别是a和b。完成下表：

| 步骤   | *x      | *y            |
| ------ | ------- | ------------- |
| 初始   | a       | b             |
| 第一步 | a       | a^b           |
| 第二步 | a^(a^b) | a^b           |
| 第三步 | a^(a^b) | a^(a^b)^(a^b) |

 由于异或运算满足交换率和结合率，且a ^ 0 = 0， a ^  = ~a。所以有 

| 步骤   | *x   | *y   |
| ------ | ---- | ---- |
| 初始   | a    | b    |
| 第一步 | a    | a^b  |
| 第二步 | b    | a^b  |
| 第三步 | b    | a    |



**练习题2.11**

A：最后一次循环时，两个变量值相同。奇数数组长度为2k+1，则变量值为中间的元素值array[k]。

B：当调用inplace_swap函数时，实际上两个参数指向同一个位置。*x=*y。由于a^a=0，第一步运算后，*y=0=*x。后两步再运算，值全是0。最终array[k]=0。

C：将for循环中的条件first <= last，改为first < last 即可。不让两个相同元素交换，即可保证代码逻辑正确。

位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。

例子：掩码 0xFF( 最低的 位为 1) 表示一个字的低位字节。位级运算 x&0xFF 生成一个由的最低有效字节组成的值，而其他的字节就被置为0。比如，对于 x= 0x89ABCDEF, 其表达式将得到0x000000EF。

**练习题2.12**

由于已经给出限定条件字长w>=8，所以基本的最低有效字节最小应该为0xFF。
1）任何位与(&)1都会得到它本身，任何位与(&)0都会得到0。所以得到 x & 0xFF。
2）任何位异或(^)0都会得到它本身，而异或(^)1则会得到它的非(~)，即它的补。需要取取补的位对应就全置为1，
需要不变的位对应就全置为0，然后在与之异或。所以得到 x ^ ~0xFF。
3）任何位或(|)1都会得到1，或(|)0都会得到它本身。所以得到 x | 0xFF 。

**练习题2.13**

```c++
int bis(int x, int m);
int bic(int x, int m);

int bool_or(int x, int y)
{
    int result = bis(x, y);
    return result;
}

int bool_xor(int x, int y)
{
    int result = bis(bic(x, y), bic(y, x));
    return result;
}
```

#### 2.1.8 C语言中的逻辑运算

C语言中有||、&&、！等逻辑运算符。

![image-20220715135803489](深入理解计算机系统.assets/image-20220715135803489.png)

逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE。它们返回1或者0。可以观察到，按位运算只有在特殊情况下，也就是参数被限制为0或者1时，才和与其对应的逻辑运算有相同的行为。

逻辑运算符&&和||与它们对应的位级运算&和|之间第二个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。因此，例如，表达式a&&5/a将不会造成被零除，而表达式p&&*p++t也不会导致间接引用空指针。

**练习题2.14**

假设x和y的字节值分别为0x66和0x39。填写下表，指明各个C表达式的字节值。

0x66 = 0110 0110(B)

0x39 = 0011 1001(B)

| 表达式     | 值   |
| ---------- | ---- |
| x & y      | 0x20 |
| x \| y     | 0x7F |
| ~x \| ~y   | 0xDF |
| x & !y     | 0x00 |
| x && y     | 0x01 |
| x \|\| y   | 0x01 |
| !x \|\| !y | 0x00 |
| x && ~y    | 0x01 |

**练习题2.15**

只使用位级运算和逻辑运算，编写一个C表达式，它等价于x==y。换句话说，当x和y相等时它将返回1，否则就返回0。

```
 !(x^y)
 当且仅当x的每一位和y相应的每一位匹配时, x ^ y 等于0,然后利用!来判定一个字是否包含任何非零位.
```

#### 2.1.9 C语言中的移位运算

移位运算：向左或向右移动位模式。

对于一个位表示为$[x_{w-1},x_{w-2},...,x_{0}]$的操作数$x$。

左移：$x<<k$，$[x_{w-k-1},x_{w-k-2},...,x_{0},0,...,0]$，向左移动k位，丢弃最高的k位，并在右端补$k$个0。移位量应该是一个$0$~$w-1$之间的值。移位运算是从左至右可结合的，所以$x<<j<<k$等价于$(x<<j)<<k$。

右移：$x>>k$。右移分为逻辑右移和算术右移。

+ 逻辑右移，左端补$k$个0，得到的结果是$[0,...,0,x_{w-1},x_{w-2},...,x_{k}]$；
+ 算术右移是左端补$k$个最高有效位的值$[x_{w-1},...,x_{w-1},x_{w-1},x_{w-2},...,x_{k}]$。

例：

|       操作       |          值           |
| :--------------: | :-------------------: |
|     参数$x$      | [01100011] [10010101] |
|      $x<<4$      | [00110000] [01010000] |
| $x>>4(逻辑右移)$ | [00000110] [00001001] |
| $x>>4(算术右移)$ | [00000110] [11111001] |

无符号数，必须是逻辑右移；几乎所有的编译器/及其组合都对有符号数使用算术右移。

Java会有明确定义。$x>>k$是算术右移，$x>>>k$会对$x$做逻辑右移。

> 旁注1：移动$k$位，这里$k$很大
> 

旁注2：



**练习题2.16**

填写下表，说明不同移位运算对单字节数的影响。

| x        |           | x<<3      |          | x>>2(逻辑) |          | x>>2(算术) |          |
| -------- | --------- | --------- | -------- | ---------- | -------- | ---------- | -------- |
| 十六进制 | 二进制    | 二进制    | 十六进制 | 二进制     | 十六进制 | 二进制     | 十六进制 |
| 0xC3     | 1100 0011 | 0001 1000 | 0x18     | 0011 0000  | 0x30     | 1111 0000  | 0xF0     |
| 0x75     | 0111 0101 | 1010 1000 | 0xA8     | 0001 1101  | 0x1D     | 0001 1101  | 0x1D     |
| 0x87     | 1000 0111 | 0011 1000 | 0x38     | 0010 0001  | 0x21     | 1110 0001  | 0xE1     |
| 0x66     | 0110 0110 | 0011 0000 | 0x30     | 0001 1001  | 0x19     | 0001 1001  | 0x19     |

### 2.2 整数表示

引入数学术语，用于精确定义和描述计算机如何编码和操作整数。

+ 非负数
+ 负数、零和整数



**复习：原码、反码、补码**

原码 ：最高位是符号位，0代表正数，1代表负数，非符号位为该数字绝对值的二进制。

反码：正数的反码与原码一致，负数的反码是对原码按位取反，只是最高位（符号位）不变。 

补码：正数的补码与原码一致，负数的补码是对原码按位取反加1，符号位不变。

例如十进制数字：5

> $5=2^2+2^0$  
>
> 5的二进制表示是101。  
>
> 至少要三位数字，如果加上符号位，就是4位数字。
>
> 原码：0101       
>
> 反码：0101
>
> 补码：0101

例如十进制数字：-5

> $5=2^2 + 2^0$     
>
> 5的二进制表示是101。
>
> 至少要三位数字，加上符号位，就是4位数字。
>
> 原码：**1**101
>
> 反码：1010
>
> 补码：1011
>

例如 将补码1011  转换为原码

> 补码：1011
>
> 符号位不变，数值位取反：1100
>
> 加1后得到原码：1101
>
> 补码变成原码的方式是：正数的补码与原码一致，负数的补码按位取反加1，符号位不变
>
> 反码变成原码的方式是：正数的反码与原码一致，负数的补码转换为源码后位取反，符号位不变

**用4位二进制原码表示0：-0=1000  +0=0000** 

**用4位二进制反码表示0：-0=1111  +0=0000** 

**用4位二进制补码表示0：-0=0000  +0=0000** 

**n+1位数字，绝对值最大的原码是  -(2^n - 1)和 2^n - 1**

**n+1位数字，绝对值最大的反码是  -(2^n - 1) 和 2^n - 1**

**n+1位数字，绝对值最大的补码是 −2^n ≤x ≤2^n−1**



```
1、正数的反码和补码都与原码相同。 
2、而负数的反码为对该数的原码除符号位外各位取反。 
3、负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1

1、原码表示法规定：用符号位和数值表示带符号数，正数的符号位用“0”表示，负数的符号位用“1”表示，数值部分用  二进制形式表示。 
2、反码表示法规定：正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反。 
3、补码表示法规定：正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1. 
4、正零和负零的补码相同，[+0]补=[-0]补=0000 0000B。

计算机中数值都是以补码的形式存储
======================================================================================
    真值             原码       ||       反码               补码              表示的数值
======================================================================================
    0             0000_0000   |                       0000_0000                  0
    1             0000_0001   |                       0000_0001                  1
   ...               ....     |                         ....
   ...               ....     |                         ....
   ...               ....     |                         ....
   ...               ....     |                         ....
   ...               ....     |                         ....
   127            0111_1111   |                       0111_1111                 127
=====================================================================================
   -0             1000_0000   |    1111_1111          1_0000_0000              -128  
   -1             1000_0001   |    1111_1110           1111_1111               -127
   -2             1000_0010   |    1111_1101           1111_1110               -126
  ...                ....     |
  ...                ....     |
  ...                ....     |
  -127            1111_1111   |    1000_0000           1000_0001                 -1
===================================================================================== 
  
=====================================================================================
    符号位         数值位
   1(负数)           7位 
   0(正数)           7位

   特殊：10000000  ：-0表示-128
   上述的-0位特殊情况，规定它在计算机中的表示的数为-128；
   -0:10000000按位取反再加1后为1_0000_0000超出了8位，把这个值规定为8位表示的-128；
   因此8位二进制数可表示的有符号数为0-255；可表示的无符号数为-128-0-127
=====================================================================================
在这里要说到一个概念 模，“模”是指一个计量系统的计数范围。如时钟等。 

时钟的计量范围是0～11，模=12。表示n位的二进制数计量范围是0～2(n)-1，模=2(n)，八位二进制数的模为2^8 。

任何有模的计量器，均可化减法为加法运算（这就是计算机二进制运算的原理）。假设当前时针指向10点，而准确时间是6点，调整时间可有以下两种拨法：一种是倒拨4小时，即：10-4=6；另一种是顺拨8小时：10+8=12+6=6 。在以12模的系统中，加8和减4效果是一样的，因此凡是减4运算，都可以用加8来代替。对“模”而言，8和4互为补数。实际上以12模的系统中，11和1，10和2，9和3，7和5，6和6都有这个特性。共同的特点是两者相加等于模。对于计算机，其概念和方法完全一样。n位计算机，设n=8， 所能表示的最大数是11111111，若再加1成为100000000(9位），但因只有8位，最高位1自然丢失。又回了00000000，所以8位二进制系统的模为2^8。在这样的系统中减法问题也可以化成加法问题，只需把减数用相应的补数表示就可以了，把补数用到计算机对数的处理上，就是补码。对一个正数的原码取反加一，得到这个正数对应负数的补码。例如~6=-7，而且加一之后会多出一个八进制补码1000 0000，而这个补码就对应着原码1000 0000，数字位同时当做符号位即-128 。所以根据以上我们可以理解为什么八位二进制数表示范围为-128~+127。八位二进制正数的补码范围是0000 0000 ~ 0111 1111 即0 ~ 127,负数的补码范围是正数的原码0000 0000 ~ 0111 1111 取反加一（也可以理解为负数1000 0000 ~ 1111 1111化为反码末尾再加一）。  所以得到 1 0000 0000 ~ 1000 0001,1000 0001作为补码，其原码是1111 1111（-127），依次往前推，可得到-1的补码为1111 1111，那么补码0000 0000的原码是1000 0000符号位同时也可以看做数字位即表示-128，这也解释了为什么127（0111 1111）+1（0000 0001）=-128（1000 0000）。
```



#### 2.2.1 整型数据类型

C语言支持多种整型数据类型——表示有限范围的整数。其中还给出了”典型”32 位和 64 位机器的取值范围。每种类型都能用关键字来指定大小，这些关键字包括char、short、long, 同时还可以指示被表示的数字是非负数 （声明为unsigned), 或者可能是负数（默认）。如图 2-3 所示，为这些不同的大小分配的字节数根据程序编译为32位还是64位而有所不同。根据字节分配，不同的大小所能表示 的值的范围是不同的 这里给出来的唯一一个与机器相关的取值范围是大小指示符 long 的。大多数 64 位机器使用8个字节的表示，比 32 位机器上使用的4个字节的表示的取值范围大很多。

char是1个字节，short是2个字节，int是4个字节，long在32位是4个字节，64位是8个字节。

> 在编程语言中，常见的数据类型包括原始类型（如：[整数](https://zh.wikipedia.org/wiki/整數)、[浮点数](https://zh.wikipedia.org/wiki/浮點數)或[字符](https://zh.wikipedia.org/wiki/字元)）、[多元组](https://zh.wikipedia.org/wiki/多元组)、记录单元、[代数数据类型](https://zh.wikipedia.org/w/index.php?title=代數資料類型&action=edit&redlink=1)、[抽象数据类型](https://zh.wikipedia.org/wiki/抽象資料類型)、[参考类型](https://zh.wikipedia.org/w/index.php?title=參考_(電腦科學)&action=edit&redlink=1)、[类](https://zh.wikipedia.org/wiki/类_(计算机科学))以及[函数类型](https://zh.wikipedia.org/w/index.php?title=函式物件&action=edit&redlink=1)。数据类型描述了[数值](https://zh.wikipedia.org/wiki/数值)的表示法、解释和结构，并以[算法](https://zh.wikipedia.org/wiki/演算法)操作，或是[对象](https://zh.wikipedia.org/wiki/物件_(電腦科學))在存储器中的存储区，或者其它存储设备。

![img](https://img-blog.csdn.net/20130913163641750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2t5X3Fpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

int_t 为一个结构的标注，可以理解为type/typedef的缩写，表示它是通过typedef定义的，而不是一种新的数据类型。因为跨平台，不同的平台会有不同的字长，所以利用预编译和typedef可以最有效的维护代码。

 int8_t      : typedef signed char; 1B
 uint8_t    : typedef unsigned char; 1B
 int16_t    : typedef signed short ; 2B
 uint16_t  : typedef unsigned short ; 2B
 int32_t    : typedef signed int; 4B
 uint32_t  : typedef unsigned int; 4B
 int64_t    : typedef signed  long long; 8B
 uint64_t  : typedef unsigned long long; 8B

![image-20220716190622922](深入理解计算机系统.assets/image-20220716190622922.png)

![image-20220716190635837](深入理解计算机系统.assets/image-20220716190635837.png)

为什么取值范围不对称？

![image-20220722160508531](深入理解计算机系统.assets/image-20220722160508531.png)

> C和C++都支持有符号和无符号数。Java只支持有符号数。

#### 2.2.2 无符号数的编码

假设有一个整数数据类型有$w$位。我们可以将位向量写成立$\vec x$表示整个向量，或者写成$[x_{w-1},x_{w-2},...,x_{0}]$，表示向量中的每一位。把$\vec x$看做一个二进制的数，就获得了$\vec x$的无符号表示。在这个编码中，我们用一个函数$B2U_w$ (Binary to Unsigned) 的缩写，长度为$w$来表示：

原理：无符号数编码的定义，对向量$\vec x=[x_{w-1},x_{w-2},...,x_0]:$
$$
B2U_w(\vec x)≐\sum_{i=0}^{w-1}x_i2^i
$$
≐：左边等于右边。





#### 2.2.3 补码编码

补码(two's-complement)。我们用函数$B2T_w$表示。

+ 字的最高有效位解释为负权(negative weight)。

![image-20220716195955828](深入理解计算机系统.assets/image-20220716195955828.png)

![image-20220716200112803](深入理解计算机系统.assets/image-20220716200112803.png)

![image-20220716200154323](深入理解计算机系统.assets/image-20220716200154323.png)

假设w=4，我们能给每个可能的十六进制数字赋予一个数值，假设用一个无符号或者补码表示。完成下表：

| x        |        | 无符号(B2U(x)) | 补码(B2T(x)) |
| -------- | ------ | -------------- | ------------ |
| 十六进制 | 二进制 |                |              |
| 0xE      | 1110   | 14             | -2           |
| 0x0      | 0000   | 0              | 0            |
| 0x5      | 0101   | 5              | 5            |
| 0x8      | 1000   | 8              | -8           |
| 0xD      | 1101   | 13             | -3           |
| 0xF      | 1111   | 15             | -1           |

补码的范围不对称。

![image-20220716201323427](深入理解计算机系统.assets/image-20220716201323427.png)

补码范围是不对称的，根据定义。$|TMin|=|TMax|+1$，$TMin$没有与之对应的正数。所以会容易造成细微的错误。原因是一半的位模式表示负数，另一半表示非负数。第二，最大的无符号数值刚好比补码的最大值两倍大1,即$UMax_w=2TMax_w+1$，补码表示中所有表示负数的位模式在无符号表示中都变成了正数。

> 关于确定大小的整数类型的更多内容
>
> 对于某些程序来说，用某个确定大小的表示来编码数据类型非常重要。例如，当编写程序，使得机器能够按照一个标准协议在因特网上通信时，让数据类型与协议指定的数据类型兼容是非常重要的。我们前面看到了，某些C数据类型，特别是long型，在不同的机器上有不同的取值范围，而实际上C语言标准只指定了每种数据类型的最小范围，而不是确定的范围。虽然我们可以选择与大多数机器上的标准表示兼容的数据类型，但是这也不能保证可移植性。
>
> 我们已经见过了32位和64位版本的确定大小的整数类型(图2-3)，它们是一个更大数据类型类的一部分。ISO C99标准在文件stdint.h中引入了这个整数类型类。这个文件定义了一组数据类型，它们的声明形如 intN_t和uintN_t，对不同的N值指定N位有符号和无符号整数。N的具体值与实现相关，但是大多数编译器允许的值为8、16、32和64。因此，通过将它的类型声明为uint16_t，我们可以无歧义地声明一个16位无符号变量，而如果声明为int32_t，就是一个32位有符号变量。
>
> E这些数据类型对应着一组宏，定义了每个N的值对应的最小和最大值。这些宏名字形如`INTN_MIN`、`INTN_MAX`和`UINTN_MAX`。
>
> 确定宽度类型的带格式打印需要使用宏，以与系统相关的方式扩展为格式串。因此，举个例子来说，变量x和y的类型是int32_t和uint64_t，可以通过调用printf来打印它们的值，如下所示:`printf ("x = %"PRId32 "，y = %PRIu64 "\n"，x，y);`
>
> 编译为64位程序时，宏PRId32展开成字符串“d”，宏PRIu64则展开成两个字符串“1”“”。当C预处理器遇到仅用空格(或其他空白字符)分隔的一个字符串常量序列时，就把它们串联起来。因此，上面的printf调用就变成了:`printf("x = %d, y = %luln"，x, y);`
>
> 使用宏能保证:不论代码是如何被编译的，都能生成正确的格式字符串。

Java中，采用补码表示。

![image-20220722163413398](深入理解计算机系统.assets/image-20220722163413398.png)

将32位补码表示的数转换为10进制数。

| 32位补码   | 十进制 |
| ---------- | ------ |
| 0x1b8      | 440    |
| 0x14       | 20     |
| 0xFFFFFE58 | -424   |
| 0xFFFFFE74 | -396   |
| 0x44       | 68     |
| 0xFFFFFEC8 | -312   |
| 0x10       | 16     |
| 0xC        | 12     |
| 0xFFFFFEEC | -276   |
| 0x20       | 32     |

#### 2.2.4 有符号数和无符号数之间的转换

C语言允许在不同的数字数据类型之间做强制类型转换。
![[image-20220718192852587.png]]

-12345的16位补码跟53191的16位无符号数是完全一样的。

```c
short int v=-12345;
unsigned short uv =(unsigned short) v;
printf("v=%d,uv=%u\n",v,uv);
```

强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。

![image-20220722171645899](深入理解计算机系统.assets/image-20220722171645899.png)
![[image-20220718210952925.png]]

![image-20220722182844747](深入理解计算机系统.assets/image-20220722182844747.png)

#### 2.2.5 C语言中的有符号数与无符号数

创建无符号常量，加上后缀字符`u`或者`U`。

C语言允许无符号数和有符号数之间的转换。

例子：显示的强制类型转换

```c
int tx, ty;
unsigned ux, uy;
tx=(int)ux;
uy=(unsigned)ty;
```

隐式的转换：

```c
int tx, ty;
unsigned ux, uy;
tx=ux; /*Cast to signed*/
uy=ty; /*Cast to unsigned*/
```

当使用`printf`输出数值时，以`%d`，`%u`，`%x`以有符号十进制、无符号十进制和十六进制格式输出一个数字。也可以用`%u`输出类型为`int`的值，`%d`输出类型为`unsigned`的数值。

例：

```c
int x=-1;
unsigned u=2147483648;
printf("x=%u=%d\n",x,x);
printf("u=%u=%d\n",u,u);
```

当在一个 32 位机器上运行时，它的输出如下：

```c
x=4294967295=-1
u=2147483648=-2147483648
```

在这两种情况下， `printf`首先将这个字当作一个无符号数输出，然后把它当作一个有符号数输出。$T2U_{32}(-1)=UMax_{32}=2^{32}-1$和$U2T_{32}(2^{31})=$$-2^{31}$=$TMin_{32}$。

由于C语言对同时包含有符号和无符号数表达式的这种处理方式，出现了一些奇特的行为。当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数。

![image-20220723154401548](深入理解计算机系统.assets/image-20220723154401548.png)

**练习2.21**

![img](https://pic2.zhimg.com/80/v2-03c799522aa4519af8724e58b046a245_720w.jpg)

> C语言中TMin的写法
>
> 在图2-19和练习题2.21中，我们很小心地将TMin32 写成-2147483647-1。为什么不简单地写成-2147483648或者0x80000000?看一下C头文件limits.h,注意到它们使用了跟我们写$TMin_{32}$和$TMax_{32}$类似的方法:
>
> ```c
> /* Minimum and maximum values a‘ signed int' can hold. */
> #define INT MAX 2147483647
> #define INT_MIN (-INT_MAX - 1) 
> ```
>
> 补码的不对称性和C语言的转换规则之间奇怪的交互，迫使我们用这种不寻常的方式写$TMin_{32}$。

#### 2.2.6 扩展一个数字的位来表示

将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加0。这种运算被称为**零扩展**。

![image-20220725182717927](深入理解计算机系统.assets/image-20220725182717927.png)

例代码：

```c
short sx = - 12345;/* -12345 */
unsigned short usx = sx;/* 53191 */
int x = sx;/* -12345 */
unsigned ux = usx;/* 53191 */
printf("sx = %d:\t",sx) ;
show_ bytes ( (byte. pointer) &sX， sizeof (short)) ;
printf ("usx = %u:\t",usx) ;
show_ bytes ( (byte. _pointer) &usx， sizeof (unsigned short));
printf ("x = %d:\t",x);
show_ bytes ((byte. pointer) &x， sizeof (int)) ;
printf("ux = %u:\t",ux);
show_ bytes((byte_ pointer) &ux， sizeof (unsigned));

>>>
sx = -12345: cf c7 
usx = 53191: cf c7 
X = -12345: ff ff cf c7 
ux = 53191: 00 00 cf c7 
```

我们看到，尽管一12345的补码表示和53191的无符号表示在16位字长时是相同的，但是在32位字长时却是不同的。特别地，一12 345的十六进制表示为0xEFFFCFC7，而53191的十六进制表示为0x0000CFC7。前者使用的是符号扩展一最开头加了16位，都是最高有效位1,表示为十六进制就是0xFFFF。后者开头使用16个0来扩展，表示为十六进制就是0x0000。

字节从$w$=3拓展到$w$=4的符号拓展结果。位向量[101]表示值-4+1=-3。符号拓展，得到[1101]，表示的值-8+4+1=-3。我们可以看到，对于$w$=4，最高两位的组合值是-8+4=-4，与$w$=3时符号位的值相同。类似地，位向量[111]和[1111]都表示值-1。


![[image-20220725201205395.png]]
展示保持补码值的符号扩展。

![image-20220725201516140](深入理解计算机系统.assets/image-20220725201516140.png)

**练习题2.22**
A.[1011]：-5的原码是1101，反码是1010，补码是1011

B.[11011]：-5的原码是11101，反码是11010，补码是11011

C.[111011]：-5的原码是111101，反码是111010，补码是111011

**数据大小位数的转换，以及无符号和有符号数字之间的相互转换能够影响一个程序的行为。**

```C
short sx=-12345;
unsigned uy=sx;
printf("uy=%u:\t",uy);
show_bytes((byte_pointer) &uy,sizeof(unsigned));
```
```
uy=42949549591: ff ff cf c7
```

这表明当把`short`转换成`unsigned`时，我们先要改变大小，之后再完成从有符号到无符号的转换。也就是说`(unsigned) sx`等价于`(unsigned)(int) sx`，求值得到4 294954 951，而不等价于`(unsigned)(unsigned short)sx`，后者求值得到53191。事实上,这个规则是C语言标准要求的。

**练习题2.23**
考虑下面 2 个 C 函数：
```C
int fun1(unsigned word)
{
    return (int) ((word << 24) >> 24);
}

int fun2(unsigned word)
{
    return ((int) word << 24) >> 24);
}
```

假设在采用补码的 32 位机上运行，且有符号数是算术右移，无符号数是逻辑右移。填写下表。
![[Pasted image 20220807113734.png]]
fun1 中是在无符号数上右移地，是逻辑右移，fun2 中 word 先被转换成了有符号数 int，故是算术右移。

B. 函数 fun1 完成提取 word 的低 8 位的功能。fun2 完成提取后，还进行符号扩展。

#### 2. 2. 7 截断数字
减少表示一个数字的位数，例如下面的代码：
```C
int x=53191;
short sx=(short)x;
int y=sx;
```
强制转换为short时，32位的int被截断为了16位的short int。16位的位模式是-12345的补码表示。强制类型转换回int时，符号扩展把高16位设置为1，从而生成-12345的32位补码表示。

当将一个w位的数$\vec x=[x_{w-1},x_{w-2},...,x_0]$截断为一个k位数字时，我们会丢弃高$w一k$位，得到一个位向量$\vec x=[x_{k-1},x_{k-2},...,x_0]$。截断一个数字可能会改变它的值——溢出的一种形式。对于一个无符号数，我们可以很容易得出其数值结果。

>原理：截断无符号数
>
>令$\vec x$等于位向量$[x_{w-1},x_{w-2},...,x_0]$，而$\vec x'$是将其截断为k位的结果：$\vec x'=[x_{k-1},x_{k-2},...,x_0]$。令$x=B2U_w(\vec x)$，$x'=B2U_w(\vec x')$。则$x'=x$ $mod$ $2^k$。

> 推导：截断无符号数 
>![[Pasted image 20220807130546.png]]

>原理：截断补码数值
>![[Pasted image 20220807131132.png]]

> 推导：截断补码数值
>![[Pasted image 20220807131159.png]]

1.  无符号数的截断直接截去高位多余的位，例如截断到 k 位，相当于进行了 mod $2^k$ 操作。
2.  有符号数的截断也是直接截去高位多余的位，但是数值要进行补码数值的解析。

**练习题 2.24 p93**

假设将一个 4 位的数(0~F) 截断到 3 位数据(0~7)。填写下表。
![[Pasted image 20220807163354.png]]

#### 2.2.8 关于有符号数与无符号数的建议

可能会造成某些非直观的行为：隐式强制类型转换的细微差别错误’无符号数据类型造成的细微的错误。

**练习题2.25**

下列代码试图计算数组 a 中所有元的各，当参数 length 等于 0 时，运行这段代码应该返回 0.0，但实际上会遇到内存错误。为什么？改进？

```C
/* WARNING: This is buggy code */
float sum_elements(float a[], unsigned length)
{
    int i;
    float result = 0;
    
    for (i=0; i <= length -1; i++)
        result += a[i];
    return result;
}
```

由于 length 是无符号数， 故 length -1 在当 length 为 0 时将不是 -1 ，而是 UMax，故会遇到内存出错。

改进：将 length 声明改为 int 即可。或者判断改为 `i<length`。

**练习题 2.26 **

要写一个函数用来判定一个字符串是否比另一个更长。前提是要用字符串库函数 `strlen`，它的声明为： `size_t strlen(const char *s);`，最开始你写的函数是这样的：

```C
/* Determine whether string s is longer than string t */
/* WARNING: This function is buggy */
int strlonger(char *s, char *t) {
    return strlen(s) - strlen(t) > 0;
}
```

当进行一些测试时，似乎一切正确。进一步研究发现在头文件 stdio.h 中数据类型 size_t 是定义成 unsigned int 的。

A. 在当 s 的长度小于 t 的长度时，结果会不正确。

B. 这是因为，在 A 情况下，负数会隐式转成了正数。

C. 修改： 改为 `return strlen(s) > strlen(t);`

> 函数`getpeername`的安全漏洞
> 
> 程序会遇到进程中非法地址的错误，但是程序还是能读到它没有被授权的内核内存区域。此问题是由于数据类型不匹配造成的。在一个地方，长度参数是有符号数；而另一个地方是无符号数。我们可以看到，这个问题是由于数据类型的不匹配造成的：在一个地方，长度参数是有符号数；而另一个地方，它又是无符号数正如这个例子表明的那样，这样的不匹配会成为缺陷的原因，甚至会导致安全漏洞幸运的是，还没有案例报告有程序员在FreeBSD上利用了这个漏洞他们发布了一个安全建议， "FreeBSD-SA-02: 38. signed-error", 建议系统管理员如何应用补丁消除这个漏d要修正这个缺陷，只要将 copy_from_kernel 的参数 maxlen 声明为类型 size_t,也就是与memcpy的参数n一致。
> 
> 同时，本地变量len和返回值声明为`size_t`。

我们已经看到了许多无符号运算的细微特性，尤其是有符号数到无符号数的隐式转换，会导致错误或者漏洞的方式。避免这类错误的一种方法就是绝不使用无符号数。实际上，除了C以外很少有语言支持无符号整数。很明显，这些语言的设计者认为它们带来的麻烦要比益处多得多。比如，Java只支持有符号整数，并且要求以补码运算来实现。正常的右移运算符>>被定义为执行算术右移。特殊的运算符>>>被指定为执行逻辑右移。

当我们想要把字仅仅看做是位的集合而没有任何数字意义时，无符号数值是非常有用的。例如，往一个字中放人描述各种布尔条件的标记(flag)时，就是这样。地址自然地就是无符号的，所以系统程序员发现无符号类型是很有帮助的。当实现模运算和多精度运算的数学包时，数字是由字的数组来表示的，无符号值也会非常有用。

### 2.3 整数运算
#### 2.3.1 无符号加法


**练习题2.27**

```C
int uadd_ok(unsigned x, unsigned y){
    unsigned result = x + y;
    printf("%u + %u = %u\n", x, y, result);
    return (result < x) || (result < y);
}
int usub_ok(unsigned x, unsigned y){
    unsigned result = x - y;
    printf("%u - %u = %u\n", x, y, result);
    return result > x;
}
int tadd_ok(int x, int y){
    int result = x + y;
    printf("%d + %d = %d\n", x, y, result);
    return ((result ^ x) & (result ^ y)) >> 31;
}
int tsub_ok(int x, int y){
    int result = x - y;
    printf("%d - %d = %d\n", x, y, result);
    return ((result ^ x) & (result ^ (-y))) >> 31;
}
```

模数加法形成了一种数学结构，称为**阿贝尔群**。可交换和可结合。有一个单位元0，并且每个元素有一个加法逆元。考虑$w$位的无符号数的集合，执行加法计算$+^u_w$，对于每个值，必然有某个值$-^u_wx$满足$-^u_wx+^u_wx=0$。

该加法的逆操作可以表述如下：


 0的无符号加法逆元是0

#### 2.3.2 补码加法

范围：$-2$

#### 2.3.3 补码的非

#### 2.3.4 无符号乘法

#### 2.3.5 补码乘法

#### 2.3.6 乘以常数

背景：

原理：乘以2的幂

设$x$为位模式$[x_{w-1},x_{w-2},...,x_0]$。

#### 2.3.7 除法

右移

算术右移

### 2.4 浮点数

$$
d=\sum_{i=-n}^m\times d_i
$$

#### 2.4.2 IEEE浮点表示





























## 第 3 章：程序的机器级表示

计算机执行**机器代码**，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据。

编译器：基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。

GCC C语言编译器：以汇编代码的形式产生输出。

汇编代码：机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。

高级语言编程中，机器屏蔽了程序的细节——机器级的实现，提供的抽象级别比较高，工作效率会更高，也更可靠。

汇编代码编程中，程序员指定程序用来执行的计算的低级指令。高级语言工作效率更高，具有可移植性。

> 网络旁注：ASM：IA32 IA32编程
>
> IA32是x86-64的32位前身，是Intel在1985年提出。

32位机器：4GB的随机访问存储器。

64位机器：多达256TB、16EB的内存空间。

### 3.1 历史观点

Intel处理器俗称`x86`处理器。是一代单芯片、16位微处理器之一。

表示：K表示1000，M表示1000000，G表示1000000000。

**8086**：1978年，29K的晶体管。第一代单芯片、16位微处理器之一。最初的机器型号只有32768字节的内存和两个软驱。

从体系结构上看，这些机器只有655360字节的地址空间——地址只有20位长(可寻址范围是1048576字节)，而操作系统保留了393216字节自用。

1980年，提出了8087浮点协处理器(45K个晶体管)，它与一个8086或8088处理器一同运行，执行浮点指令。称为"x87"。

**80286**：1985年，134K个晶体管。增加了更多的寻址模式，构成了IBM PC-AT个人计算机的基础，是MS Windows最初的使用平台。

**i386**（1985年，275K个晶体管）。将体系结构扩展到32位。增加了**平坦寻址模式(flataddressing model)**，Linux和最近版本的Windows 操作系统都是使用的这种模式。这是Intel系列中第一台全面支持 Unix 操作系统的机器。

**i486**(1989 年，1.2M个晶体管)。改善了性能，同时将浮点单元集成到了处理器芯片上，但是指令集没有明显的改变。

**Pentium**(1993 年，3.1M个晶体管)。改善了性能，不过只对指令集进行了小的扩展。

**PentiumPro**（1995年，5.5M个晶体管）。引全新的处理器设计，在内部被称为P6微体系结构。指令集中增加了一类“**条件传(conditionalmove)**”指令。

**Pentium/MMX**（1997年，4.5M个晶体管）。在 Pentium 处理器中增加了一类新的处理整数向量的指令。每个数据大小可以是 1、2或4字节。每个向量总长 64 位。

**Pentium II**（1997年，7M个晶体管）。P6微体系结构的延伸。

**Pentium III**（1999 年，8.2M个晶体管）。引人了SSE，这是一类处理整数或浮点数向量的指令。每个数据可以是1、2或4 个字节，打包成 128 位的向量。由于芯片上包括了二级高速缓存，这种芯片后来的版本最多使用了`24M`个晶体管。

**Pentium 4**（2000年，42M个晶体管）。SSE 扩展到了`SSE2`，增加了新的数据类型（包括双精度浮点数），以及针对这些格式的 144 条新指令。有了这些扩展，编译器可以使用SSE指令(而不是`x87`指令)，来编译浮点代码。

**Pentium 4E**（2004 年，125M个晶体管）。增加了超线程(hyperthreading)，这种技术可以在一个处理器上同时运行两个程序；还增加了EM64T，它是Intel对AMD提出的对IA32的64位扩展的实现，我们称之为x86-64。

**Core 2**（2006 年，291M个晶体管）。回归到类似于P6的微体系结构。Intel的第一个多核微处理器，即多处理器实现在一个芯片上。但不支持超线程。

**Core i7**，Nehalem(2008 年，781M个晶体管)。既支持超线程，也有多核，最初的版本支持每个核上执行两个程序，每个芯片上最多四个核。

**Core i7**，Sandy Bridge(2011年，1.17G个晶体管)。引入了AVX，这是对 SSE 的扩展，支持把数据封装进256 位的向量。

**Core i7**，Haswell(2013 年，1.4G 个晶体管)。将AVX 扩展至AVX2，增加了更多的指令和指令格式。

每个后继处理器的设计都是后向兼容的——较早版本上编译的代码可以在较新的处理器上运行。Intel处理器系列有好几个名字，包括 `IA32`，也就是“Intel 32 位体系结构(Intel Architecture 32-bit)”，以及最新的`Intel 64`，即IA32的64 位扩展，我们也称为`x86-64`。最常用的名字是“`x86`”，我们用它指代整个系列，也反映了直到486处理器命名的惯例。

> **摩尔定律(Moore's Law)**
>
> 含义：晶体管数量每26个月就会翻一番。
>
> <img src="深入理解计算机系统.assets/image-20221121150333016.png" alt="image-20221121150333016" style="zoom:50%;" />
>
> 1965年，Gordon Moore，Intel公司的创始人，根据当时的芯片技术(那时他们能够在一个芯片上制造有大约 64 个晶体管的电路)做出推断，预测在未来 10 年，芯片上的晶体管数量每年都会翻一番。这个预测就称为摩尔定律。正如事实证明的那样，他的预测有点乐观，而且短视。在超过 50 年中，半导体工业一直能够使得晶体管数目每 18 个月翻一倍。
>
> 对计算机技术的其他方面，也有类似的呈指数增长的情况出现，比如磁盘和半导体存储器的存储容量。这些惊人的增长速度一直是计算机革命的主要驱动力。

### 3.2 程序编码

假设有一个C程序，有两个文件`p1.c`和`p2.c`。

Unix命令行编译：`linux > gcc -0g -o p p1.c p2.c`。

命令：`gcc`指的是`GCC C`编译器，是Linux默认的编译器。

`-Og`：编译器使用会生成符合原始C代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系难以理解。

`gcc`命令调用了一整套程序，将源代码转化成可执行代码。

1. **C预处理器**：扩展源代码，插入所有用`#include`命令指定的文件，扩展所有用`#define`声明指定的宏。
2. 编译器产生两个源文件的汇编代码，名字分别为`p1.s`和`p2.s`。
3. 汇编器会将汇编代码转化成二进制目标代码文件`p1.o`和`p2.o`
4. 目标代码是机器代码的一种形式，它包含所有指令的二进制表示。
5. 链接器将两个代码文件与实现库函数的代码合并，并产生最终可执行代码文件`p`。

#### 3.2.1 机器级代码

对于机器级编程来说，两种抽象十分重要：

1. 由指令集体系结构或指令集架构(Instruction Set)定义。

   定义机器级程序的格式和行为，定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA，包括x86-64，将程序的行为描述成好像每条指令按照顺序执行，一条指令结束，下一条指令再执行。处理器的硬件比描述的精细复杂，会并发地

2. 机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去像是一个非常大的字节数组。存储器系统实际实现是将多个硬件存储器和操作系统软件组合起来。

在整个编译过程中，编译器会完成大部分的工作，将把用C语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。能够理解汇编代码以及它与原始 C代码的联系，是理解计算机如何执行程序的关键一步。

x86-64的机器代码和原始的C代码差别很大：

+ 程序计数器(PC，在`x86-64`中用`%rip`表示)给出将要执行的下一跳指令在内存中的地址。
+ 整数寄存器文件包含16个命名的位置，分别存储64位的值。寄存器可以存储地址或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
+ 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现`if`和`while`语句
+ 一组向量寄存器可以存放一个或多个整数或浮点数值。

机器代码简单地将内存看成一个很大、按照字节寻址的数组。

C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节表示。即使是对标量数据类型，汇编代码不区分。

程序内存包含：程序可执行机器代码、操作系统的信息、栈、块。

例如，`x86-64`的虚拟地址是由64位的字来表示的。在目前的实现中这些地址的高16位必须设置为0，所以一个地址实际上能够指定的是$2^{48}$或64TB范围内的一个字节。较为典型的程序只会访问几兆字节或几千兆字节的数据。

操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

**一条机器指令只执行一个非常基本的操作**。例：将存放在寄存器中两个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现程序结构。

> **不断变化的生成代码的格式**
>
> 在本书的表述中，我们给出的代码是由特定版本的$GCC$在特定的命令行选项设置下产生的。如果你在自己的机器上编译代码，很有可能用到其他的编译器或者不同版本的$GCC$，因而会产生不同的代码。支持 $GCC$的开源社区一直在修改代码产生器，试图根据微处理器制造商提供的不断变化的代码规则，产生更有效的代码。本书示例的目标是展示如何查看汇编代码，并将它反向映射到高级编程语言中的结构。你需要将这些技术应用到你的特定的编译器产生的代码格式上。

#### 3.2.2 代码示例

```c
long mult2(long,long)
    
void multstore(long x,long y,long *dest)
{
    long t = mult2(x,y);
    *dest = t;
}
```

在命令行上使用`-S`选项，就能看到C语言编译器产生的汇编代码：

```shell
linux > gcc -0g -S mstore.c
```

含义：产生一个汇编文件`mstore.s`，但是不做其他进一步工作(调用汇编器产生目标代码文件)。

汇编代码包含的声明：

```c
multstore:
   pushq %rbx
   movq  %rbx,%rbx
   call  mult2
   movq  %rax,(%rbx)
   popq  %rbx
   ret
```

代码中每个缩进去的行都对应了一条机器指令。

`pushq`：表示应该将寄存器`%rbx`的内容压入程序栈中。这段代码中已经除去了所有关于局部变量名或数据类型的信息。

使用了`-c`后，GCC会编译并汇编该代码：

`linux > gcc -0g -c mstore.c`

产生了目标代码文件`mstore.o`，是二进制格式的。

例：1368字节的文件`mstore.o`中有一段14字节的序列，它的十六进制表示是：

`53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3`

这就是上面列出的汇编指令对应的目标代码。从中得到一个重要信息：机器执行的程序只是一个字节序列，是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。

> **旁注：如何展示程序的字节表示**
>
> 展示程序的二进制目标代码，用反汇编器确定该过程代码长度是14字节。
>
> 在`mstore.o`上运行GNU调试工具GDB，输入：`(gdb) x/14xb multstore`。
>
> 这条命令告诉GDB显示从函数multstore所处地址开始的14个十六进制格式表示。

反汇编器(disassembler)：查看机器代码文件的内容。根据机器代码产生一种类似于汇编代码格式。

**Linux中，带`-d`命令行标志的程序OBJDUMP(表示“`object dump`”)可以充当这个角色。**

```shell
linux> objdump -d mstore.o
```

查看：

```
Disassembly of function multstore in binary file mstore. o
1 0000000000000000 <multstore>: 
	Offset Bytes				Equivalent	assembly	language
2	0:	   53					push        %rbx
3	1:	   48 89 d3 			mov			%rbx	
4   4:     e8 00 00 00 00		callq		9 <multstore+0x9>
5   9:     48 89 03				mov			%rax,(%rbx)	
6   c:	   5b					pop			%rbx
7   d:     c3					retq
```

14个十六进制字节值，被分成若干组，每组有1~5个字节。每组都是一个指令，右边是等价的汇编语言。

机器代码和反汇编特性：

1. `x86-64`的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。
2. 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令`pushq %rbx`是以字节值53开头的。
3. 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
4. 反汇编器使用的指令命名规则与`GCC`生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的`'q'`。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给`call`和`ret`指令添加了`'q'`后缀，同样，省略这些后缀也没有问题。

生成可执行代码需要对目标代码运行链接器，这组目标代码文件中必须包含`main`函数，假设有这样的函数：

```c
#include <stdio.h>
void multstore(long,long,long *);
int main()
{
    long d;
    multstore(2,3,&d);
    printf("2*3 -> %ld\n",d);
    return 0;
}
long mult2(long a,long b)
{
    long s = a*b;
    return s;
}
```

生成可执行文件`prog`：

```shell
linux>gcc -0g -o prog main.c mstore.c
```

文件`prog`变成了8655个字节，因为它包含两个过程的代码、启动和终止程序、与操作系统交互的代码。

反汇编`prog`文件：

```shell
linux>objdump -d prog
```

反汇编器抽取出各种代码序列，包括：

```shell
Disaaembly of function sum multstore binary file prog
1 0000000000400540 <multstore>:
2	400540:53			push %rbx
```

第一个不同：左边代码地址移到了不同的地址范围中。

第二个不同：链接器填上了`callq`指令调用函数`mult2`需要使用的地址。

#### 3.2.3 关于格式的注解

生成汇编代码`mstore.s`：

```shell
linux>gcc -0g -S mstore.c
```

`mstore.s`完整内容：

<img src="深入理解计算机系统.assets/image-20221125152543298.png" alt="image-20221125152543298" style="zoom: 80%;" />

`.`开头的行：指导汇编器和链接器工作的伪指令。

带解释的汇编代码：

<img src="深入理解计算机系统.assets/image-20221125152738751.png" alt="image-20221125152738751" style="zoom:80%;" />

左边的编号：提供引用。

右边：注释，描述指令效果。

网络旁注：为专门的机器语言爱好者提供资料。一个网络旁注描述的是IA32机器代码；另一个网络旁注描述了C语言中插入汇编代码的方法。

汇编代码访问机器的低级特性；汇编代码编写整个函数，在链接阶段把它们和C函数组合起来；利用GCC的支持，直接在C程序中嵌入汇编代码。

> 旁注：ATT与Intel汇编代码格式
>
> 我们的表述是ATT(根据“AT&T”命名的，`AT&T`是运营贝尔实验室多年的公司)格式的汇编代码，这是GCC、OBJDUMP和其他一些我们使用的工具的默认格式。其他一些编程工具，包括 Microsoft的工具，以及来自`Intel`的文档，其汇编代码都是Intel格式的。这两种格式在许多方面有所不同。例如，使用下述命令行，GCC可以产生`multstore`函数的Intel格式的代码：`linux>gcc -0g -S -masm=intel mstore.c`
>
> 这个命令得到下列汇编代码：
>
> ```
> multstore:
> push rbx
> mov rbx,rdx
> call mult2
> mov QWORD PTR [rbx], rax
> pop rbx
> ret
> ```
>
> Intel和ATT格式的不同：
>
> + Intel代码省略了指示大小的后缀。我们看到指令push和 mov，而不是pushq和movq。
> + Intel代码省略了寄存器名字前面的‘%’符号，用的是 rbx，而不是%rbx。
> + Intel代码用不同的方式来描述内存中的位置，例如是’QWORD PTR [rbx]’而不是‘(%rbx)’。
> + 在带有多个操作数的指令情况下，列出操作数的顺序相反。当在两种格式之间进行转换的时候，这一点非常令人困惑。

> 网络旁注ASM：EASM 把C程序和汇编代码结合起来
>
> 虽然C编译器在把程序中表达的计算转换到机器代码方面表现出色，但是仍然有一些机器特性是C程序访问不到的。例如，每次 x86-64处理器执行算术或逻辑运算时，如果得到的运算结果的低8位中有偶数个1，那么就会把一个名为PF的1位条件码(condition code)标志设置为1，否则就设置为0。这里的PF表示“parity flag(奇偶标志)”。在C语言中计算这个信息需要至少7次移位、掩码和异或运算(参见习题2.65)。即使作为每次算术或逻辑运算的一部分，硬件都完成了这项计算，而C程序却无法知道PF条件码标志的值。在程序中插入几条汇编代码指令就能很容易地完成这项任务。
>
> 在C程序中插入汇编代码有两种方法。第一种是，我们可以编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把它和用C语言书写的代码合并起来。第二种方法是，我们可以使用GCC的内联汇编(inline assembly)特性，用asm伪指令可以在C程序中包含简短的汇编代码。这种方法的好处是减少了与机器相关的代码量。
>
> 当然，在C程序中包含汇编代码使得这些代码与某类特殊的机器相关(例如x86-64)，所以只应该在想要的特性只能以此种方式才能访问到时才使用它。

### 3.3 数据格式

字(word)：表示16位数据类型。

双字(double words)：32位数。

四字(quad words)：64位数。

C语言基本数据类型对应的x86-64表示：

![image-20230102132130146](深入理解计算机系统.assets/image-20230102132130146.png)

标准`int`值存储为双字(32位)。

指针(`char *`)存储为8字节的四字。

x86-64中，数据类型`long`实现为64位。

浮点数的两种形式：单精度(4字节)值，对应`float`；双精度(8字节)值，对应于C语言数据类型`double`。

多数GCC生产的汇编代码指令有一个字符的后缀，表示操作数的大小。

数据传送指令：

+ movb：传送字节。
+ movw：传送字。
+ movl：传送双子。
+ movq：传送四字。

后缀`l`：表示双字，因为32位数被看成是”长字(long word)”。汇编代码也使用后缀`l`表示4字节整数和8字节双精度浮点数。

浮点数使用的是一组完全不同的指令和寄存器。

### 3.4 访问信息

一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。

![image-20230107123254653](深入理解计算机系统.assets/image-20230107123254653.png)

这16个寄存器的名字都以`%r`开头，后面跟着一些不同命名规则的名字。

最初的8086中有8个16位的寄存器，即图3-2中的`%ax`到`%bp`。每个寄存器都有特殊的用途，它们的名字就反映了这些不同的用途。扩展到IA32架构时，这些寄存器也扩展成 32位寄存器，标号从`%eax`到`%ebp`。扩展到 `x86-64`后，原来的8个寄存器扩展成64位，标号从`%rax`到`%rbp`。除此之外，还增加了8个新的寄存器，它们的标号是按照新的命名规则制定的：从`%r8`到`%r15`。

指令可以对这16个寄存器的低位字节中存放的不同大小数据进行操作。字节级操作可以访问最低的字节，16位操作可以访问最低的2个字节，32位操作可以访问最低的4个字节，而64位操作可以访问整个寄存器。

当这些指令以寄存器作为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则：生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置为0。后面这条规则是作为从`IA32`到`x86-64`的扩展的一部分而采用的。

程序里不同的寄存器扮演不同的角色。栈指针`%rsp`，指明运行时栈的结束位置。

#### 3.4.1 操作数指示符

大多数指令有一个或多个操作数(operand)：指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。

`x86-64`支持多种操作数格式。源数据值可以以常数或者从寄存器或者内存中读出，结果可以存放在寄存器或者内存中。

操作数的三种类型：

+ 立即数(immediate)：表示常数值。

  + ATT格式汇编代码，书写方式：`$`后面跟一个用标准C表示法的整数，比如：`$-577`或`$0x1F$`。

+ 寄存器(register)：表示某个寄存器的内容。

  + 16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节数分别对应于8位、16位、32位或64位。

  + 符号$r_a$表示任意寄存器$a$，用引用R[$r_a$]表示它的值。

    > 将寄存器集合堪称一个数组R，用寄存器标识符作为索引。

+ 内存引用：根据计算出来的地址(有效地址)访问某个内存位置。

  + 用符号$M_b[Addr]$表示对存储在内存中地址$Addr$开始的$b$个字节值的引用。

不同的寻址模式：

+ $Imm(r_b,r_i,s)$表示最常用的形式。
+ 四个组成部分：一个立即数偏移$Imm$，一个基址寄存器$r_b$，一个变址寄存器$r_i$和一个比例因子$s$，$s$的取值必须是1、2、4或8。
+ 基址和变址寄存器都必须是64位寄存器。
+ 有效地址计算：$Imm$+$R[r_b]$+$R[r_i]·s$。

![image-20230107140452546](深入理解计算机系统.assets/image-20230107140452546.png)

练习3.1：假设下面的值存放在指明的内存地址和寄存器中：

| 地址  | 值   |
| ----- | ---- |
| 0x100 | 0xFF |
| 0x104 | 0xAB |
| 0x108 | 0x13 |
| 0x10C | 0x11 |

| 寄存器 | 值    |
| ------ | ----- |
| %rax   | 0x100 |
| %rcx   | 0x1   |
| %rdx   | 0x3   |

填写下表，给出所示操作数的值：

| 操作数         | 值    |
| -------------- | ----- |
| %rax           | 0x100 |
| 0x104          | 0xAB  |
| $0x108         | 0x108 |
| (%rax)         | 0xff  |
| 4(%rax)        | 0xAB  |
| 9(%rax,%rdx)   | 0x11  |
| 260(%rcx,%rdx) | 0x13  |
| 0xFC(,%rcx,4)  | 0xff  |
| (%rax,%rdx,4)  | 0x11  |

#### 3.4.2 数据传送指令

最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。

操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能。

把许多不同的指令划分成指令类，每一类中的指令执行相同的操作，只不过操作数大小不同。

最简单形式的数据传送指令——MOV类。这些指令把数据从源位置复制到目的位置，不做任何变化。

MOV类由四条指令组成：`movb`、`movw`、`mov1`和`movq`。区别：执行同样的操作，操作的数据大小不同，分别是1、2、4和8字节。

<img src="深入理解计算机系统.assets/image-20230111090817115.png" alt="image-20230111090817115" style="zoom:67%;" />

源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址。

`x86-64`加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令——第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。

指令的寄存器操作数可以是16个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符(‘b’,’w’,’l’或‘q’)指定的大小匹配。大多数情况中，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是`movl`指令以寄存器作为目的时，它会把寄存器的高位4字节设置为0，原因：任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0。

MOV指令示例：源和目的类型的五种可能的组合。第一个是源操作数，第二个是目的操作数：

```
movl $0x4050,%eax Immediate--Register, 4 bytes
movw %bp,%sp Register--Register, 2 bytes
movb (%rdi,%rcx)%al Memory--Register, 1byte
movb $-17,(%rsp) Immediate--Memory, 1byte
movq %rax,-12(%rbp) Register--Memory, 8 bytes//处理64位立即数数据
```

常规的`movq`指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置。

`movabsq`指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。

两类数据移动指令：在将较小的源值复制到较大的目的时使用。所有这些指令都把数据从源（在寄存器或内存中）复制到目的寄存器。

`MOVZ`类中的指令把目的中剩余的字节填充为0，而`MOVS`类中的指令通过符号扩展来填充，把源操作的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符：第一个字符指定源的大小，而第二个指明目的的大小。正如看到的那样，这两个类中每个都有三条指令，包括了所有的源大小为1个和2个字节、目的大小为2个和4个的情况，当然只考虑目的大于源的情况。

![image-20230111132910051](深入理解计算机系统.assets/image-20230111132910051.png)

> 理解数据传送如何改变目的寄存器
>
> 代码序列说明数据传送指令是否以及如何修改目的寄存器的高位字节：
>
> ```
> movabsq $0x0011223344556677,%rax %rax=0011223344556677
> movb $-1,%al %rax=00112233445566FF
> movw $-1,%ax %rax=001122334455FFFF
> movl $-1,%eax %rax=00000000FFFFFFF
> movq $-1,%rax %rax=FFFFFFFFFFFFFFF
> ```
>
> 第一行指令把寄存器%rax初始化为位模式0011223344556677。剩下的指令源操作数值是立即数值-1。
>
> -1的十六进制表示形如FF….F，F的数量是表述中字节数量的两倍。
>
> movb指令把%rax低位字节设置成FF；movw指令把低2位字节设置成FFFF；`movl`指令将低4个字节设置为FFFFFFFF，同时把高位4字节设置为00000000；最后movq指令把整个寄存器设置为FFFFFFFFFFFFFFFF。
>
> 4字节源值零扩展到8字节目的：借助`movl`指令实现。生成4字节值并以寄存器作为目的的指令把高4字节设置为0。对于64位的目标，所有三种源类型都有对应的符号扩展传送，而只有两种较小的源类型有零扩展传送。
>
> `cltq`指令：无操作数，以寄存器%eax作为源，%rax作为符号扩展结果的目的，它的效果与指令movslq %eax,%rax完全一致。

练习题3.2：对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀

1 l

2 w

3 b

4 b

5 q

6 w

#### 3.4.3 数据传送示例

a.C语言代码









# 第三部分 程序间的交互和通信

目标：了解UNIX操作系统提供的基本`I/O`服务。

> 例：Web客户端和服务器，通过Internet彼此通信。

### 第10章：系统级`I/O`

含义：输入/输出(`I/O`)是在主存和外部设备(磁盘驱动器、终端和网络之间复制数据的过程)。

> 输入：从I/O设备复制数据到主存；
>
> 输出：从主存复制数据到`I/O`设备；

所有语言的运行时系统都提供执行I/O较高级别的工具。

> 例：ANSI C提供标准`I/O`库，包含`printf`或`scanf`这样执行带缓冲区的I/O函数。
>
> C++语言用它的重载操作符、`<<`(输入)和`>>`(输出)提供了类似的功能。
>
> Linux系统中，通过使用内核提供的系统级`Unix I/O`函数实现这些较高级别的`I/O`函数。

标准 IO 库没有提供读取**元文件**数据的方式，例如文件大小或文件创建时间

学习`Unix I/O`好处：

1. 理解其它系统概念。
2. 没有选择的选择。

#### 10.1 Unix I/O

一个`Linux`文件就是一个$m$个字节的序列：
$$
B_0,B_1,...,B_k,...,B_{m-1}
$$
`Unix I/O`：所有的`I/O`设备(网络、磁盘和终端)都被模型化为==**文件**==，所有输入和输出都被当作相应文件的读和写执行。这种将设备映射为文件的方式，允许`Linux`内核引出简单、低级的应用接口，即是`Unix I/O`。

这使得输入和输出都能以一种统一方式执行：

1. **打开文件**。一个应用程序通过要求内核打开相应的文件，宣告它想访问一个`I/O`设备。内核返回一个小的非负整数，叫做**描述符**，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。

   概念：描述符。

2. `Linux shell`创建的每个进程开始时都有三个打开的文件：

   + **标准输入**(描述符是0)
   + **标准输出(**描述符是1)
   + **标准错误**(描述符是2)
   + 头文件`<unistd.h>`定义了常量`STDIN_FILENO`、`STDOUT_FILENO`、`STDERR_FILENO`，用来代替显示的描述符值。

3. **改变当前的文件位置**。

   + 对于每个打开的文件，内核保持着一个文件位置$k$，初始为0。
   + 这个文件位置是从文件开头起始的**字节偏移量**。
   + 应用程序能够通过执行`seek`操作，显式地设置文件的当前位置为$k$。

4. **读写文件**。

   + 读操作
     + 从文件复制$n>0$个字节到内存，从当前文件位置$k$开始，然后将飞增加到$k+n$。
     + 给定一个大小为$m$字节的文件，当$k>m$时执行读操作会触发一个称为`end-of-file(EOF)`的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF 符号”。

   + 写操作
     + 从内存复制$n>0$个字节到一个文件，从当前文件位置$k$开始，然后更新$k$。

5. **关闭文件**。

   + 当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构。
   + 将这个描述符恢复到可用的描述符池中。
   + 无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。

#### 10.2 文件

每个Linux文件都有一个类型(type)表明它在系统中的角色：

+ `普通文件(regular file)`

  + 包含任意数据。
  + 应用程序
    + 文本文件(text file)
      + 文本文件只含有ASCII或Unicode字符的普通文件。
    + 二进制文件(binary file)
      + 二进制文件包含其他文件。

  + 内核不区分文本文件和二进制文件。

  + `Linux`文本文件包含了一个`文本行(text line)`序列，每一行都是一个字符序列，以一个新行符("\n")结束。
    + 新行符与ASCII的换行符(LF)相同，数字值为`0X0a`。

+ `目录(directory)`

  + 包含一组`链接(link)`的文件。
  + 每个链接都将一个`文件名(filename)`映射到一个文件，这个文件可能是另一个目录。
  + 每个目录至少含有两个条目：`“.”`是到该目录自身的链接，以及`“..”`是到目录层次结构中`父目录(parent directory)`的链接。
  + 用 `mkdir`命令创建一个目录，用`ls`查看其内容，用`rmdir`删除该目录

+ `套接字(socket)`：与另一个进程进行跨网络通信的文件。

其他文件类型：

+ 命名通道(named pipe)；
+ 符号链接(symbolic link)；
+ 字符和块设备(character and block device)；

`Linux`内核将所有文件组织成一个`目录层次结构(directory hierarchy)`，由名为`/`(斜杠)的根目录确定。系统中的每个文件都是根目录的直接或间接的后代。

<img src="深入理解计算机系统.assets/image-20221114230303570.png" alt="image-20221114230303570" style="zoom: 67%;" />

作为上下文的一部分，每个进程都有一个`当前工作目录(current working directory)`来确定其在目录层次结构中的当前位置。可以用`cd`命令来修改`shell`中的当前工作目录。

目录层次结构中的位置用`路径名(pathname)`来指定。路径名是一个字符串，包括一个可选斜杠，其后紧跟一系列的文件名，文件名之间用斜杠分隔。路径名有两种形式：

+ `绝对路径名(absolute pathname)`：以一个斜杠开始，表示从根节点开始的路径。例如，在图10-1中，`hello.c`的绝对路径名为`/home/droh/hello.c`。
+ `相对路径名(relative pathname)`：以文件名开始，表示从当前工作目录开始的路径。例如，在图10-1中，如果`/home/droh`是当前工作目录，那么`hello.c`的相对路径名就是`./hello.c`。反之，如果`/home/bryant`是当前工作目录，那么相对路径名就是`../home/droh/hello.c`。

#### 10.3 打开和关闭文件

进程通过调用`open`函数打开一个已存在的文件或创建一个新文件：

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(char *filename,int flags,mode_t mode);

//返回:若成功则为新文件描述符，若出错为-1。
```

`open`函数将`filename`转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。

##### flag参数

`flags`参数指明了进程打算如何访问这个文件:

+ `O_RDONLY`：只读。
+ `O_WRONLY`：只写
+ `O_RDWR`：可读可写。

例，下面的代码说明如何以读的方式打开一个已存在的文件：

`fd = Open("foo.txt",O_RDONLY,0);`

`flags`参数也可以是一个或者更多位掩码的或，为写提供给一些额外的指示：

+ `O_CREAT`：如果文件不存在，就创建它的一个`截断的(truncated)`(空)文件。
+ `O_TRUNC`：如果文件已经存在，就截断它。
+ `O_APPEND`:在每次写操作前，设置文件位置到文件的结尾处。

例如，下面的代码说明的是如何打开一个已存在文件，并在后面添加一些数据

`fd = Open("foo.txt",0_WRONLY|O_APPEND,0);`

> `|`表示管道：前面的结果作为后面的输入

##### mode参数

`mode`参数

+ 指定了新文件的访问权限位。

+ 访问权限位。在 `sys/stat.h` 中定义：

| 掩码 | 描述    |                                    |
| ---- | ------- | ---------------------------------- |
| usr  | S_IRUSR | 使用者（拥有者）能够读这个文件     |
|      | S_IWUSR | 使用者（拥有者）能够写这个文件     |
|      | S_IXUSR | 使用者（拥有者）能够执行这个文件   |
| grp  | S_IRGRP | 拥有者所在组的成员能够读这个文件   |
|      | S_IWGRP | 拥有者所在组的成员能够写这个文件   |
|      | S_IXGRP | 拥有者所在组的成员能够执行这个文件 |
| oth  | S_IROTH | 其他人（任何人）能够读这个文件     |
|      | S_IWOTH | 其他人（任何人）能够写这个文件     |
|      | S_IXOTH | 其他人（任何人）能够执行这个文件   |

作为上下文的一部分，每个进程都有一个`umask`，通过调用`umask`函数来设置的。当进程通过带某个`mode`参数的`open`函数调用来创建一个新文件时，文件的访问权限位被设置为`mode & ~ umask`。例如，假设我们给定下面的`mode`和`umask`默认值：

```c
#define DEF_MODE S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH
#define DEF_UMASK S_IWGRP|S_IWOTH
```

接下来，下面的代码片段创建一个新文件，文件的拥有者有读写权限，而所有其他的拥堵都有读权限：

```c
umask(DEF_UMASK);
fd = Open("foo.txt"，0_CREAT|O_TRUNC|O_WRONLY，DEF_MODE);
```

最后，进程通过调用`close`函数关闭打开的文件

```c
#include<unistd.h>
int close(int fd);
// 返回：若成功则为 0， 若出错则为 -1
```

关闭一个已关闭的描述符会出错。

**练习题10.1** 

```c
#include "csapp.h"
int main ()
{
  int fd1, fd2;
  fd1 = Open("foo. txt", 0_RDONLY, 0);
  fd2 = Open("bar.txt", 0_RDONLY, 0);
  Close(fd2);
  fd2 = Open("baz. txt", 0_RDONLY, 0);
  printf("fd2 = %d\n",  fd2);
  exit(0) ;
}
```

答案：Unix进程生命周期开始时，打开的描述符赋给了stdin(描述符 0) 、stdout(描述符 1)和stderr描述符 2)。`open函数`总是返回最低的未打开的描述符，所以第一次调用open会返回描述符3。调用close函数会释放描述符，最后对`open`的调用会返回描述符3，因此程序的输出是 "fd2=3"。

#### 10.4 读和写文件

应用程序通过调用`read`和`write`函数执行输入和输出。

```c
#include <unistd.h>
// fd 文件描述符       *buf 内存位置	 n 大小
ssize_t read(int fd, void *buf, size_t n);
// 返回： 若成功则为读的字节数，若 EOF(end of file) 则为0，若出错则为 -1.
ssize_t write(int fd, const void *buf, size_t n);
// 返回： 若成功则为写的字节数，若出错则为 -1.
```

##### `read`函数

含义：

+ 从描述符为`fd`的当前文件位置复制最多$n$个字节到内存位置 `buf`。

- 返回值
  - -1表示一个错误；
  - 0表示`EOF(end of file)；
  - 否则返回值表示的是实际传送的字节数量；

##### `write`函数

含义：从内存位置`buf`复制至多$n$个字节到描述符`fd`的当前文件位置。

以下程序使用`read`和`write`调用一次一个字节地从标准输入复制到标准输出。

```c
/* $begin cpstdin */
#include "csapp.h"

int main(void) 
{
    char c;

    while(Read(STDIN_FILENO, &c, 1) != 0) 
        Write(STDOUT_FILENO, &c, 1);
    exit(0);
}
/* $end cpstdin */
```

调用`lseek`函数，应用程序能够显式地修改当前文件的位置。

> ##### `ssize_t`和`size_t`的区别
>
> - read()函数`size_t`为参数，返回值为`ssize_t`。
> - x86-64 系统中，`size_t`定义为`unsigned long`，而`ssize_t` (**有符号的大小**) 被定义为`long`。
> - `read`函数返回一个有符号的大小，保证出错时能返回 **-1。**
> - 返回-1的可能性使得`read`的最大值减小了一半。

##### 不足值

背景：在某些情况下， read 和write传送的字节比应用程序要求的要少。这些不足值（ short count ）不表示有错误。

> **不足值是已经读到的文本**。

出现不足值的原因：

- 读时遇到 EOF
  - 准备读一个文件，该文件从当前文件位置开始只含有20个字节的。而文件以50个字节的片段进行读取。下一个`read`返回不足值为20，此后的`read`将通过返回不足值0发出EOF信号。
- 从终端读取文本行
  - 打开文件是与终端相关联的，每个`read`函数一次传送一个文本行，返回的不足值等于文本行的大小。
- **读和写网络套接字 socket**
  + 如果打开的文件对应于网络套接字，那么内部缓冲约束和较长的网络延迟会引起函数返回不足值。
  + 对Linux Pipe调用函数时，也有可能出现不足值。
- 读/写磁盘文件时，将会遇到不足值。
- 创建可靠诸如Web服务器的网络应用，须通过反复调用`read`和`write`处理不足值，直到所有需要字节传送完毕。

#### 10.5 用RIO包健壮地读写

RIO(Robust I/O) ：健壮的`I/O`包。

功能：

1. 自动处理上文中的不足值。
2. 在容易出现不足值的应用中，RIO包提供方便、健壮和高效的`I/O`。

RIO提供了两类函数：

- 无缓冲的输入输出函数
  - 函数直接在内存和文件中传送数据，没有应用级缓冲。
  -  对将**二进制数据**读写到网络和从网络读写**二进制数据**尤其有用。
- 带缓冲的输入函数
  - 高效地从文件中读取**文本行**和**二进制数据**。
  - 这些文件的内容缓存在**应用级缓冲区**中，类似于为 `printf` 这样的标准I/O函数提供的缓冲区。
  - 是**线程安全**的（见 Chapter 12.7.1 节）。
  - 在同一个描述符上可以被交错地调用。
  - 可以从一个描述符中读一些文本行，然后读取一些二进制数据，接着再多读取一些文本行。

##### 10.5.1 RIP的无缓冲的输入输出函数

调用`rio_readn`和`rio_writen`函数，应用程序可以在内存和文件之间直接传送数据。

```c
#include <unistd.h>
// fd 文件描述符       *usrbuf 内存位置	 n 大小
ssize_t rio_readn(int fd, void *usrbuf, size_t n);
ssize_t rio_writen(int fd, void *usrbuf, size_t n);
// 返回:若成功则为写传送的字节数,若EOF则为0(只对rio_readn而言)，若出错则为-1
```

`rio_readn`函数：

+ 从描述符`fd`的当前文件位置最多传送$n$个字节到内存位置`usrbuf`。
+ 遇到EOF时只能返回一个不足值。

`rio_writen`函数：

+ 从描述符`fd`的当前文件位置最多传送$n$个字节到描述符`fd`。
+ 不会返回不足值。
+ 对同一个描述符，可以任意交错地调用`rio_readn`和`rio_writen`。

`rio_readn`函数：

```c
/*
 * rio_readn - Robustly read n bytes (unbuffered)
 */
/* $begin rio_readn */
ssize_t rio_readn(int fd, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) {
		if ((nread = read(fd, bufp, nleft)) < 0) {
	    	if (errno == EINTR) /* Interrupted by sig handler return */
				nread = 0;      /* and call read() again */
	    	else
				return -1;      /* errno set by read() */ 
			} 
		else if (nread == 0)
	    	break;              /* EOF */
		nleft -= nread;
		bufp += nread;
    	}
    	return (n - nleft);         /* Return >= 0 */
}
/* $end rio_readn */
```

`rio_writen`函数：

```c
/*
 * rio_readn - Robustly read n bytes (unbuffered)
 */
/* $begin rio_readn */
ssize_t rio_readn(int fd, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) {
		if ((nread = read(fd, bufp, nleft)) < 0) {
	    	if (errno == EINTR) /* Interrupted by sig handler return */
				nread = 0;      /* and call read() again */
	    	else
				return -1;      /* errno set by read() */ 
			} 
		else if (nread == 0)
	   		break;              /* EOF */
		nleft -= nread;
		bufp += nread;
    	}
    	return (n - nleft);         /* Return >= 0 */
}
/* $end rio_readn */
```

> 如果`rio_readn`和`rio_writen`函数被一个从应用信号处理程序的返回中断，那么每个函数会手动地重启`read`或`write`。为了尽可能有较好的可移植性，我们允许被中断的系统调用，且在必要时重启它们。

##### 10.5.2 RIO的带缓冲的输入函数

背景：假设我们要编写一个程序来计算文本文件中文本行的数量，该如何来实现呢？一种方法就是用read函数来一次一个字节地从文件传送到用户内存，检查每个字节来查找换行符。这个方法的缺点是效率不是很高，每读取文件中的一个字节都要求陷入内核。

一种更好的方法是调用一个包装函数（`rio_readlineb`），它从一个内部**读缓冲区**复制一个文本行，当缓冲区变空时，会自动地调用 read 重新填满缓冲区。对于既包含文本行也包含二进制数据的文件（例如 11.5.3 节中描述的 HTTP 响应），我们也提供了一个 rio_readn 带缓冲区的版本，叫做 `rio_readnb`，它从和 rio_readlineb 一样的读缓冲区中传送原始字节。

```c
#include "csapp.h"

void rio_readinitb(rio_t *rp, int fd);
// 返回：无。

ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);
ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n);
// 返回：若成功则为读的字节数，若 EOF 则为 0，若出错则为 -1。 
```

```c
//code/src/csapp.c
/*
 * rio_readn - Robustly read n bytes (unbuffered)
 */
/* $begin rio_readn */
ssize_t rio_readn(int fd, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) {
      if ((nread = read(fd, bufp, nleft)) < 0) {
        if (errno == EINTR) /* Interrupted by sig handler return */
          nread = 0;      /* and call read() again */
        else
          return -1;      /* errno set by read() */ 
      } 
			else if (nread == 0)
        break;              /* EOF */
			nleft -= nread;
			bufp += nread;
    }
    return (n - nleft);         /* Return >= 0 */
}
/* $end rio_readn */
```

```c
/*
 * rio_writen - Robustly write n bytes (unbuffered)
 */
/* $begin rio_writen */
ssize_t rio_writen(int fd, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nwritten;
    char *bufp = usrbuf;

    while (nleft > 0) {
      if ((nwritten = write(fd, bufp, nleft)) <= 0) {
        if (errno == EINTR)  /* Interrupted by sig handler return */
          nwritten = 0;    /* and call write() again */
	    	else
          return -1;       /* errno set by write() */
			}
      nleft -= nwritten;
      bufp += nwritten;
    }
    return n;
}
/* $end rio_writen */
```

每打开一个描述符，都会调用一次 rio_readinitb 函数。它将描述符 fd 和地址 rp 处的一个类型为 rio_t 的读缓冲区联系起来。

rio_readlineb 函数从文件rp读出下一个文本行（包括结尾的换行符），将它复制到内存位置 usrbuf，并且用NULL（零）字符来结束这个文本行。rio_readlineb 函数最多读 **maxlen-1** 个字节，余下的一个字符留给结尾的 NULL 字符。超过 **maxlen-1** 字节的文本行被截断，并用一个 NULL 字符结束。

rio_readnb 函数从文件 rp 最多读 n 个字节到内存位置 usrbuf。对同一描述符，对 rio_readlineb 和 rio_readnb 的调用可以任意交叉进行。然而，对这些带缓冲的函数的调用却不应和无缓冲的 rio_readn 函数交叉使用。

在本书剩下的部分中将给出大量的 RIO 函数的示例。图 10-5 展示了如何使用 RIO 函数来一次一行地从标准输入复制一个文本文件到标准输出。

```c
//code/io/cpfile.c
#include "csapp.h"

int main(int argc, char **argv)
{
    int n;
    rio_t rio;
    char buf[MAXLINE];

    Rio_readinitb(&rio, STDIN_FILENO);
    while ((n = Rio_readlineb(&rio, buf, MAXLINE)) != 0)
        Rio_writen(STDOUT_FILENO, buf, n);
}
```

下面的代码展示了一个读缓冲区的格式，以及初始化它的 rio_readinitb 函数的代码。rio_readinitb 函数创建了一个空的读缓冲区，并且将一个打开的文件描述符和这个缓冲区联系起来。

```c
#define RIO_BUFSIZE 8192
typedef struct {
    int rio_fd;                /* Descriptor for this internal buf */
    int rio_cnt;               /* Unread bytes in internal buf */
    char *rio_bufptr;          /* Next unread byte in internal buf */
    char rio_buf[RIO_BUFSIZE]; /* Internal buffer */
} rio_t;
```

```c
void rio_readinitb(rio_t *rp, int fd)
{
    rp->rio_fd = fd;
    rp->rio_cnt = 0;
    rp->rio_bufptr = rp->rio_buf;
}
```

> 一个类型为 rio_t 的读缓冲区和初始化它的 rio_readinitb 函数

RIO 读程序的核心是图 10-7 所示的 rio_read 函数。rio_read 函数是 Linux read 函数的带缓冲的版本。当调用 rio_read 要求读 n 个字节时，读缓冲区内有 **rp->rio_cnt** 个未读字节。如果缓冲区为空，那么会通过调用 read 再填满它。这个 read 调用收到一个不足值并不是错误，只不过读缓冲区是填充了一部分。一旦缓冲区非空，rio_read 就从读缓冲区复制 n 和 **rp->rio_cnt** 中较小值个字节到用户缓冲区，并返回复制的字节数。

```c
static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)
{
    int cnt;

    while (rp->rio_cnt <= 0) {  /* Refill if buf is empty */
        rp->rio_cnt = read(rp->rio_fd, rp->rio_buf,
                           sizeof(rp->rio_buf));
        if (rp->rio_cnt < 0) {
            if (errno != EINTR) /* Interrupted by sig handler return */
                return -1;
        }
        else if (rp->rio_cnt == 0)  /* EOF */
            return 0;
        else
            rp->rio_bufptr = rp->rio_buf; /* Reset buffer ptr */
    }

    /* Copy min(n, rp->rio_cnt) bytes from internal buf to user buf */
    cnt = n;
    if (rp->rio_cnt < n)
        cnt = rp->rio_cnt;
    memcpy(usrbuf, rp->rio_bufptr, cnt);
    rp->rio_bufptr += cnt;
    rp->rio_cnt -= cnt;
    return cnt;
}
```

对于一个应用程序，rio_read 函数和 Linuxread 函数有同样的语义。在出错时，它返回值 -1，并且适当地设置 errno。在 EOF 时，它返回值 0。如果要求的字节数超过了读缓冲区内未读的字节的数量，它会返回一个不足值。两个函数的相似性使得很容易通过用 rio_read 代替 read 来创建不同类型的带缓冲的读函数。例如，用 rio_read 代替 read，图 10-8 中的 rio_readnb 函数和 rio_readn 有相同的结构。相似地，图 10-8 中的 rio_readlineb 程序最多调用 **maxlen-1** 次 rio_read。每次调用都从读缓冲区返回一个字正然后检查这个字节是否是结尾的换行符。

> RIO包的起源
>
> rio_readn和rio_written函数。

```c
ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)
{
    int n, rc;
    char c, *bufp = usrbuf;

    for (n = 1; n < maxlen; n++) {
        if ((rc = rio_read(rp, &c, 1)) == 1) {
            *bufp++ = c;
            if (c == ’\n’) {
                n++;
                break;
            }
        } else if (rc == 0) {
            if (n == 1)
                return 0; /* EOF, no data read */
            else
                break;    /* EOF, some data was read */
        } else
            return -1;    /* Error */
    }
    *bufp = 0;
    return n - 1;
}
```

```c
ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n)
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) {
        if ((nread = rio_read(rp, bufp, nleft)) < 0)
            return -1;          /* errno set by read() */
        else if (nread == 0)
            break;              /* EOF */
        nleft -= nread;
        bufp += nread;
    }
    return (n - nleft);         /* Return >= 0 */
}
```

#### 10.6 读取文件元数据

应用程序调用`stat`和`fstat`函数，检索到关于文件的信息(也称文件的元数据(metadata))。

```c
#include <unistd.h>
#include <sys/stat.h>

int stat(const char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);

// 返回：若成功则为 0，若出错则为 -1。
```

stat 函数以一个文件名作为输入，并填写如图 10-9 所示的一个 stat 数据结构中的各个成员。fstat 函数是相似的，只不过是以文件描述符而不是文件名作为输入。当我们在 11.5 节中讨论 Web 服务器时，会需要 stat 数据结构中的 st_mode 和 st_size 成员，其他成员则不在我们的讨论之列。

```c
//statbuf.h(included by sys.stat.h)
/* Metadata returned by the stat and fstat functions */
struct stat {
    dev_t         st_dev;      /* Device */
    ino_t         st_ino;      /* inode */
    mode_t        st_mode;     /* Protection and file type */
    nlink_t       st_nlink;    /* Number of hard links */
    uid_t         st_uid;      /* User ID of owner */
    gid_t         st_gid;      /* Group ID of owner */
    dev_t         st_rdev;     /* Device type (if inode device) */
    off_t         st_size;     /* Total size, in bytes */
    unsigned long st_blksize;  /* Block size for filesystem I/O */
    unsigned long st_blocks;   /* Number of blocks allocated */
    time_t        st_atime;    /* Time of last access */
    time_t        st_mtime;    /* Time of last modification */
    time_t        st_ctime;    /* Time of last change */
};
```

st_size成员包含了文件的字节数大小。st_mode成员则编码了文件访问许可位（图 10-2）和文件类型（10.2 节）。Linux 在sys/stat.h中定义了宏谓词来确定st_mode 成员的文件类型：

+ **S_ISREG(m)**。这是一个普通文件吗？
+ **S_ISDIR(m)**。这是一个目录文件吗？
+ **S_ISSOCK(m)**。这是一个网络套接字吗？

图 10-10 展示了我们会如何使用这些宏和 stat 函数来读取和解释一个文件的 st_mode 位。

```c
//code/io/statcheck.c
#include "csapp.h"

int main (int argc, char **argv)
{
    struct stat stat;
    char *type, *readok;

    Stat(argv[1], &stat);
    if (S_ISREG(stat.st_mode))     /* Determine file type */
        type = "regular";
    else if (S_ISDIR(stat.st_mode))
        type = "directory";
    else
        type = "other";
    if ((stat.st_mode & S_IRUSR))  /* Check read access */
        readok = "yes";
    else
        readok = "no";

    printf("type: %s, read: %s\n", type, readok);
    exit(0);
}
```

> 图 10-10 查询和处理一个文件的 st_mode 位

#### 10.7 读取文件目录

使用`readdir`系列函数读取目录内容。

```c
#include <sys/types.h>
#include <dirent.h>

DIR *opendir(const char *name);

// 返回：若成功，则为处理的指针；若出错，则为 NULL。
```

函数 opendir 以路径名为参数，返回指向**目录流**（directory stream）的指针。流是对条目有序列表的抽象，在这里是指目录项的列表。

```c
#include <dirent.h>

struct dirent *readdir(DIR *dirp);

// 返回：若成功，则为指向下一个目录项的指针；
//      若没有更多的目录项或出错，则为 NULL。
```

每次对 readdir 的调用返回的都是指向流 dirp 中下一个目录项的指针，或者，如果没有更多目录项则返回 NULL。每个目录项都是一个结构，其形式如下：

```c
struct dirent {
    ino_t d_ino;      /* inode number */
    char d_name[256]; /* Filename */
};
```

虽然有些 Linux 版本包含了其他的结构成员，但是只有这两个对所有系统来说都是标准的。成员 d_name 是文件名，d_ino 是文件位置。

如果出错，则 readdir 返回 NULL，并设置 errno。可惜的是，唯一能区分错误和流结束情况的方法是检査自调用 readdir 以来 errno 是否被修改过。

```c
#include <dirent.h>

int closedir(DIR *dirp);

// 返回：成功为 0；错误为 -1。
```

函数 closedir 关闭流并释放其所有的资源。图 10-11 展示了怎样用 readdir 来读取目录的内容。

```c
//code/io/readdir.c
#include "csapp.h"

int main(int argc, char **argv)
{
    DIR *streamp;
    struct dirent *dep;

    streamp = Opendir(argv[1]);

    errno = 0;
    while ((dep = readdir(streamp)) != NULL) {
        printf("Found file: %s\n", dep->d_name);
    }
    if (errno != 0)
        unix_error("readdir error");

    Closedir(streamp);
    exit(0);
}
```

#### 10.8 共享文件

内核用三个相关的数据结构来表示打开的文件：

+ **描述符表**（descriptor table）。每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。
+ **文件表**（file table）。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成（针对我们的目的）包括当前的文件位置、**引用计数**（reference count）（即当前指向该表项的描述符表项数），以及一个指向 v-node 表中对应表项的指针。关闭一个描述符会减少相应的文件表表项中的引用计数。内核不会删除这个文件表表项，直到它的引用计数为零。
+ **v-node 表**（v-node table）。同文件表一样，所有的进程共享这张 v-node 表。每个表项包含 stat 结构中的大多数信息，包括 st_mode 和 st_size 成员。

图 10-12 展示了一个示例，其中描述符 1 和 4 通过不同的打开文件表表项来引用两个不同的文件。这是一种典型的情况，没有共享文件，并且每个描述符对应一个不同的文件。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIZaQmB-3C37fF0RDpf%2F-MIZb9l9J1QuZDdPItQH%2F10-13%20%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB.png?alt=media&token=146d08da-0f92-48b6-b974-e9dc8848d3a7" alt="img" style="zoom:50%;" />

文件共享的图：这个例子展示了两个描述符通过两个打开文件表表项共享同一个磁盘文件

我们也能理解父子进程是如何共享文件的。假设在调用 fork 之前，父进程有如图 10-12 所示的打开文件。然后，图 10-14 展示了调用 fork 后的情况。子进程有一个父进程描述符表的副本。父子进程共享相同的打开文件表集合，因此共享相同的文件位置。一个很重要的结果就是，在内核删除相应文件表表项之前，父子进程必须都关闭了它们的描述符。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIZbE892OsvunybuK2S%2F-MIZbOpNsefhrtaXMvjC%2F10-14%20%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E7%BB%A7%E6%89%BF%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6.png?alt=media&token=7f32c770-ace6-4ce7-bb69-853e9d62367d" alt="img" style="zoom:50%;" />

> 图 10-14 子进程如何继承父进程的打开文件。初始状态如图 10-12 所示

**练习题 10.2**

假设磁盘文件 foobar.txt 由 6 个 ASCII 码字符 “foobar” 组成。那么，下列程序的输出是什么？

```c
#include "csapp.h"

int main()
{
    int fd1, fd2;
    char c;

    fd1 = Open("foobar.txt", O_RDONLY, 0);
    fd2 = Open("foobar.txt", O_RDONLY, 0);
    Read(fd1, &c, 1);
    Read(fd2, &c, 1);
    printf("c = %c\n", c);
    exit(0);
}
```

答案：

描述符 fd1 和 fd2 都有各自的打开文件表表项，所以每个描述符对于 foobar.txt 都有它自己的文件位置。因此，从 fd2 的读操作会读取 foobar.txt 的第一个字节，并输出

**c = f**

而不是像你开始可能想的

**c = o**

**练习题10.3** 

就像前面那样，假设磁盘文件 foobar.txt 由 6 个 ASCII 码字符 “foobar” 那么下列程序的输出是什么？

```c
#include "csapp.h"

int main()
{
    int fd;
    char c;

    fd = Open("foobar.txt", O_RDONLY, 0);
    if (Fork() == 0) {
        Read(fd, &c, 1);
        exit(0);
    }
    Wait(NULL);
    Read(fd, &c, 1);
    printf("c = %c\n", c);
    exit(0);
}
```

回想一下，子进程会继承父进程的描述符表，以及所有进程共享的同一个打开文件表。因此，描述符 fd 在父子进程中都指向同一个打开文件表表项。当子进程读取文件的第一个字节时，文件位置加 1。因此，父进程会读取第二个字节，而输出就是**c=o**。

#### 10.9 I/O重定向

Linuxshell 提供了 I/O 重定向操作符，允许用户将磁盘文件和标准输入输出联系起来。例如，键入

```shell
linux> ls > foo.txt
```

使得 shell 加载和执行 Is 程序，将标准输出重定向到磁盘文件 foo.txto 就如我们将在 11.5 节中看到的那样，当一个 Web 服务器代表客户端运行 CGI 程序时，它就执行一种相似类型的重定向。那么 I/O 重定向是如何工作的呢？一种方式是使用 dup2 函数。

```c
#include <unistd.h>

int dup2(int oldfd, int newfd);

// 返回：若成功则为非负的描述符，若出错则为 -1。
```

dup2 函数复制描述符表表项 oldfd 到描述符表表项 newfd，覆盖描述符表表项 newfd 以前的内容。如果 newfd 已经打开了，dup2 会在复制 oldfd 之前关闭 newfd。

假设在调用 **dup2(4,1)** 之前，我们的状态如图 10-12 所示，其中描述符 1（标准输出）对应于文件 A（比如一个终端），描述符 4 对应于文件 B（比如一个磁盘文件）。A 和 B 的引用计数都等于 1。图 10-15 显示了调用 **dup2(4,1)** 之后的情况。两个描述符现在都指向文件 B；文件 A 已经被关闭了，并且它的文件表和 v-node 表表项也已经被删除了；文件 B 的引用计数已经增加了。从此以后，任何写到标准输出的数据都被重定向到文件 B。

<img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIZbUMrq_gYTh7mys8U%2F-MIZbfV_VzVlDu9NUqgL%2F10-15%20%E9%80%9A%E8%BF%87%E9%87%8D%E5%AE%9A%E5%90%91%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E4%B9%8B%E5%90%8E%E7%9A%84%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png?alt=media&token=67524b7e-097b-4c8d-bb39-ccb6e4f0b57a" alt="img" style="zoom: 50%;" />

> 图 10-15 通过调用 dup2(4,1) 重定向标准输出之后的内核数据结构。初始状态如图 10-12 所示

> 旁注 - 左边和右边的 hoinkies
>
> 为了避免和其他括号类型操作符比如 “]” 和 “[” 相混淆，我们总是将 shell 的 “>” 操作符称为 “右 hoinky”，而将 “<” 操作符称为 “左 hoinky"。

**练习题 10.4**

如何用 dup2 将标准输入重定向到描述符 5？

**答案**

重定向标准输入（描述符 0）到描述符 5，我们将调用 **dup2(5, 0)** 或者等价的 **dup2(5, STDIN_FILENO)**。

**练习题 10.5**

假设磁盘文件 foobar.txt 由 6 个 ASCII 码字符 “foobar” 组成，那么下列程序的输出是什么？

```c
#include "csapp.h"

int main()
{
    int fd1, fd2;
    char c;

    fd1 = Open("foobar.txt", O_RDONLY, 0);
    fd2 = Open("foobar.txt", O_RDONLY, 0);
    Read(fd2, &c, 1);
    Dup2(fd2, fd1);
    Read(fd1, &c, 1);
    printf("c = %c\n", c);
    exit(0);
}
```

答案

第一眼你可能会想输出应该是

**c = f**

但是因为我们将 fd1 重定向到了 fd2，输出实际上是

**c = o**

#### 10.10 标准I/O

C 语言定义了一组高级输入输出函数，称为标准 I/O 库，为程序员提供了 Unix I/O 的较高级别的替代。这个库（libc）提供了打开和关闭文件的函数（fopen 和 fclose）、读和写字节的函数（fread 和 fwrite）、读和写字符串的函数（fgets 和 fputs），以及复杂的格式化的 I/O 函数（scanf 和 printf）。

标准 I/O 库将一个打开的文件模型化为一个流。对于程序员而言，一个流就是一个指向 FILE 类型的结构的指针。每个 ANSI C 程序开始时都有三个打开的流 stdin、stdout 和 stderr，分别对应于标准输入、标准输出和标准错误：

```c
#include <stdio.h>
extern FILE *stdin;    /* Standard input (descriptor 0) */
extern FILE *stdout;   /* Standard output (descriptor 1) */
extern FILE *stderr;   /* Standard error (descriptor 2) */
```

类型为 FILE 的流是对文件描述符和流缓冲区的抽象。流缓冲区的目的和 RIO 读缓冲区的一样：就是使开销较高的 Linux I/O 系统调用的数量尽可能得小。例如，假设我们有一个程序，它反复调用标准 I/O 的 getc 函数，每次调用返回文件的下一个字符。当第一次调用 getc 时，库通过调用一次 read 函数来填充流缓冲区，然后将缓冲区中的第一个字节返回给应用程序。只要缓冲区中还有未读的字节，接下来对 getc 的调用就能直接从流缓冲区得到服务。

#### 10.11 综合：我该使用哪些I/O函数

