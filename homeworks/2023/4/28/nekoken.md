# CSAPP note

> 第二遍重读：《CSAPP》

## 第1章 计算机系统漫游

计算机系统=硬件+系统软件

一个简单的C语言程序：`code/intro/hello.c`

```c
#include <stdio.h>
int main()
{
    printf("hello, world\n");
    return 0;
}
```

### 1.1 信息就是位+上下文

`hello`程序的生命周期是从一个源程序(源文件)开始的。

+ 程序员通过编辑器创建并保存文本文件(`hello.c`)。
+ 源程序由值0和1组成的位(比特)，8个位被组织成一组，称为字节。
+ 每个字节表示程序中的某些文本字符。

大部分计算机系统使用`ASCII`标准表示文本字符，实际上就是用一个唯一的单字节大小的整数值表示每个字符。

<img src="assets/image-20230327111319744.png" alt="image-20230327111319744" style="zoom:50%;" />

`hello.c`程序是以字节序列的方式储存在文件中的。每个字节都有一个整数值，对应于某些字符。

> 例如，第一个字节的整数值是35，它对应的就是字符`#`。第二个字节的整数值为 105，它对应的字符是`i`，依此类推。注意，每个文本行都是以一个看不见的换行符`\n`来结束的，它所对应的整数值为10。像hello.c这样只由ASCII字符构成的文件称为**文本文件**，所有其他文件都称为**二进制文件**。

`hello.c`的表示方法说明了一个基本思想：系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串**比特**表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的**上下文**。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。 作为程序员，我们需要了解数字的机器表示方式，因为它们与实际的整数和实数是不同的。它们是对真值的有限近似值，有时候会有意想不到的行为表现。

> C编程语言的起源
>
> 创建时间：1969～1973
>
> 创建人：贝尔实验室Dennis Ritchie
>
> 美国国家标准学会（American National Standards Institute，ANSI）在 1989 年颁布了ANSI C的标准，后来C语言的标准化成了国际标准化组织（International StandardsOrganization，ISO）的责任。这些标准定义了C语言和一系列函数库，即所谓的 **C 标准库**。Kernighan 和 Ritchie 在他们的经典著作中描述了 ANSI C，这本著作被人们满怀感情地称为 “K&R”。
>
> + C语言和Unix操作系统关系密切。C 从一开始就是作为一种用于 Unix 系统的程序语言开发出来的。大部分 Unix 内核（操作系统的核心部分），以及所有支撑工具和函数库都是用 C 语言编写的。20 世纪 70 年代后期到 80 年代初期，Unix 风行于高等院校，许多人开始接触 C 语言并喜欢上它。因为 Unix 几乎全部是用 C 编写的，它可以很方便地移植到新的机器上，这种特点为 C 和 Unix 赢得了更为广泛的支持。
> + C语言小而简单。C语言的设计是由一个人而非一个协会掌控的，因此这是一个简洁明了、没有什么冗赘的设计。K&R 这本书用大量的例子和练习描述了完整的 C 语言及其标准库，而全书不过  261 页。C 语言的简单使它相对而言易于学习，也易于移植到不同的计算机上。 
> + C 语言是设计用来实现 Unix 操作系统的。后来，其他人发现能够用这门语言无障碍地编写他们想要的程序。

### 1.2 程序被其他程序翻译成不同的格式

一个C程序的生命周期：hello`程序的生命周期是从一个高级C语言程序开始的，因为这种形式能够被人读懂。为了在系统上运行 hello.c 程序，每条C语句都必须被其他程序转化为一系列的低级**机器语言**指令。然后这些指令按照一种称为**可执行目标程序**的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为**可执行目标文件。**

在 Unix 系统上，从源文件到目标文件的转化是由**编译器驱动程序**完成的：

```shell
linux> gcc -o hello hello.c
```

GCC编译器驱动程序读取源程序文件`hello.c`，并把它翻译成一个可执行目标文件`hello`。这个翻译过程可分为四个阶段完成，如图 1-3 所示。执行这四个阶段的程序（**预处理器**、**编译器**、**汇编器**和**链接器**）一起构成了**编译系统**（compilation system）。

![image-20230327112202582](assets/image-20230327112202582.png)

+ 预处理阶段。预处理器(`cpp`)根据以字符`#`开头的命令，修改原始的 C 程序。比如`hello.c`中第1行的`#include <stdio.h>`命令告诉预处理器读取系统头文件`stdio.h`的内容，并把它直接插入程序文本中。结果就得到了另一个`C`程序，通常是以`.i`作为文件扩展名。

+ 编译阶段。编译器(`ccl`)将文本文件`hello.i`翻译成文本文件`hello.s`，它包含一个汇编语言程序。该程序包含函数`main`定义，如下所示：

  ```
  main:
      subq $8, %rsp
      movl $.LC0, %edi
      call puts
      movl $0, %eax
      addq $8, %rsp
      ret
  ```

  定义中 2～7 行的每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C编译器和 Fortran 编译器产生的输出文件用的都是一样的汇编语言。

+ 汇编阶段。汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做**可重定位目标程序**（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码。如果我们在文本编辑器中打开 hello.o文件，将看到一堆乱码。

+ 链接阶段。hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器（ld）就负责处理这种合并。结果就得到 hello 文件，它是一个**可执行目标文件**（或者简称为**可执行文件**），可以被加载到内存中，由系统执行。

> GNU项目
>
> GCC 是 GNU（GNU 是GNU's Not Unix 的缩写）项目开发出来的众多有用工具之一。GNU 项目是 1984 年由 Richard Stallman 发起的一个免税的慈善项目。该项目的目标非常宏大，就是开发出一个完整的类 Unix 的系统，其源代码能够不受限制地被修改和传播。GNU 项目已经开发出了一个包含 Unix 操作系统的所有主要部件的环境，但内核除外，内核是由 Linux 项目独立发展而来的。GNU 环境包括 EMACS 编辑器、GCC 编译器、GDB 调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。GCC 编译器已经发展到支持许多不同的语言，能够为许多不同的机器生成代码。支持的语言包括 C、C++、Fortran、Java、Pascal、面向对象 C 语言（Objective-C）和 Ada。
>
> GNU 项目取得了非凡的成绩，但是却常常被忽略。现代开放源码运动（通常和 Linux 联系在一起）的思想起源是 GNU 项目中自由软件（free software）的概念。（此处的free 为自由言论（free speech）中的“自由”之意，而非免费啤酒（free beer）中的“免费”之意。）而且，Linux 如此受欢迎在很大程度上还要归功于 GNU 工具，它们给 Linux 内核提供了环境。

### 1.3 了解编译系统如何工作是大有益处的

我们需要知道编译系统如何工作：

+ 优化程序性能。了解机器代码以及编译器将不同的C语句转化为机器代码的方式。
+ 理解链接时出现的错误。根据我们的经验，一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。比如，链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？如果你在不同的 C 文件中定义了名字相同的两个全局变量会发生什么？静态库和动态库的区别是什么？我们在命令行上排列库的顺序有什么影响？最严重的是，为什么有些链接错误直到运行时才会出现？根据我们的经验，一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。比如，链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？如果你在不同的 C 文件中定义了名字相同的两个全局变量会发生什么？静态库和动态库的区别是什么？我们在命令行上排列库的顺序有什么影响？最严重的是，为什么有些链接错误直到运行时才会出现？
+ 避免安全漏洞。多年来，缓冲区溢出错误是造成大多数网络和 Internet 服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。作为学习汇编语言的一部分，我们将在第 3 章中描述堆栈原理和缓冲区溢出错误。多年来，缓冲区溢出错误是造成大多数网络和 Internet 服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。作为学习汇编语言的一部分，我们将在第 3 章中描述堆栈原理和缓冲区溢出错误。

### 1.4 处理器度并解释存储在内存中的指令















## 第6章 存储器层次结构

一个简单的计算机系统模型：CPU执行指令，存储器系统为CPU存放指令和数据。

存储器系统(memory system)：具有不同容量、成本和访问时间的存储设备的层次结构。CPU寄存器保存最常用的数据。

高速缓存从





























































